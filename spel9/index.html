

<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/swordguy.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game5.js"></script>
        <script src="js/joy.js"></script>

    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
    
        <script>
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

      



            game = new Game5("Spelet");
            joy = new JoyStick('myCanvas');
            var audio = new Audio('sounds/cast3.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
          
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/war3.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
                
              }
          });

           
            
            
  
            document.addEventListener('click', (event) => {try{if(audio.paused){ audio.play();}}catch(error){};});

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false,
                space: false
            };
            
            document.addEventListener("keydown", function(e) {
                try{if(audio.paused){ audio.play();}}catch(error){};
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
                if (e.key === " ") keyState.space = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
                if (e.key === " ") keyState.space = false;
            });

            

            jump=false;
            count=0;
            jumplength=30;
            attack=false;
            acount=0;
            attacklength=25;
            coins=0;
            levelCompleteTimer = 0;
            showLevelComplete = false;
             
            var check = function(){
                if(canvas.width===10||canvas.width===300){canvas.width=document.body.clientWidth;canvas.height=document.body.clientHeight-8;}  
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                const bird=game.getobjecttype("swordguy");
                const rat=game.getobjecttype("rat");
                const abutton=game.getobjecttype("abutton");
                const bbutton=game.getobjecttype("bbutton");
                const coin=game.getobjecttype("coin");
                const apple=game.getobjecttype("apple");
                const coinicon=game.getobjecttype("coinicon");
                
                if(bird){
                    
                    bbutton.objects[0].x=canvas.width-400;bbutton.objects[0].y=canvas.height-400;
                    abutton.objects[0].x=canvas.width-250;abutton.objects[0].y=canvas.height-250;
                    
                    if(!mobileAndTabletCheck()){abutton.objects[0].x=canvas.width+300;abutton.objects[0].y=canvas.height+400;bbutton.objects[0].x=canvas.width+300;bbutton.objects[0].y=canvas.height+400;}
                    
                    
                    
                    game.updateanimation(ctx);
                    game.setcameraobj(bird.objects[0], canvas.width, null);
                    coinicon.objects[0].x=40;coinicon.objects[0].y=100;
                    ctx.font = "100px serif";
                    ctx.fillText(": "+coins, 150, 190);
                    
                    
                    
                    if (hitstopFrames > 0){
                        hitstopFrames--;
                        requestAnimationFrame(check);
                        return; // stoppa all logik den här framen
                    }
                    
                    
                    bird.objects[0].dual=40;
                    bird.objects[0].animation=0;
                    bird.objects[0].y=bird.objects[0].y+11;
                    if(keyState.d){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}
                    if(keyState.a){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}
                    if(keyState.w||abutton.objects[0].mousepressed==true){if(game.collideswith(bird.objects[0],"any","down"))jump=true; }
                    
                    
                    if("ontouchstart" in document.documentElement){
                            if(joy.GetDir()=="N"){}
                            else if(joy.GetDir()=="NE"){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}    
                            else if(joy.GetDir()=="E"){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}
                            else if(joy.GetDir()=="SE"){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}    
                            else if(joy.GetDir()=="S"){}
                            else if(joy.GetDir()=="SW"){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}    
                            else if(joy.GetDir()=="W"){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}    
                            else if(joy.GetDir()=="NW"){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}     
                            else if(joy.GetDir()=="C") {
                           
                            }
                        
                         joy.redraw();
                    }
                    if(jump==true){
                        bird.objects[0].animation=2;
                        if(count==0){}
                        if(count<jumplength){bird.objects[0].y=bird.objects[0].y-22;count++;}


                        if(game.collideswith(bird.objects[0],"any","down")&&count>2){
                            count=0;
                            jump=false;
                        }
                    }
                    if(keyState.space||bbutton.objects[0].mousepressed==true){attack=true;}
                    
                    if(attack==true){
                        if(acount===0){bird.images[3].ani=0;bird.images[3].counter = 0;}
                        bird.objects[0].animation=3;
                        if(acount<attacklength){acount++;}
                        else{attack=false;acount=0;}
                    }
                    
                    updateRats();
                    drawHealthBars();
                    
                    if(acount==20)  handleCombat("swordguy", ["rat"], 50);
                    updatePhysics(bird.objects[0]);
                    updateLoot(bird.objects[0]);
                    updateGoal(bird.objects[0]);
                    drawHUD(ctx);
                    
                    
                    let offx = 0, offy = 0;
                    if (shakeTime > 0){
                      shakeTime--;
                      offx = (Math.random()-0.5) * shakeMag;
                      offy = (Math.random()-0.5) * shakeMag;
                    }
                    ctx.restore();
                    ctx.save();
                    ctx.translate(offx, offy);
                    
                    
                }
                window.requestAnimationFrame(check);   
            };check();
            
const Heroes = new Set(["swordguy"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du använder för input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects().filter(o => o.name=="swordguy"|| o.name=="rat");
  for (const o of objs) {


    // defaultvärden om hälsa saknas
    if (o.maxhealth == null){ o.maxhealth = Heroes.has(o.name) ? 200 : 100;o.health = o.maxhealth;}
    if (o.health == null) o.health = o.maxhealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxhealth));

    // Värld → skärm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // öka svagt med zoom
    const offsetY = -10 * zoom; // ovanför objektet
    
    
    
    if(o.name=="swordguy"){
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Röd full bar
        ctx.fillStyle = "red";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Grön nuvarande HP
        ctx.fillStyle = "lime";
        ctx.fillRect(50, 50 + offsetY, 800 * hpPct, 30);

        // Kant
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.strokeRect(50, 50 + offsetY, 800, 30);
        
    }
    else{
    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Röd full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Grön nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
    }
    
  
    
    
    
  }
  
          
  
  
}
function handleCombat(attackerType, enemyTypes, damage) {
  const attackers = game.getobjecttype(attackerType).objects;
  for (const unit of attackers) {
    for (const enemyType of enemyTypes) {
      const target = game.collideswith(unit, enemyType, "ghost");
      if (target) {
        // === DAMAGE ===
        target.health -= damage;
        spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" });
        spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);

        // === JUICE ===
        hitStop(3);                // fryser ~3 frames (≈50 ms vid 60fps)
        cameraShake(20, 120);       // 120 ms shake
       
        // === KNOCKBACK ===
        const dir = (unit.x < target.x) ? +1 : -1;
        target.vx = dir * 20;  // kastas åt sidan
        target.vy = -25;       // lite upp i luften

        // === DÖD ===
        if (target.health <= 0) {
            
            
            // --- DROP LOOT ---
            const cx = target.x + target.dimx/2;
            const cy = target.y+target.dimy-30; // vid marken

            // Coin (100% chans)
            const c = game.addobject(game.getobjecttype("coin"),  cx, cy, 16,16, 0, false);
            c.vx = (Math.random()*2 - 1) * 1.2;
            c.vy = -6 - Math.random()*2;
            c.ay = 0.6;
            c.state = 'air';
            c.t = 0;
            c.pickDelay = 10;          // kan inte plockas direkt
            c.despawn = 60*20;         // ~20s

            // apple (30% chans)
            if (Math.random() < 0.3){
              const a = game.addobject(game.getobjecttype("apple"), cx+8, cy, 16,16, 0, false);
              a.vx = (Math.random()*2 - 1) * 1.0;
              a.vy = -7;
              a.ay = 0.6;
              a.state = 'air';
              a.t = 0;
              a.pickDelay = 10;
              a.despawn = 60*25;
            } 
            
            
            
            
            
            
            
            
            
          game.removeobject(game.getobjecttype(enemyType), target);
        }
      }
    }
  }
}
// ====== Tunables ======
const RAT_AI = {
  SPEED:        2.2,
  CHASE_SPEED:  3.2,
  SIGHT_X:     260,
  SIGHT_Y:      48,
  FORGET_X:    360,
  ATTACK_RANGE: 34,
  WINDUP_FR:     20,
  ATTACK_CD_FR: 26,
  TURN_CD_FR:   102,   // <— NYTT: “safe window” efter vändning
  ALERT_T_FR:   50,   // hur länge “!” visas när de får aggro
  SEP_RADIUS:   24,
  SEP_PUSH:      0.6
};

function initRat(r){
  if (r.ai) return;
  r.ai = {
    state:'patrol',
    dir: (r.fliped ? -1 : 1),
    vx:0, timer:0,
    target:null,
    turnCD:0,       // <— NYTT
    alertT:0,        // <— NYTT (för “!” och ev. ‘alert’-animation)
    vy:0
  };
}

function nearestPlayer(from){
  const t = game.getobjecttype('swordguy');
  if (!t || !t.objects || !t.objects.length) return null;
  let best=null,bd=1e9;
  for (const p of t.objects){
    const d = Math.abs(p.x-from.x) + Math.abs(p.y-from.y);
    if (d<bd){ bd=d; best=p; }
  }
  return best;
}

function ratSeparation(r, rats){
  for (const o of rats){
    if (o===r) continue;
    const dx=r.x-o.x, dy=r.y-o.y;
    const d2=dx*dx+dy*dy; if (d2===0) continue;
    if (d2 <= RAT_AI.SEP_RADIUS*RAT_AI.SEP_RADIUS){
      const d=Math.sqrt(d2), f=RAT_AI.SEP_PUSH*(1-d/RAT_AI.SEP_RADIUS);
      r.x += (dx/d)*f;
    }
  }
}

function updateRats(){
  const rats = game.getobjecttype('rat')?.objects || [];
  for (const r of rats){
    initRat(r);
    updatePhysics(r);
    r.animation = 0;
    // din grav / dual hack
    r.y += 11; 
    r.dual = 30;

    ratSeparation(r, rats);

    // target + avstånd
    if (!r.ai.target) r.ai.target = nearestPlayer(r);
    const P = r.ai.target;
    let dx=0, dy=0, distX=1e9;
    if (P){ dx=P.x-r.x; dy=P.y-r.y; distX=Math.abs(dx); }

    // tick timers
    if (r.ai.turnCD > 0){ r.ai.turnCD--;}
    if (r.alertT > 0) r.alertT--;

    // ——— Aggro/forget
    const seesPlayer = (P && distX < RAT_AI.SIGHT_X && Math.abs(dy) < RAT_AI.SIGHT_Y);
    if (r.ai.state==='patrol' && seesPlayer){ 
      r.ai.state = 'chase'; 
      r.alertT = RAT_AI.ALERT_T_FR;          // <— visa “!”
      // valfritt: setta animation “alert”
    }
    if (r.ai.state!=='patrol' && (!P || distX>RAT_AI.FORGET_X)){
      r.ai.state = 'patrol'; r.ai.target=null;
    }

    // ——— Vändhantering: om spelaren är på andra sidan → vänd + turn cooldown
    // Ger ett “backstab-fönster”: under turnCD kan råttan inte starta attack.
    const desiredDir = (dx < 0 ? -1 : 1);
    if (P){
      
      if (desiredDir !== r.ai.dir){
          if(r.ai.turnCD==0)r.ai.turnCD = RAT_AI.TURN_CD_FR
          if(r.ai.turnCD==1)r.ai.dir   = desiredDir;

      }
    }

    // ——— State machine
    switch (r.ai.state){
      case 'patrol': {
        r.ai.vx = RAT_AI.SPEED * r.ai.dir;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }
        break;
      }

      case 'chase': {
        r.ai.vx = RAT_AI.CHASE_SPEED * r.ai.dir;

        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }

        // Attack bara när:
        // - vi är inom range
        // - vi FAKTISKT FÖR rätten (dx*dir > 0)
        // - och vi är inte i vänd-cooldown
        if (P && game.collideswith(r, "swordguy", "ghost") && (dx * r.ai.dir) > 0 && r.ai.turnCD === 0){
          r.ai.state = 'windup';
          r.ai.timer = RAT_AI.WINDUP_FR;
          r.ai.vx = 0;
           r.animation = 1;
        }
        break;
      }

      case 'windup': {
        r.ai.vx = 0;
        r.animation = 1; // attack animation

        r.ai.timer--;

        // När halva windupen passerat → träffen går igenom
        if (r.ai.timer === Math.floor(RAT_AI.WINDUP_FR/2)) {
          handleCombat("rat", ["swordguy"], 10);
        }

        if (r.ai.timer <= 0) {
          r.ai.state = 'cooldown';
          r.ai.timer = RAT_AI.ATTACK_CD_FR;
        }
        break;
      }

      case 'cooldown': {
        r.ai.vx = -0.6 * r.ai.dir; // backa liten bit
        r.ai.timer--;
        if (r.ai.timer <= 0) r.ai.state = 'chase';
        break;
      }
    }

    // Rörelse + facing
    if(desiredDir === r.ai.dir)r.x += r.ai.vx;
    r.fliped = (r.ai.dir < 0);
    r.direction = r.fliped ? 'left' : 'right';
  }
}
function updatePhysics(obj){
  // Gravitation
  if(obj.vy<0)obj.vy += 1.2;         // grav styrka
  
  
  //if (obj.vy > 11) obj.vy = 11; // clamp fallhastighet

  // Rörelse
  obj.x += obj.vx;
  obj.y += obj.vy;

  // Friktion på marken
  if (game.collideswith(obj,"any","down")){
    //obj.vy = 0;
    //obj.y = Math.floor(obj.y/32)*32 - obj.h; // snap to tile
    obj.vx *= 0.85; // bromsa horisontellt
    if (Math.abs(obj.vx)<0.2) obj.vx = 0;
  }
}
// Camera shake
let shakeTime = 0, shakeMag = 0;
function cameraShake(mag, ms){
  shakeMag = mag;
  shakeTime = Math.floor(ms / (1000/60)); // räkna om ms → frames
}

// Hitstop
let hitstopFrames = 0;
function hitStop(fr){
  hitstopFrames = fr;
}
function groundSnapGhost(o){
  // Om din motor tillåter: if (game.collideswith(o,"ground","down")) return true;
  const grounds = game.getobjecttype("ground")?.objects || [];
  let bestY = +Infinity;
  for (const g of grounds){
    const overlapX = (o.x+o.dimx > g.x) && (o.x < g.x+g.dimx);
    if (!overlapX) continue;
    bestY = Math.min(bestY, g.y - o.dimy);
  }
  if (bestY < +Infinity && o.y >= bestY){
    o.y = bestY;
    return true;
  }
  return false;
}

function updateLoot(player){
  const sets = [game.getobjecttype("coin"), game.getobjecttype("apple")];
  for (const type of sets){
    const arr = type?.objects || [];
    for (let i=arr.length-1; i>=0; --i){
      const o = arr[i];
      o.t++; if (o.pickDelay>0) o.pickDelay--;
      if (o.despawn-- <= 0){ game.removeobject(type, o); continue; }

      if (o.state === 'air'){
        // enkel “fysik”
        o.vy += (o.ay || 0.6);
        o.x  += (o.vx || 0);
        o.y  += (o.vy || 0);

        // landa på mark (ghost → manuell snap)
        if (groundSnapGhost(o)){
          o.state = 'rest';
          o.vx = 0; o.vy = 0;
          o.baseY = o.y;
        }
      } else { // 'rest' → bob + magnet
        // bob
        o.y = o.baseY + Math.sin(o.t*0.2)*0.6;

        // magnet mot spelaren inom radie
        const px = player.x + player.dimx/2, py = player.y + player.dimy/2;
        const ox = o.x + o.dimx/2,          oy = o.y + o.dimy/2;
        const dx = px-ox, dy = py-oy;
        const d2 = dx*dx + dy*dy;
        const R = 140; // magnetradie px
        if (d2 < R*R){
          const invd = 1/Math.max(1, Math.sqrt(d2));
          const s = 3.0; // sugstyrka
          o.x += dx*invd*s;
          o.y += dy*invd*s;
        }
      }

      // pickup (ghost-kollision)
      if (o.pickDelay<=0){
        if (type === game.getobjecttype("coin") && game.collideswith(player,"coin","ghost")){
          game.removeobject(type,o);
          coins++;
          audio2("sounds/coin.mp3");
          continue;
        }
        if (type === game.getobjecttype("apple") && game.collideswith(player,"apple","ghost")){
          game.removeobject(type,o);
          player.health = Math.min(player.maxhealth, (player.health)+20);
          audio2("sounds/apple.mp3");
          continue;
        }
      }
    }
  }
}
function updateGoal(player){
    
   if(showLevelComplete){
    levelCompleteTimer--;
    if (levelCompleteTimer <= 1){
      showLevelComplete = false;
      game.currentmap = (game.currentmap+1) % game.maps.length;
      markStaticsDirty();
    }
  }  
    
    
    
  const p = game.collideswith(player, "portal", "ghost");
  if (p&&levelCompleteTimer===0){
    // Liten effekt innan bytet
    cameraShake(6, 200);
    //hitStop(5);
    levelCompleteTimer = 240;
    showLevelComplete=true;
    // Byt till nästa bana
    //game.currentmap = (game.currentmap + 1) % game.maps.length;
    //markStaticsDirty();


  }

  
  
  
}

function drawHUD(ctx){
  // Level complete overlay
  if (showLevelComplete){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "#FFD700";
    ctx.font = "bold 32px pixel, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("LEVEL COMPLETE!", canvas.width/2, canvas.height/2);
    ctx.restore();
  }
}




        </script>
        
        
        
        
        
        
        
        
        
    </body>
</html>
