

<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/swordguy.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game5.js"></script>
        <script src="js/joy.js"></script>

    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
    
        <script>
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

      



            game = new Game5("Spelet");
            joy = new JoyStick('myCanvas');
            var audio = new Audio('sounds/cast3.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
          
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/cast3.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
                
              }
          });

           
            
            
  
            document.addEventListener('click', (event) => {try{if(audio.paused&&gameState!=='game_over'){ audio.play();}}catch(error){};});

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false,
                space: false
            };
            
            document.addEventListener("keydown", function(e) {
                try{if(audio.paused&&gameState!=='game_over'){ audio.play();}}catch(error){};
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
                if (e.key === " ") keyState.space = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
                if (e.key === " ") keyState.space = false;
            });

            

            jump=false;
            count=0;
            jumplength=30;
            attack=false;
            acount=0;
            attacklength=25;
            coins=0;
            levelCompleteTimer = 0;
            showLevelComplete = false;
            let countercleared=0;
            let overworldPlayer = { node:0, from:0, progress:1, speed:0.02, x:0, y:0 };
            let gameState = 'overworld'; // 'play' | 'level_complete' | 'game_over'| "overworld" 
            // === Overworld data ===
            let overworldNodes = [
              {id:0, x:100, y:200, type:"level", cleared:false},
              {id:1, x:200, y:200, type:"town",  cleared:false},
              {id:2, x:300, y:200, type:"level", cleared:false},
              {id:3, x:400, y:150, type:"level", cleared:false}, // gren uppåt
            ];

            let overworldEdges = [
              [0,1], [1,2], [2,3] // kopplingar
            ];
            let OW = { adj: buildAdjList(overworldNodes, overworldEdges) };
            const overworldimage=new Image();
            overworldimage.src="images/overworld.png";
            let dstopper=false;
            let astopper=false;
            let wstopper=false;
            let sstopper=false;
            
            let stateTimer = 0;
            let wantRestart = false;
            let gemeovercounter=0;
            
            window.addEventListener('keydown', e => { if (e.code==='Space') if(gameState === 'game_over')wantRestart = true; });
            canvas.addEventListener('pointerdown', () => { if(gameState === 'game_over')wantRestart = true; });
             
            var check = function(){
                if(canvas.width===10||canvas.width===300){
                    canvas.width=document.body.clientWidth;
                    canvas.height=document.body.clientHeight-8;
                    overworldNodes = [
                             {id:0, x:canvas.width/8, y:canvas.height/2.5, type:"level", cleared:false,prereq:[]},
                             {id:1, x:canvas.width/2.2, y:canvas.height/2.3, type:"level",  cleared:false,prereq:[0]},
                             {id:2, x:canvas.width/2.1, y:canvas.height/6.5, type:"level", cleared:false,prereq:[1]},
                             {id:3, x:canvas.width/1.35, y:canvas.height/2.2, type:"level", cleared:false,prereq:[1]}, // gren uppåt
                             {id:4, x:canvas.width/2.2, y:canvas.height/1.3, type:"level", cleared:false,prereq:[1]},
                             {id:5, x:canvas.width/1.3, y:canvas.height/1.4, type:"level", cleared:false,prereq:[4]},
                             {id:6, x:canvas.width/1.1, y:canvas.height/1.1, type:"level", cleared:false,prereq:[5]},
                           ];

                   overworldEdges = [
                             [0,1], [1,2], [1,3],[1,4],[4,5],[5,6] // kopplingar
                           ];

                   OW = { adj: buildAdjList(overworldNodes, overworldEdges) };
              }  
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                const bird=game.getobjecttype("swordguy");
                const rat=game.getobjecttype("rat");
                const abutton=game.getobjecttype("abutton");
                const bbutton=game.getobjecttype("bbutton");
                const coin=game.getobjecttype("coin");
                const apple=game.getobjecttype("apple");
                const coinicon=game.getobjecttype("coinicon");
                
                if(bird){
                    bbutton.objects[0].x=canvas.width-400;bbutton.objects[0].y=canvas.height-400;
                    abutton.objects[0].x=canvas.width-250;abutton.objects[0].y=canvas.height-250;
                    if(!mobileAndTabletCheck()){abutton.objects[0].x=canvas.width+300;abutton.objects[0].y=canvas.height+400;bbutton.objects[0].x=canvas.width+300;bbutton.objects[0].y=canvas.height+400;}
                    game.updateanimation(ctx);
                }
                
                if(bird&&gameState !== 'overworld'){
                    if(!audio.src.endsWith("cast3.mp3")){audio.src = "sounds/cast3.mp3";}
                    
                    
                    coinicon.objects[0].x=40;coinicon.objects[0].y=100;
                    ctx.restore();
                    ctx.fillStyle="black";
                    ctx.font = "100px serif";
                    ctx.fillText(": "+coins, 150, 190);
                    
                    
                    
                    if (hitstopFrames > 0){
                        hitstopFrames--;
                        requestAnimationFrame(check);
                        return; // stoppa all logik den här framen
                    }
                    
                    if(bird.objects[0]){
                        game.setcameraobj(bird.objects[0], canvas.width, null);
                        bird.objects[0].dual=40;
                        bird.objects[0].animation=0;
                        bird.objects[0].y=bird.objects[0].y+11;
                        if(keyState.d){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}
                        if(keyState.a){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}
                        if(keyState.w||abutton.objects[0].mousepressed==true){if(game.collideswith(bird.objects[0],"any","down"))jump=true; }


                        
                        if(jump==true){
                            bird.objects[0].animation=2;
                            if(count==0){}
                            if(count<jumplength){bird.objects[0].y=bird.objects[0].y-22;count++;}


                            if(game.collideswith(bird.objects[0],"any","down")&&count>2){
                                count=0;
                                jump=false;
                            }
                        }
                        if(keyState.space||bbutton.objects[0].mousepressed==true){attack=true;}

                        if(attack==true){
                            if(acount===0){bird.images[3].ani=0;bird.images[3].counter = 0;}
                            bird.objects[0].animation=3;
                            if(acount<attacklength){acount++;}
                            else{attack=false;acount=0;}
                        }
                        updatePhysics(bird.objects[0]);
                        updateLoot(bird.objects[0]);
                        updateGoal(bird.objects[0]);
                    }
                    updateRats();
                    updateArchers();
                    drawHealthBars();
                    updateArrows();
                    if(acount==25)  handleCombat("swordguy", ["rat","archer"], 50);
                    
                    handleCombat("arrow", ["swordguy"], 10);
                    
                    
                    let offx = 0, offy = 0;
                    if (shakeTime > 0){
                      shakeTime--;
                      offx = (Math.random()-0.5) * shakeMag;
                      offy = (Math.random()-0.5) * shakeMag;
                    }
                    ctx.restore();
                    ctx.save();
                    ctx.translate(offx, offy);
                    
                    
                
                drawOverlays(ctx);
                gameover();
                }
                if (gameState==="overworld"){
                    
                   
                    if(!audio.src.endsWith("COV.mp3")){audio.src = 'sounds/COV.mp3';}
                    updateOverworld();
                    drawOverworld(ctx);
                }
                if("ontouchstart" in document.documentElement){
                    keyState.d=false;keyState.a = false;keyState.w=false;keyState.s = false;
                    if(joy.GetDir()=="N"){keyState.w = true;}
                    else if(joy.GetDir()=="NE"){keyState.d = true;}    
                    else if(joy.GetDir()=="E"){keyState.d = true;}
                    else if(joy.GetDir()=="SE"){keyState.d = true;}    
                    else if(joy.GetDir()=="S"){keyState.s = true;}
                    else if(joy.GetDir()=="SW"){keyState.a = true;}    
                    else if(joy.GetDir()=="W"){keyState.a = true;}    
                    else if(joy.GetDir()=="NW"){keyState.a = true;}     
                    else if(joy.GetDir()=="C") {

                    }

                 joy.redraw();
                }
                
                
                
                window.requestAnimationFrame(check);   
            };check();
            
const Heroes = new Set(["swordguy"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du använder för input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects().filter(o => o.name=="swordguy"|| o.name=="rat");
  for (const o of objs) {


    // defaultvärden om hälsa saknas
    if (o.maxhealth == null){ o.maxhealth = Heroes.has(o.name) ? 30 : 100;o.health = o.maxhealth;}
    if (o.health == null) o.health = o.maxhealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxhealth));

    // Värld → skärm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // öka svagt med zoom
    const offsetY = -10 * zoom; // ovanför objektet
    
    
    
    if(o.name=="swordguy"){
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Röd full bar
        ctx.fillStyle = "red";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Grön nuvarande HP
        ctx.fillStyle = "lime";
        ctx.fillRect(50, 50 + offsetY, 800 * hpPct, 30);

        // Kant
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.strokeRect(50, 50 + offsetY, 800, 30);
        
    }
    else{
    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Röd full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Grön nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
    }
    
  
    
    
    
  }
  
          
  
  
}
function handleCombat(attackerType, enemyTypes, damage) {
  const attackers = game.getobjecttype(attackerType).objects;
  for (const unit of attackers) {
    for (const enemyType of enemyTypes) {
      const target = game.collideswith(unit, enemyType, "ghost");
      if (target) {
          
        // === DAMAGE ===
        target.health -= damage;
        target.flashTimer = 12;
        spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" });
        spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);
        
        if(unit.name==="arrow")game.removeobject(game.getobjecttype(attackerType), unit);
        

        // === JUICE ===
        hitStop(3);                // fryser ~3 frames (≈50 ms vid 60fps)
        cameraShake(20, 120);       // 120 ms shake
        
        // === KNOCKBACK ===
        const dir = (unit.x < target.x) ? +1 : -1;
        target.vx = dir * 20;  // kastas åt sidan
        target.vy = -25;       // lite upp i luften

        // === DÖD ===
        if (target.health <= 0) {
            if(target.name=="swordguy"){
                gameState='game_over';
                audio.currentTime = 0;
                audio.pause();
                stateTimer=150;
                
            }
            
            // --- DROP LOOT ---
            const cx = target.x + target.dimx/2;
            const cy = target.y+target.dimy-30; // vid marken

            // Coin (100% chans)
            const c = game.addobject(game.getobjecttype("coin"),  cx, cy, 16,16, 0, false);
            c.vx = (Math.random()*2 - 1) * 1.2;
            c.vy = -6 - Math.random()*2;
            c.ay = 0.6;
            c.state = 'air';
            c.t = 0;
            c.pickDelay = 10;          // kan inte plockas direkt
            c.despawn = 60*20;         // ~20s

            // apple (30% chans)
            if (Math.random() < 0.3){
              const a = game.addobject(game.getobjecttype("apple"), cx+8, cy, 16,16, 0, false);
              a.vx = (Math.random()*2 - 1) * 1.0;
              a.vy = -7;
              a.ay = 0.6;
              a.state = 'air';
              a.t = 0;
              a.pickDelay = 10;
              a.despawn = 60*25;
            } 
            
            
            
            
            
            
            
            
            
          game.removeobject(game.getobjecttype(enemyType), target);
        }
      }
    }
  }
}
// ====== Tunables ======
const RAT_AI = {
  SPEED:        2.2,
  CHASE_SPEED:  3.2,
  SIGHT_X:     260,
  SIGHT_Y:      48,
  FORGET_X:    360,
  ATTACK_RANGE: 34,
  WINDUP_FR:     20,
  ATTACK_CD_FR: 26,
  TURN_CD_FR:   102,   // <— NYTT: “safe window” efter vändning
  ALERT_T_FR:   50,   // hur länge “!” visas när de får aggro
  SEP_RADIUS:   24,
  SEP_PUSH:      0.6
};

function initRat(r){
  if (r.ai) return;
  r.ai = {
    state:'patrol',
    dir: (r.fliped ? -1 : 1),
    vx:0, timer:0,
    target:null,
    turnCD:0,       // <— NYTT
    alertT:0,        // <— NYTT (för “!” och ev. ‘alert’-animation)
    vy:0
  };
}

function nearestPlayer(from){
  const t = game.getobjecttype('swordguy');
  if (!t || !t.objects || !t.objects.length) return null;
  let best=null,bd=1e9;
  for (const p of t.objects){
    const d = Math.abs(p.x-from.x) + Math.abs(p.y-from.y);
    if (d<bd){ bd=d; best=p; }
  }
  return best;
}

function ratSeparation(r, rats){
  for (const o of rats){
    if (o===r) continue;
    const dx=r.x-o.x, dy=r.y-o.y;
    const d2=dx*dx+dy*dy; if (d2===0) continue;
    if (d2 <= RAT_AI.SEP_RADIUS*RAT_AI.SEP_RADIUS){
      const d=Math.sqrt(d2), f=RAT_AI.SEP_PUSH*(1-d/RAT_AI.SEP_RADIUS);
      r.x += (dx/d)*f;
    }
  }
}

function updateRats(){
  const rats = game.getobjecttype('rat')?.objects || [];
  for (const r of rats){
    initRat(r);
    updatePhysics(r);
    r.animation = 0;
    // din grav / dual hack
    r.y += 11; 
    r.dual = 35;

    ratSeparation(r, rats);

    // target + avstånd
    if (!r.ai.target) r.ai.target = nearestPlayer(r);
    const P = r.ai.target;
    let dx=0, dy=0, distX=1e9;
    if (P){ dx=P.x-r.x; dy=P.y-r.y; distX=Math.abs(dx); }

    // tick timers
    if (r.ai.turnCD > 0){ r.ai.turnCD--;}
    if (r.alertT > 0) r.alertT--;

    // ——— Aggro/forget
    const seesPlayer = (P && distX < RAT_AI.SIGHT_X && Math.abs(dy) < RAT_AI.SIGHT_Y);
    if (r.ai.state==='patrol' && seesPlayer){ 
      r.ai.state = 'chase'; 
      r.alertT = RAT_AI.ALERT_T_FR;          // <— visa “!”
      // valfritt: setta animation “alert”
    }
    if (r.ai.state!=='patrol' && (!P || distX>RAT_AI.FORGET_X)){
      r.ai.state = 'patrol'; r.ai.target=null;
    }

    // ——— Vändhantering: om spelaren är på andra sidan → vänd + turn cooldown
    // Ger ett “backstab-fönster”: under turnCD kan råttan inte starta attack.
    const desiredDir = (dx < 0 ? -1 : 1);
    if (P){
      
      if (desiredDir !== r.ai.dir){
          if(r.ai.turnCD==0)r.ai.turnCD = RAT_AI.TURN_CD_FR
          if(r.ai.turnCD==1)r.ai.dir   = desiredDir;

      }
    }

    // ——— State machine
    switch (r.ai.state){
      case 'patrol': {
        r.ai.vx = RAT_AI.SPEED * r.ai.dir;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }
        break;
      }

      case 'chase': {
        r.ai.vx = RAT_AI.CHASE_SPEED * r.ai.dir;

        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }

        // Attack bara när:
        // - vi är inom range
        // - vi FAKTISKT FÖR rätten (dx*dir > 0)
        // - och vi är inte i vänd-cooldown
        if (P && game.collideswith(r, "swordguy", "ghost") && (dx * r.ai.dir) > 0 && r.ai.turnCD === 0){
          r.ai.state = 'windup';
          r.ai.timer = RAT_AI.WINDUP_FR;
          r.ai.vx = 0;
           r.animation = 1;
        }
        break;
      }

      case 'windup': {
        r.ai.vx = 0;
        r.animation = 1; // attack animation

        r.ai.timer--;

        // När halva windupen passerat → träffen går igenom
        if (r.ai.timer === Math.floor(RAT_AI.WINDUP_FR/2)) {
          handleCombat("rat", ["swordguy"], 10);
        }

        if (r.ai.timer <= 0) {
          r.ai.state = 'cooldown';
          r.ai.timer = RAT_AI.ATTACK_CD_FR;
        }
        break;
      }

      case 'cooldown': {
        r.ai.vx = -0.6 * r.ai.dir; // backa liten bit
        r.ai.timer--;
        if (r.ai.timer <= 0) r.ai.state = 'chase';
        break;
      }
    }

    // Rörelse + facing
    if(desiredDir === r.ai.dir)r.x += r.ai.vx;
    r.fliped = (r.ai.dir < 0);
    r.direction = r.fliped ? 'left' : 'right';
  }
}
function updatePhysics(obj){
  // Gravitation
  if(obj.vy<0)obj.vy += 1.2;         // grav styrka
  
  
  //if (obj.vy > 11) obj.vy = 11; // clamp fallhastighet

  // Rörelse
  obj.x += obj.vx;
  obj.y += obj.vy;

  // Friktion på marken
  if (game.collideswith(obj,"any","down")){
    //obj.vy = 0;
    //obj.y = Math.floor(obj.y/32)*32 - obj.h; // snap to tile
    obj.vx *= 0.85; // bromsa horisontellt
    if (Math.abs(obj.vx)<0.2) obj.vx = 0;
  }
}
// Camera shake
let shakeTime = 0, shakeMag = 0;
function cameraShake(mag, ms){
  shakeMag = mag;
  shakeTime = Math.floor(ms / (1000/60)); // räkna om ms → frames
}

// Hitstop
let hitstopFrames = 0;
function hitStop(fr){
  hitstopFrames = fr;
}
function groundSnapGhost(o){
  // Om din motor tillåter: if (game.collideswith(o,"ground","down")) return true;
  const grounds = game.getobjecttype("ground")?.objects || [];
  let bestY = +Infinity;
  for (const g of grounds){
    const overlapX = (o.x+o.dimx > g.x) && (o.x < g.x+g.dimx);
    if (!overlapX) continue;
    bestY = Math.min(bestY, g.y - o.dimy);
  }
  if (bestY < +Infinity && o.y >= bestY){
    o.y = bestY;
    return true;
  }
  return false;
}

function updateLoot(player){
  const sets = [game.getobjecttype("coin"), game.getobjecttype("apple")];
  for (const type of sets){
    const arr = type?.objects || [];
    for (let i=arr.length-1; i>=0; --i){
      const o = arr[i];
      o.t++; if (o.pickDelay>0) o.pickDelay--;
      if (o.despawn-- <= 0){ game.removeobject(type, o); continue; }

      if (o.state === 'air'){
        // enkel “fysik”
        o.vy += (o.ay || 0.6);
        o.x  += (o.vx || 0);
        o.y  += (o.vy || 0);

        // landa på mark (ghost → manuell snap)
        if (groundSnapGhost(o)){
          o.state = 'rest';
          o.vx = 0; o.vy = 0;
          o.baseY = o.y;
        }
      } else { // 'rest' → bob + magnet
        // bob
        o.y = o.baseY + Math.sin(o.t*0.2)*0.6;

        // magnet mot spelaren inom radie
        const px = player.x + player.dimx/2, py = player.y + player.dimy/2;
        const ox = o.x + o.dimx/2,          oy = o.y + o.dimy/2;
        const dx = px-ox, dy = py-oy;
        const d2 = dx*dx + dy*dy;
        const R = 140; // magnetradie px
        if (d2 < R*R){
          const invd = 1/Math.max(1, Math.sqrt(d2));
          const s = 3.0; // sugstyrka
          o.x += dx*invd*s;
          o.y += dy*invd*s;
        }
      }

      // pickup (ghost-kollision)
      if (o.pickDelay<=0){
        if (type === game.getobjecttype("coin") && game.collideswith(o,"swordguy","ghost")){
          game.removeobject(type,o);
          coins++;
          audio2("sounds/coin.mp3");
          continue;
        }
        if (type === game.getobjecttype("apple") && game.collideswith(o,"swordguy","ghost")){
          game.removeobject(type,o);
          player.health = Math.min(player.maxhealth, (player.health)+10);
          audio2("sounds/apple.mp3");
          continue;
        }
      }
    }
  }
}
function updateGoal(player){
    
   if(gameState === 'level_complete'){
    levelCompleteTimer--;
    if (levelCompleteTimer <= 1){
      markCleared(overworldPlayer.node);
      gameState = 'overworld';
      levelCompleteTimer=0;
      //game.currentmap = (game.currentmap+1) % game.maps.length;
      //markStaticsDirty();
    }
  }  
  const p = game.collideswith(player, "portal", "ghost");
  if (gameState !== 'overworld'&&p&&levelCompleteTimer===0){
    // Liten effekt innan bytet
    cameraShake(6, 200);
    //hitStop(5);
    levelCompleteTimer = 240;
    gameState = 'level_complete';
    // Byt till nästa bana
    //game.currentmap = (game.currentmap + 1) % game.maps.length;
    //markStaticsDirty();
  }

  
  
  
}
function gameover(){
    stateTimer--;
    if (wantRestart){
        game.load();
        audio.play();
        coins=0;
        wantRestart=false;
        gameState = 'overworld';
        gemeovercounter=20;
    }
}


function drawOverlays(ctx){
  if (gameState === 'level_complete' || gameState === 'game_over'){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = (gameState==='level_complete') ? "#FFD700" : "#ff4d4d";
    ctx.font = "bold 32px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(gameState==='level_complete' ? "LEVEL COMPLETE!" : "GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "16px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.fillText(gameState==='game_over' ? "Tap/Space för att försöka igen" : "", canvas.width/2, canvas.height/2+28);
    ctx.restore();
  }
  if (gameState === 'game_over'){
        // röd overlay
        const alpha = Math.min(1, (150 - stateTimer)/150);
        ctx.fillStyle = `rgba(255,0,0,${0.4*alpha})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.fillStyle = "#ff4d4d";
        ctx.font = "bold 32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText("Tap/Space för att försöka igen", canvas.width/2, canvas.height/2+28);
    }
}


// === Update overworld ===





// När du byter nod
function moveToNode(next){
  overworldPlayer.from = overworldPlayer.node;
  overworldPlayer.node = next;
  overworldPlayer.progress = 0; // starta resa
}

// Uppdatering varje frame
function updateOverworld(){
    

    
    
    
  const curIdx  = overworldPlayer.node;
  const fromIdx = overworldPlayer.from;
  const from    = overworldNodes[fromIdx];
  const to      = overworldNodes[curIdx];

  if (overworldPlayer.progress < 1){
    overworldPlayer.progress += overworldPlayer.speed; // 0.02 ≈ 50 frames = ~0.8s
    if (overworldPlayer.progress > 1) overworldPlayer.progress = 1;
  }

  // Lerp mellan from och to
  const t = overworldPlayer.progress;
  overworldPlayer.x = from.x + (to.x - from.x) * t;
  overworldPlayer.y = from.y + (to.y - from.y) * t;

  // Bara acceptera ny input om progress är klar
  if (t >= 1){
    handleOverworldInput();
  }
}

// Input (bara byta nod när man står still)
function handleOverworldInput(){
  if(!keyState.d)dstopper=false;
if(!keyState.a)astopper=false;
if(!keyState.w)wstopper=false;
if(!keyState.s)sstopper=false;


let ix = 0, iy = 0;
if (keyState.d&&dstopper===false) {ix += 1;dstopper=true;}
if (keyState.a&&astopper===false) {ix -= 1;astopper=true;}
if (keyState.s&&sstopper===false) {iy += 1;sstopper=true;}
if (keyState.w&&wstopper===false) {iy -= 1;wstopper=true;}

const next = chooseNeighborByInput(ix,iy);
if (next!=null) moveToNode(next);
gemeovercounter--;
if (gemeovercounter<1&&(keyState.space||(game.getobjecttype("abutton")&&game.getobjecttype("abutton").objects[0].mousepressed==true))){game.load().then(stuff).catch(console.error);  }




}
function stuff(){
    game.currentmap = overworldPlayer.node; markStaticsDirty(); gameState = "play";
    
    
    
}



function drawOverworld(ctx){
  
  ctx.drawImage(overworldimage,0,0,canvas.width,canvas.height);
  
  if(game.getobjecttype("abutton")&&mobileAndTabletCheck())ctx.drawImage(game.getobjecttype("abutton").images[0].getimage(),canvas.width-250,canvas.height-250,150,150);

  



  for (const n of overworldNodes){
    const unlocked = isUnlocked(n);
    ctx.save();
    ctx.globalAlpha = unlocked ? 0.00 : 0.85;
    ctx.fillStyle = unlocked ? "#cfd3d8" : "#9aa0a6"; // platta
    ctx.beginPath(); ctx.arc(n.x, n.y, 40, 0, Math.PI*2); ctx.fill();

    // hänglås på låsta noder
    if (!unlocked){
      ctx.fillStyle = "#333";
      ctx.fillRect(n.x-6, n.y-2, 12, 10);         // kropp
      ctx.beginPath(); ctx.arc(n.x, n.y-6, 6, Math.PI, 0); ctx.lineWidth=2; ctx.strokeStyle="#333"; ctx.stroke();
    }
    ctx.restore();

    // cleared markering (liten stjärna)
    if (n.cleared){
        countercleared++;
        ctx.globalAlpha=0.85;
      if(countercleared<100)  {
        ctx.fillStyle = "green";
        ctx.beginPath();  ctx.ellipse(n.x, n.y, 50, 100, Math.PI / 2, 0, Math.PI*2);ctx.fill();
      }
      if(countercleared>100)  {
        ctx.fillStyle = "lightgreen";
        ctx.beginPath();  ctx.ellipse(n.x, n.y, 50, 100, Math.PI / 2, 0, Math.PI*2);ctx.fill();
      }
      if(countercleared>200)countercleared=0;
    }
  }

  // rita spelarikonen vid overworldPlayer.x/y







  // player
  const p = overworldNodes[overworldPlayer.node];
  
 
  
  if(game.getobjecttype("swordguy"))ctx.drawImage(game.getobjecttype("swordguy").images[0].getimage(),overworldPlayer.x,overworldPlayer.y-80,80,80);


}

function buildAdjList(nodes, edges){
  const adj = Array(nodes.length).fill(0).map(()=>[]);
  for (const [a,b] of edges){ adj[a].push(b); adj[b].push(a); }
  return adj;
}
function isUnlocked(node){
  if (node.id === 0) return true;          // start
  if (!node.prereq || node.prereq.length===0) return true;
  return node.prereq.every(id => overworldNodes[id]?.cleared);
}
function markCleared(id){
  const n = overworldNodes.find(n=>n.id===id);
  if (n) n.cleared = true;
}
function chooseNeighborByInput(ix, iy){
  const cur = overworldNodes[overworldPlayer.node];
  let best=null, bestDot=0;

  for (const ni of OW.adj[overworldPlayer.node]){
    const n = overworldNodes[ni];
    if (!isUnlocked(n)) continue;                 // <<< låsta noder ignoreras
    const vx=n.x-cur.x, vy=n.y-cur.y;
    const len=Math.hypot(vx,vy)||1, dx=vx/len, dy=vy/len;
    const dot = dx*ix + dy*iy;
    if (dot>bestDot){ bestDot=dot; best=ni; }
  }
  return (bestDot>0.5)? best : null;
}
const ARCHER_AI = {
  SIGHT_X: 480,
  ATTACK_RANGE: 420,
  MIN_DISTANCE: 120,
  WINDUP_FR: 80,
  COOLDOWN_FR: 80,
  SPEED: 2.2,
};

function initArcher(r){
  if (r.ai) return;
  r.ai = { state:"patrol", dir:(r.fliped?-1:1), timer:0, target:null };
}

function updateArchers(){
  const archers = game.getobjecttype("archer")?.objects || [];
  const players = game.getobjecttype("swordguy")?.objects || [];
  if (!players.length) return;

  for (const r of archers){
    initArcher(r);

    // === fysik ===
    updatePhysics(r);
    r.y += 11;   // ditt “dual/grav hack”
    r.dual = 10;

    const p = players[0];
    const dx = p.x - r.x, dy = p.y - r.y;
    const dist = Math.hypot(dx,dy);
    const dir = dx<0 ? -1 : 1;
    r.fliped = dir<0; r.direction = (dir<0)?"left":"right";

    if (r.ai.timer>0) r.ai.timer--;

    switch(r.ai.state){
      case "patrol": {
        // enkel patrull → gå i riktning
        
        r.x += r.ai.dir * ARCHER_AI.SPEED;
        if (game.collideswith(r,"any","left"))  r.ai.dir = +1;
        if (game.collideswith(r,"any","right")) r.ai.dir = -1;

        if (dist < ARCHER_AI.SIGHT_X){
          r.ai.state = "aim";
        }
        break;
      }

      case "aim": {
        if (dist < ARCHER_AI.MIN_DISTANCE){
          // backa om spelaren kommer nära
          r.x -= dir * ARCHER_AI.SPEED;
        } else if (dist < ARCHER_AI.ATTACK_RANGE && r.ai.timer===0){
          r.ai.state = "windup";
          r.ai.timer = ARCHER_AI.WINDUP_FR;
          r.animation = 1; // sikta
        } else {
          // för långt bort → gå mot spelaren
          r.x += dir * ARCHER_AI.SPEED*0.6;
        }
        break;
      }

      case "windup": {
        r.ai.timer--;
        r.animation = 1; // “dra strängen”
        if (r.ai.timer<=0){
          shootArrow(r.x, r.y, dir);
          r.ai.state="cooldown";
          r.ai.timer=ARCHER_AI.COOLDOWN_FR;
        }
        break;
      }

      case "cooldown": {
        r.ai.timer--;
        r.animation = 0; // idle
        if (r.ai.timer<=0) r.ai.state="aim";
        break;
      }
    }
  }
}

function shootArrow(x,y,dir){
  const arrow = game.addobject(game.getobjecttype("arrow"), x, y, game.getobjecttype("arrow").standarddimx, game.getobjecttype("arrow").standarddimy, 0, dir<0);

  
    // fysik-komponent
  arrow.vx = dir * 18.5;   // horisontell fart
  arrow.vy = -1.0;        // liten båge uppåt
  arrow.ay = 0.1;        // gravitation
  arrow.life = 60*3;      // 3s livstid
  arrow.damage = 8;       // skada på spelaren
  arrow.stuck = false;    // när den fastnar i mark/vägg
  
  
}
function updateArrows(){
  const A = game.getobjecttype("arrow");
  const P = game.getobjecttype("swordguy")?.objects?.[0];
  if (!A) return;

  for (let i = A.objects.length - 1; i >= 0; --i){
    const a = A.objects[i];

    // döda gamla pilar
    if (--a.life <= 0){ game.removeobject(A, a); continue; }

    if (!a.stuck){
      // fysik
      a.vy += (a.ay || 0);
      if (a.vy > 14) a.vy = 14;

      a.x += (a.vx || 0);
      a.y += (a.vy || 0);

      // kollision med världen (vänster/höger/mark)
      if (!game.collideswith(a, "archer", "ghost")&&game.collideswith(a, "any", "ghost")) {
       
        // fastna i ytan: nolla hastigheten, kortare liv
        a.vx = 0; a.vy = 0; a.ay = 0; a.stuck = true;
        a.life = Math.min(a.life, 45);
        // valfritt: gnist-partiklar här
      }


    }


  }
}

        </script>
        
        
        
        
        
        
        
        
        
    </body>
</html>
