

<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/swordguy.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game5.js"></script>
        <script src="js/joy.js"></script>

    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
    
        <script>
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

      



            game = new Game5("Spelet");
            joy = new JoyStick('myCanvas');
            var audio = new Audio('sounds/cast3.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
          
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/cast3.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
                
              }
          });

           
            
            
  
            document.addEventListener('click', (event) => {try{if(audio.paused&&gameState!=='game_over'){ audio.play();}}catch(error){};});

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false,
                space: false
            };
            
            document.addEventListener("keydown", function(e) {
                try{if(audio.paused&&gameState!=='game_over'){ audio.play();}}catch(error){};
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
                if (e.key === " ") keyState.space = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
                if (e.key === " ") keyState.space = false;
            });

            

            jump=false;
            climb =false;
            count=0;
            jumplength=30;
            attack=false;
            acount=0;
            attacklength=25;
            coins=0;
            levelCompleteTimer = 0;
            showLevelComplete = false;
            let countercleared=0;
            let overworldPlayer = { node:0, from:0, progress:1, speed:0.02, x:0, y:0 };
            let gameState = 'overworld'; // 'play' | 'level_complete' | 'game_over'| "overworld" 
            // === Overworld data ===
            let overworldNodes = [
              {id:0, x:100, y:200, type:"level", cleared:false},
              {id:1, x:200, y:200, type:"town",  cleared:false},
              {id:2, x:300, y:200, type:"level", cleared:false},
              {id:3, x:400, y:150, type:"level", cleared:false}, // gren uppåt
            ];

            let overworldEdges = [
              [0,1], [1,2], [2,3] // kopplingar
            ];
            let OW = { adj: buildAdjList(overworldNodes, overworldEdges) };
            const overworldimage=new Image();
            overworldimage.src="images/overworld.png";
            let dstopper=false;
            let astopper=false;
            let wstopper=false;
            let sstopper=false;
            
            let stateTimer = 0;
            let wantRestart = false;
            let gemeovercounter=0;
            
            window.addEventListener('keydown', e => { if (e.code==='Space') if(gameState === 'game_over')wantRestart = true; });
            canvas.addEventListener('pointerdown', () => { if(gameState === 'game_over')wantRestart = true; });
             
            var check = function(){
                if(canvas.width===10||canvas.width===300){
                    canvas.width=document.body.clientWidth;
                    canvas.height=document.body.clientHeight-8;
                    canvas.style.width  = canvas.width + "px";
                    canvas.style.height = canvas.height + "px";
                    
                    overworldNodes = [
                             {id:0, x:canvas.width/8, y:canvas.height/2.5, type:"level", cleared:false,prereq:[]},
                             {id:1, x:canvas.width/2.2, y:canvas.height/2.3, type:"level",  cleared:false,prereq:[0]},
                             {id:2, x:canvas.width/2.1, y:canvas.height/6.5, type:"level", cleared:false,prereq:[1]},
                             {id:3, x:canvas.width/1.35, y:canvas.height/2.2, type:"level", cleared:false,prereq:[1]}, // gren uppåt
                             {id:4, x:canvas.width/2.2, y:canvas.height/1.3, type:"level", cleared:false,prereq:[1]},
                             {id:5, x:canvas.width/1.3, y:canvas.height/1.4, type:"level", cleared:false,prereq:[4]},
                             {id:6, x:canvas.width/1.1, y:canvas.height/1.1, type:"level", cleared:false,prereq:[5]},
                           ];

                   overworldEdges = [
                             [0,1], [1,2], [1,3],[1,4],[4,5],[5,6] // kopplingar
                           ];

                   OW = { adj: buildAdjList(overworldNodes, overworldEdges) };
                   
              }  
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 

                const bird=game.getobjecttype("swordguy");
                const rat=game.getobjecttype("rat");
                const abutton=game.getobjecttype("abutton");
                const bbutton=game.getobjecttype("bbutton");
                const coin=game.getobjecttype("coin");
                const apple=game.getobjecttype("apple");
                const coinicon=game.getobjecttype("coinicon");
                
                if(bird){
                    bbutton.objects[0].x=canvas.width-400;bbutton.objects[0].y=canvas.height-400;
                    abutton.objects[0].x=canvas.width-250;abutton.objects[0].y=canvas.height-250;
                    if(!mobileAndTabletCheck()){abutton.objects[0].x=canvas.width+300;abutton.objects[0].y=canvas.height+400;bbutton.objects[0].x=canvas.width+300;bbutton.objects[0].y=canvas.height+400;}
                    game.updateanimation(ctx);
                }
                
                if(bird&&gameState !== 'overworld'){
                    if(!audio.src.endsWith("cast3.mp3")&&(!audio.src.endsWith("drak.mp3")||game.getobjecttype("warlock").objects.length===0)){audio.src = "sounds/cast3.mp3";audio.play();}
                    
                    
                    coinicon.objects[0].x=40;coinicon.objects[0].y=100;
                    ctx.restore();
                    ctx.fillStyle="black";
                    ctx.font = "100px serif";
                    ctx.fillText(": "+coins, 150, 190);
                    
                    
                    
                    if (hitstopFrames > 0){
                        hitstopFrames--;
                        requestAnimationFrame(check);
                        return; // stoppa all logik den här framen
                    }
                    
                    if(bird.objects[0]){
                        game.setcameraobj(bird.objects[0], canvas.width, null);
                        bird.objects[0].dual=40;
                        bird.objects[0].animation=0;
                        if(climb==false)bird.objects[0].y=bird.objects[0].y+11;
                        if(keyState.d){bird.objects[0].x+=5;bird.objects[0].fliped=false;bird.objects[0].animation=1;bird.objects[0].direction="right";}
                        if(keyState.a){bird.objects[0].x-=5;bird.objects[0].fliped=true;bird.objects[0].animation=1;bird.objects[0].direction="left";}
                        if("ontouchstart" in document.documentElement){if(abutton.objects[0].mousepressed==true){if(game.collideswith(bird.objects[0],"any","down"))jump=true; }}
                        else{if(keyState.w){if(game.collideswith(bird.objects[0],"any","down"))jump=true; }}

                        
                        if(jump==true){
                            bird.objects[0].animation=2;
                            if(count==0){}
                            if(count<jumplength){bird.objects[0].y=bird.objects[0].y-22;count++;}


                            if(game.collideswith(bird.objects[0],"any","down")&&count>2){
                                count=0;
                                jump=false;
                            }
                        }
                        if(keyState.space||bbutton.objects[0].mousepressed==true){attack=true;}

                        if(attack==true){
                            if(acount===0){bird.images[3].ani=0;bird.images[3].counter = 0;}
                            bird.objects[0].animation=3;
                            if(acount<attacklength){acount++;}
                            else{attack=false;acount=0;}
                        }
                        updatePhysics(bird.objects[0],true);
                        updateLoot(bird.objects[0]);
                        updateGoal(bird.objects[0]);
                        
                        if(game.collideswiths(bird.objects[0],"rope")){
                            if(keyState.w||keyState.s){climb=true;jump=false;}
                            if(keyState.w)bird.objects[0].y-=3;
                            if(keyState.s)bird.objects[0].y+=3;
                        }
                        else{climb=false;}
                        
                        
                    }
                    updateRats();
                    updateArchers();
                    drawHealthBars();
                    updateArrows();
                    updateShields();
                    updateBats();
                    updateMages();
                    runScheduled();
                    updateWarlocks();
                    updateFireballs();
                    updateFirePillars();
                    
                    if(acount==25)  handleCombat("swordguy", ["rat","archer","tank","bat","mage","warlock"], 50);
                    
                    handleCombat("arrow", ["swordguy"], 10);
                    
                    
                    let offx = 0, offy = 0;
                    if (shakeTime > 0){
                      shakeTime--;
                      offx = (Math.random()-0.5) * shakeMag;
                      offy = (Math.random()-0.5) * shakeMag;
                    }
                    ctx.restore();
                    ctx.save();
                    ctx.translate(offx, offy);
                    
                    
                
                drawOverlays(ctx);
                gameover();
                }
                if (gameState==="overworld"){
                    
                   
                    if(!audio.src.endsWith("COV.mp3")){audio.src = 'sounds/COV.mp3';audio.play();}
                    updateOverworld();
                    drawOverworld(ctx);
                }
                if("ontouchstart" in document.documentElement){
                    keyState.d=false;keyState.a = false;keyState.w=false;keyState.s = false;
                    if(joy.GetDir()=="N"){keyState.w = true;}
                    else if(joy.GetDir()=="NE"){keyState.d = true;}    
                    else if(joy.GetDir()=="E"){keyState.d = true;}
                    else if(joy.GetDir()=="SE"){keyState.d = true;}    
                    else if(joy.GetDir()=="S"){keyState.s = true;}
                    else if(joy.GetDir()=="SW"){keyState.a = true;}    
                    else if(joy.GetDir()=="W"){keyState.a = true;}    
                    else if(joy.GetDir()=="NW"){keyState.a = true;}     
                    else if(joy.GetDir()=="C") {

                    }

                 joy.redraw();
                }
                
                
                
                window.requestAnimationFrame(check);   
            };check();
            
const Heroes = new Set(["swordguy"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du använder för input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects().filter(o => o.name=="swordguy"|| o.name=="rat"|| o.name=="archer"|| o.name=="tank"|| o.name=="bat"|| o.name=="mage"|| o.name=="warlock");
  for (const o of objs) {
      if(!o.isvisable)continue;

    // defaultvärden om hälsa saknas
    if (o.maxhealth == null&&o.name=="warlock"){o.maxhealth = 400;o.health = o.maxhealth;}
    if (o.maxhealth == null&&o.name=="tank"){o.maxhealth = 200;o.health = o.maxhealth;}
    if (o.maxhealth == null&&(o.name=="mage"||o.name=="bat")){o.maxhealth = 50;o.health = o.maxhealth;}
    if (o.maxhealth == null){ o.maxhealth = Heroes.has(o.name) ? 30 : 100;o.health = o.maxhealth;}
    if (o.health == null) o.health = o.maxhealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxhealth));

    // Värld → skärm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // öka svagt med zoom
    const offsetY = -10 * zoom; // ovanför objektet
    
    
    
    if(o.name=="swordguy"){
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Röd full bar
        ctx.fillStyle = "red";
        ctx.fillRect(50, 50 + offsetY, 800, 30);

        // Grön nuvarande HP
        ctx.fillStyle = "lime";
        ctx.fillRect(50, 50 + offsetY, 800 * hpPct, 30);

        // Kant
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.strokeRect(50, 50 + offsetY, 800, 30);
        
    }
    else{
    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Röd full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Grön nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
    }
    
  
    
    
    
  }
  
          
  
  
}
function handleCombat(attackerType, enemyTypes, damage) {
  function attackFromFront(attacker, defender){
  const ddir = defender.fliped ? -1 : 1;
  const ax = attacker.x + attacker.dimx/2;
  const dx = ax - (defender.x + defender.dimx/2);
  return (dx * ddir > 0);
}

function warlockFrontOpen(w){
  // endast under OFF-fönstret
  return w.ai?.phase === 3 && w.ai?.shieldState === 'off';
}  
    
    
    
  const attackers = game.getobjecttype(attackerType).objects;
  for (const unit of attackers) {
    for (const enemyType of enemyTypes) {
      const target = game.collideswith(unit, enemyType, "ghost");
      if (target) {
          
          if (enemyType === "tank"){
                if (attackFromFront(unit, target)){
                    // Blockerat!
                    spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 8, "#aaa");
                    //playSound("clank");
                    continue; // hoppa över damage
                }
        }
        if (enemyType === 'warlock'){
            const front = attackFromFront(unit, target);

            if (target.ai?.phase === 3 && front){
              if (target.ai.shieldState === 'on' || target.ai.shieldState === 'warn'){
                // block → flash blå
                target.flashTimer = 6;
                target.flashTimercolor = "#rgba(168, 199, 255, 0.8)";

                spawnHitParticles(target.x+target.dimx/2, target.y, 6, "#a8c7ff");
                cameraShake(2,80);

                // knockback på spelaren
                const k = (unit.x<target.x)?-1:+1;
                unit.vx = (unit.vx||0)+k*2.5;
                unit.vy = -3;

                return; // block = ingen skada
              }
              // shieldState === 'off' ⇒ attack går igenom
            }
          }
          
        // === DAMAGE ===
        target.health -= damage;
        target.flashTimer = 12;
        spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" });
        spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);
        
        if(unit.name==="arrow")game.removeobject(game.getobjecttype(attackerType), unit);
        

        // === JUICE ===
        hitStop(3);                // fryser ~3 frames (≈50 ms vid 60fps)
        cameraShake(20, 120);       // 120 ms shake
        
        // === KNOCKBACK ===
        const dir = (unit.x < target.x) ? +1 : -1;
        target.vx = dir * 20;  // kastas åt sidan
        target.vy = -25;       // lite upp i luften

        // === DÖD ===
        if (target.health <= 0) {
            if(target.name=="swordguy"){
                gameState='game_over';
                audio.currentTime = 0;
                audio.pause();
                stateTimer=150;
                
            }
            
            // --- DROP LOOT ---
            const cx = target.x + target.dimx/2;
            const cy = target.y+target.dimy-30; // vid marken

            // Coin (100% chans)
            const c = game.addobject(game.getobjecttype("coin"),  cx, cy, 16,16, 0, false);
            c.vx = (Math.random()*2 - 1) * 1.2;
            c.vy = -6 - Math.random()*2;
            c.ay = 0.6;
            c.state = 'air';
            c.t = 0;
            c.pickDelay = 10;          // kan inte plockas direkt
            c.despawn = 60*20;         // ~20s

            // apple (30% chans)
            if (Math.random() < 0.3){
              const a = game.addobject(game.getobjecttype("apple"), cx+8, cy, 16,16, 0, false);
              a.vx = (Math.random()*2 - 1) * 1.0;
              a.vy = -7;
              a.ay = 0.6;
              a.state = 'air';
              a.t = 0;
              a.pickDelay = 10;
              a.despawn = 60*25;
            } 
            
            
            
            
            
            
            
            
            
          game.removeobject(game.getobjecttype(enemyType), target);
        }
      }
    }
  }
}
// ====== Tunables ======
const RAT_AI = {
  SPEED:        2.2,
  CHASE_SPEED:  3.2,
  SIGHT_X:     260,
  SIGHT_Y:      48,
  FORGET_X:    360,
  ATTACK_RANGE: 34,
  WINDUP_FR:     20,
  ATTACK_CD_FR: 26,
  TURN_CD_FR:   102,   // <— NYTT: “safe window” efter vändning
  ALERT_T_FR:   50,   // hur länge “!” visas när de får aggro
  SEP_RADIUS:   24,
  SEP_PUSH:      0.6
};

function initRat(r){
  if (r.ai) return;
  r.ai = {
    state:'patrol',
    dir: (r.fliped ? -1 : 1),
    vx:0, timer:0,
    target:null,
    turnCD:0,       // <— NYTT
    alertT:0,        // <— NYTT (för “!” och ev. ‘alert’-animation)
    vy:0,
    
    losCD: 0,
    canSee: false,
    lastSeenX:r.x,
    lastSeenY:r.y,
    huntT: 0,
    tturn:false,
    hurt: r.health
    
  };
}

function nearestPlayer(from){
  const t = game.getobjecttype('swordguy');
  if (!t || !t.objects || !t.objects.length) return null;
  let best=null,bd=1e9;
  for (const p of t.objects){
    const d = Math.abs(p.x-from.x) + Math.abs(p.y-from.y);
    if (d<bd){ bd=d; best=p; }
  }
  return best;
}

function ratSeparation(r, rats){
  for (const o of rats){
    if (o===r) continue;
    const dx=r.x-o.x, dy=r.y-o.y;
    const d2=dx*dx+dy*dy; if (d2===0) continue;
    if (d2 <= RAT_AI.SEP_RADIUS*RAT_AI.SEP_RADIUS){
      const d=Math.sqrt(d2), f=RAT_AI.SEP_PUSH*(1-d/RAT_AI.SEP_RADIUS);
      r.x += (dx/d)*f;
    }
  }
}

function updateRats(){
  const rats = game.getobjecttype('rat')?.objects || [];
  for (const r of rats){
    if(!r.isonscreen)continue;  
      
    initRat(r);
    updatePhysics(r);
    r.animation = 0;
    // din grav / dual hack
    r.y += 11; 
    r.dual = 35;

    ratSeparation(r, rats);

    // target + avstånd
    if (!r.ai.target) r.ai.target = nearestPlayer(r);
    const P = r.ai.target;
    let dx=0, dy=0, distX=1e9;
    if (P){ dx=P.x-r.x; dy=P.y-r.y; distX=Math.abs(dx); }

    // tick timers
    if (r.ai.turnCD > 0){ r.ai.turnCD--;}
    if (r.alertT > 0) r.alertT--;

    // ——— LOS (uppdateras inte varje frame)
    if (r.ai.losCD > 0) r.ai.losCD--;
    if (r.ai.losCD === 0 && P && r.isonscreen){
      r.ai.losCD = 6; // testa 4..10 (lägre = snabbare reaktion, mer CPU)
      const gridStat = window.G5?.gridStat;

      const eyeX = r.x + r.dimx*0.5;
      const eyeY = r.y + r.dimy*0.35;
      const px   = P.x + P.dimx*0.5;
      const py   = P.y + P.dimy*0.35;

      r.ai.canSee = window.G5?.hasLineOfSight?.(gridStat, eyeX, eyeY, px, py, {
        pad: 2,
        filter: (S) => true // här kan du senare ignorera "see-through" walls
      }) ?? true;
    }
    if(!r.ai.canSee)r.isvisable=false;
    else r.isvisable=true;
    
    const desiredDir = (dx < 0 ? -1 : 1);
    const seesPlayer = (P && distX < RAT_AI.SIGHT_X && Math.abs(dy) < RAT_AI.SIGHT_Y && r.ai.canSee&&r.ai.dir=== desiredDir);
    if (r.ai.state==='patrol' && seesPlayer){ 
      r.ai.state = 'chase'; 
      r.alertT = RAT_AI.ALERT_T_FR;          // <— visa “!”
     r.ai.tturn=true;
      // valfritt: setta animation “alert”
    }
    if (r.ai.state!=='patrol' && (!P || (distX>RAT_AI.FORGET_X && r.ai.tturn===false))){
      r.ai.state = 'patrol'; r.ai.target=null;
    }

    // ——— Vändhantering: om spelaren är på andra sidan → vänd + turn cooldown
    // Ger ett “backstab-fönster”: under turnCD kan råttan inte starta attack.
    
    if (P){
      
      if (desiredDir !== r.ai.dir&&(r.ai.tturn||r.ai.hurt!==r.health)){
          
          if(r.ai.turnCD==0)r.ai.turnCD = RAT_AI.TURN_CD_FR
          if(r.ai.turnCD==1){r.ai.dir   = desiredDir;r.ai.tturn=false;r.ai.state = 'patrol';r.ai.hurt=r.health;}

      }
    }

    // ——— State machine
    switch (r.ai.state){
      case 'patrol': {
        r.ai.vx = RAT_AI.SPEED * r.ai.dir;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }
        break;
      }

      case 'chase': {
        r.ai.vx = RAT_AI.CHASE_SPEED * r.ai.dir;
        r.ai.tturn=true;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }

        // Attack bara när:
        // - vi är inom range
        // - vi FAKTISKT FÖR rätten (dx*dir > 0)
        // - och vi är inte i vänd-cooldown
        if (P && game.collideswith(r, "swordguy", "ghost") && (dx * r.ai.dir) > 0 && r.ai.turnCD === 0){
          r.ai.state = 'windup';
          r.ai.timer = RAT_AI.WINDUP_FR;
          r.ai.vx = 0;
           r.animation = 1;
        }
        break;
      }

      case 'windup': {
        r.ai.vx = 0;
        r.animation = 1; // attack animation

        r.ai.timer--;

        // När halva windupen passerat → träffen går igenom
        if (r.ai.timer === Math.floor(RAT_AI.WINDUP_FR/2)) {
          handleCombat("rat", ["swordguy"], 10);
        }

        if (r.ai.timer <= 0) {
          r.ai.state = 'cooldown';
          r.ai.timer = RAT_AI.ATTACK_CD_FR;
        }
        break;
      }

      case 'cooldown': {
        r.ai.vx = -0.6 * r.ai.dir; // backa liten bit
        r.ai.timer--;
        if (r.ai.timer <= 0) r.ai.state = 'chase';
        break;
      }
    }
    
    // Rörelse + facing
    if(desiredDir === r.ai.dir|| (r.ai.state=='patrol'&&r.ai.tturn==false))r.x += r.ai.vx;

    r.fliped = (r.ai.dir < 0);
    r.direction = r.fliped ? 'left' : 'right';
    
    
  }
}
function updatePhysics(obj,player){
  // Gravitation
  if(player && climb==true){obj.vy=0;}else if(obj.vy<0)obj.vy += 1.2;         // grav styrka
  
  
  //if (obj.vy > 11) obj.vy = 11; // clamp fallhastighet

  // Rörelse
  obj.x += obj.vx;
  obj.y += obj.vy;

  // Friktion på marken
  if (game.collideswith(obj,"any","down")){
    //obj.vy = 0;
    //obj.y = Math.floor(obj.y/32)*32 - obj.h; // snap to tile
    obj.vx *= 0.85; // bromsa horisontellt
    if (Math.abs(obj.vx)<0.2) obj.vx = 0;
  }
}
// Camera shake
let shakeTime = 0, shakeMag = 0;
function cameraShake(mag, ms){
  shakeMag = mag;
  shakeTime = Math.floor(ms / (1000/60)); // räkna om ms → frames
}

// Hitstop
let hitstopFrames = 0;
function hitStop(fr){
  hitstopFrames = fr;
}
function groundSnapGhost(o){
  // Om din motor tillåter: if (game.collideswith(o,"ground","down")) return true;
  const grounds = game.getobjecttype("ground")?.objects || [];
  let bestY = +Infinity;
  for (const g of grounds){
    const overlapX = (o.x+o.dimx > g.x) && (o.x < g.x+g.dimx);
    if (!overlapX) continue;
    bestY = Math.min(bestY, g.y - o.dimy);
  }
  if (bestY < +Infinity && o.y >= bestY){
    o.y = bestY;
    return true;
  }
  return false;
}

function updateLoot(player){
  const sets = [game.getobjecttype("coin"), game.getobjecttype("apple")];
  for (const type of sets){
    const arr = type?.objects || [];
    for (let i=arr.length-1; i>=0; --i){
      const o = arr[i];
      o.t++; if (o.pickDelay>0) o.pickDelay--;
      if (o.despawn-- <= 0){ game.removeobject(type, o); continue; }

      if (o.state === 'air'){
        // enkel “fysik”
        o.vy += (o.ay || 0.6);
        o.x  += (o.vx || 0);
        o.y  += (o.vy || 0);

        // landa på mark (ghost → manuell snap)
        if (groundSnapGhost(o)){
          o.state = 'rest';
          o.vx = 0; o.vy = 0;
          o.baseY = o.y;
        }
      } else { // 'rest' → bob + magnet
        // bob
        o.y = o.baseY + Math.sin(o.t*0.2)*0.6;

        // magnet mot spelaren inom radie
        const px = player.x + player.dimx/2, py = player.y + player.dimy/2;
        const ox = o.x + o.dimx/2,          oy = o.y + o.dimy/2;
        const dx = px-ox, dy = py-oy;
        const d2 = dx*dx + dy*dy;
        const R = 140; // magnetradie px
        if (d2 < R*R){
          const invd = 1/Math.max(1, Math.sqrt(d2));
          const s = 3.0; // sugstyrka
          o.x += dx*invd*s;
          o.y += dy*invd*s;
        }
      }

      // pickup (ghost-kollision)
      if (o.pickDelay<=0){
        if (type === game.getobjecttype("coin") && game.collideswith(o,"swordguy","ghost")){
          game.removeobject(type,o);
          coins++;
          audio2("sounds/coin.mp3");
          continue;
        }
        if (type === game.getobjecttype("apple") && game.collideswith(o,"swordguy","ghost")){
          game.removeobject(type,o);
          player.health = Math.min(player.maxhealth, (player.health)+10);
          audio2("sounds/apple.mp3");
          continue;
        }
      }
    }
  }
}
function updateGoal(player){
    
   if(gameState === 'level_complete'){
    levelCompleteTimer--;
    if (levelCompleteTimer <= 1){
      markCleared(overworldPlayer.node);
      gameState = 'overworld';
      levelCompleteTimer=0;
      //game.currentmap = (game.currentmap+1) % game.maps.length;
      //markStaticsDirty();
    }
  }  
  const p = game.collideswith(player, "portal", "ghost");
  if (gameState !== 'overworld'&&p&&levelCompleteTimer===0){
    // Liten effekt innan bytet
    cameraShake(6, 200);
    //hitStop(5);
    levelCompleteTimer = 240;
    gameState = 'level_complete';
    // Byt till nästa bana
    //game.currentmap = (game.currentmap + 1) % game.maps.length;
    //markStaticsDirty();
  }

  
  
  
}
function gameover(){
    stateTimer--;
    if (wantRestart){
        game.load();
        audio.play();
        coins=0;
        wantRestart=false;
        gameState = 'overworld';
        gemeovercounter=20;
    }
}


function drawOverlays(ctx){
  if (gameState === 'level_complete' || gameState === 'game_over'){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = (gameState==='level_complete') ? "#FFD700" : "#ff4d4d";
    ctx.font = "bold 32px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(gameState==='level_complete' ? "LEVEL COMPLETE!" : "GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "16px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.fillText(gameState==='game_over' ? "Tap/Space för att försöka igen" : "", canvas.width/2, canvas.height/2+28);
    ctx.restore();
  }
  if (gameState === 'game_over'){
        // röd overlay
        const alpha = Math.min(1, (150 - stateTimer)/150);
        ctx.fillStyle = `rgba(255,0,0,${0.4*alpha})`;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        ctx.fillStyle = "#ff4d4d";
        ctx.font = "bold 32px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText("Tap/Space för att försöka igen", canvas.width/2, canvas.height/2+28);
    }
}


// === Update overworld ===





// När du byter nod
function moveToNode(next){
  overworldPlayer.from = overworldPlayer.node;
  overworldPlayer.node = next;
  overworldPlayer.progress = 0; // starta resa
}

// Uppdatering varje frame
function updateOverworld(){
    

    
    
    
  const curIdx  = overworldPlayer.node;
  const fromIdx = overworldPlayer.from;
  const from    = overworldNodes[fromIdx];
  const to      = overworldNodes[curIdx];

  if (overworldPlayer.progress < 1){
    overworldPlayer.progress += overworldPlayer.speed; // 0.02 ≈ 50 frames = ~0.8s
    if (overworldPlayer.progress > 1) overworldPlayer.progress = 1;
  }

  // Lerp mellan from och to
  const t = overworldPlayer.progress;
  overworldPlayer.x = from.x + (to.x - from.x) * t;
  overworldPlayer.y = from.y + (to.y - from.y) * t;

  // Bara acceptera ny input om progress är klar
  if (t >= 1){
    handleOverworldInput();
  }
}

// Input (bara byta nod när man står still)
function handleOverworldInput(){
  if(!keyState.d)dstopper=false;
if(!keyState.a)astopper=false;
if(!keyState.w)wstopper=false;
if(!keyState.s)sstopper=false;


let ix = 0, iy = 0;
if (keyState.d&&dstopper===false) {ix += 1;dstopper=true;}
if (keyState.a&&astopper===false) {ix -= 1;astopper=true;}
if (keyState.s&&sstopper===false) {iy += 1;sstopper=true;}
if (keyState.w&&wstopper===false) {iy -= 1;wstopper=true;}

const next = chooseNeighborByInput(ix,iy);
if (next!=null) moveToNode(next);
gemeovercounter--;
if (gemeovercounter<1&&(keyState.space||(game.getobjecttype("abutton")&&game.getobjecttype("abutton").objects[0].mousepressed==true))){game.load().then(stuff).catch(console.error);  }




}
function stuff(){
    game.currentmap = overworldPlayer.node; markStaticsDirty(); gameState = "play";
    
    
    
}



function drawOverworld(ctx){
  
  ctx.drawImage(overworldimage,0,0,canvas.width,canvas.height);
  
  if(game.getobjecttype("abutton")&&mobileAndTabletCheck())ctx.drawImage(game.getobjecttype("abutton").images[0].getimage(),canvas.width-250,canvas.height-250,150,150);

  



  for (const n of overworldNodes){
    const unlocked = isUnlocked(n);
    ctx.save();
    ctx.globalAlpha = unlocked ? 0.00 : 0.85;
    ctx.fillStyle = unlocked ? "#cfd3d8" : "#9aa0a6"; // platta
    ctx.beginPath(); ctx.arc(n.x, n.y, 40, 0, Math.PI*2); ctx.fill();

    // hänglås på låsta noder
    if (!unlocked){
      ctx.fillStyle = "#333";
      ctx.fillRect(n.x-6, n.y-2, 12, 10);         // kropp
      ctx.beginPath(); ctx.arc(n.x, n.y-6, 6, Math.PI, 0); ctx.lineWidth=2; ctx.strokeStyle="#333"; ctx.stroke();
    }
    ctx.restore();

    // cleared markering (liten stjärna)
    if (n.cleared){
        countercleared++;
        ctx.globalAlpha=0.85;
      if(countercleared<100)  {
        ctx.fillStyle = "green";
        ctx.beginPath();  ctx.ellipse(n.x, n.y, 50, 100, Math.PI / 2, 0, Math.PI*2);ctx.fill();
      }
      if(countercleared>100)  {
        ctx.fillStyle = "lightgreen";
        ctx.beginPath();  ctx.ellipse(n.x, n.y, 50, 100, Math.PI / 2, 0, Math.PI*2);ctx.fill();
      }
      if(countercleared>200)countercleared=0;
    }
  }

  // rita spelarikonen vid overworldPlayer.x/y







  // player
  const p = overworldNodes[overworldPlayer.node];
  
 
  
  if(game.getobjecttype("swordguy"))ctx.drawImage(game.getobjecttype("swordguy").images[0].getimage(),overworldPlayer.x,overworldPlayer.y-80,80,80);


}

function buildAdjList(nodes, edges){
  const adj = Array(nodes.length).fill(0).map(()=>[]);
  for (const [a,b] of edges){ adj[a].push(b); adj[b].push(a); }
  return adj;
}
function isUnlocked(node){
  if (node.id === 0) return true;          // start
  if (!node.prereq || node.prereq.length===0) return true;
  return node.prereq.every(id => overworldNodes[id]?.cleared);
}
function markCleared(id){
  const n = overworldNodes.find(n=>n.id===id);
  if (n) n.cleared = true;
}
function chooseNeighborByInput(ix, iy){
  const cur = overworldNodes[overworldPlayer.node];
  let best=null, bestDot=0;

  for (const ni of OW.adj[overworldPlayer.node]){
    const n = overworldNodes[ni];
    if (!isUnlocked(n)) continue;                 // <<< låsta noder ignoreras
    const vx=n.x-cur.x, vy=n.y-cur.y;
    const len=Math.hypot(vx,vy)||1, dx=vx/len, dy=vy/len;
    const dot = dx*ix + dy*iy;
    if (dot>bestDot){ bestDot=dot; best=ni; }
  }
  return (bestDot>0.5)? best : null;
}
const ARCHER_AI = {
  SIGHT_X: 480,
  ATTACK_RANGE: 420,
  MIN_DISTANCE: 120,
  WINDUP_FR: 80,
  COOLDOWN_FR: 80,
  SPEED: 2.2,
  
  
};

function initArcher(r){
  if (r.ai) return;
  r.ai = { state:"patrol", dir:(r.fliped?-1:1), timer:0, target:null ,losCD: 0,
    canSee: false,
    lastSeenX:r.x,
    lastSeenY:r.y,
    huntT: 0,
    tturn:false,
    hurt: r.health,
    turnCD:0,       // <— NYTT
    alertT:0,};
}

function updateArchers(){
  const archers = game.getobjecttype("archer")?.objects || [];
  const players = game.getobjecttype("swordguy")?.objects || [];
  if (!players.length) return;

  for (const r of archers){
    initArcher(r);
    if(!r.isonscreen)continue;  
    // === fysik ===
    updatePhysics(r);
    r.y += 11;   // ditt “dual/grav hack”
    r.dual = 10;

    const p = players[0];
    const dx = p.x - r.x, dy = p.y - r.y;
    const dist = Math.hypot(dx,dy);
   // const dir = dx<0 ? -1 : 1;
    r.fliped = r.ai.dir<0;// r.direction = (dir<0)?"left":"right";

    if (r.ai.timer>0) r.ai.timer--;
    if (r.ai.turnCD > 0){ r.ai.turnCD--;}
    if (r.alertT > 0) r.alertT--;
    const desiredDir = (dx < 0 ? -1 : 1);
    
    if(r.ai.hurt!==r.health){r.ai.dir=desiredDir;r.ai.hurt=r.health;}
    
    // ——— LOS (uppdateras inte varje frame)
    if (r.ai.losCD > 0) r.ai.losCD--;
    if (r.ai.losCD === 0 && p && r.isonscreen ){
      r.ai.losCD = 6; // testa 4..10 (lägre = snabbare reaktion, mer CPU)
      const gridStat = window.G5?.gridStat;

      const eyeX = r.x + r.dimx*0.5;
      const eyeY = r.y + r.dimy*0.35;
      const px   = p.x + p.dimx*0.5;
      const py   = p.y + p.dimy*0.35;

      r.ai.canSee = window.G5?.hasLineOfSight?.(gridStat, eyeX, eyeY, px, py, {
        pad: 2,
        filter: (S) => true // här kan du senare ignorera "see-through" walls
      }) ?? true;
    }
    if(!r.ai.canSee)r.isvisable=false;
    else r.isvisable=true;
    
    
    
     if (desiredDir !== r.ai.dir&&(r.ai.tturn)){
          
          if(r.ai.turnCD==0)r.ai.turnCD = 102;
          if(r.ai.turnCD==1){r.ai.dir   = desiredDir;r.ai.tturn=false;r.ai.state = 'patrol';}

      }
    
    
    
    
    
    
    
    
    
    switch(r.ai.state){
      case "patrol": {
        // enkel patrull → gå i riktning
        
        r.x += r.ai.dir * ARCHER_AI.SPEED;
        if (game.collideswith(r,"any","left"))  r.ai.dir = +1;
        if (game.collideswith(r,"any","right")) r.ai.dir = -1;

        if (dist < ARCHER_AI.SIGHT_X&&desiredDir===r.ai.dir&&r.ai.canSee){
          r.ai.state = "aim";
          r.ai.tturn=true;
          r.alertT = RAT_AI.ALERT_T_FR;
        }
        break;
      }

      case "aim": {
     
         if (dist < ARCHER_AI.ATTACK_RANGE && r.ai.timer===0&&desiredDir===r.ai.dir&&r.ai.canSee){
          r.ai.state = "windup";
          r.ai.timer = ARCHER_AI.WINDUP_FR;
          r.animation = 1; // sikta
        }
        else r.ai.state="patrol";
        break;
      }

      case "windup": {
        r.ai.timer--;
        r.animation = 1; // “dra strängen”
        if (r.ai.timer<=0){
          shootArrow(r.x, r.y, r.ai.dir);
          r.ai.state="cooldown";
          r.ai.timer=ARCHER_AI.COOLDOWN_FR;
        }
        break;
      }

      case "cooldown": {
        r.ai.timer--;
        r.animation = 0; // idle
        if (r.ai.timer<=0) r.ai.state="aim";
        break;
      }
    }
  }
}

function shootArrow(x,y,dir){
  const arrow = game.addobject(game.getobjecttype("arrow"), x, y, game.getobjecttype("arrow").standarddimx, game.getobjecttype("arrow").standarddimy, 0, dir<0);

  
    // fysik-komponent
  arrow.vx = dir * 18.5;   // horisontell fart
  arrow.vy = -1.0;        // liten båge uppåt
  arrow.ay = 0.1;        // gravitation
  arrow.life = 60*3;      // 3s livstid
  arrow.damage = 8;       // skada på spelaren
  arrow.stuck = false;    // när den fastnar i mark/vägg
  
  
}
function updateArrows(){
  const A = game.getobjecttype("arrow");
  const P = game.getobjecttype("swordguy")?.objects?.[0];
  if (!A) return;

  for (let i = A.objects.length - 1; i >= 0; --i){
    const a = A.objects[i];

    // döda gamla pilar
    if (--a.life <= 0){ game.removeobject(A, a); continue; }

    if (!a.stuck){
      // fysik
      a.vy += (a.ay || 0);
      if (a.vy > 14) a.vy = 14;

      a.x += (a.vx || 0);
      a.y += (a.vy || 0);

      // kollision med världen (vänster/höger/mark)
      if (!game.collideswith(a, "archer", "ghost")&&!game.collideswith(a, "rat", "ghost")&&!game.collideswith(a, "tank", "ghost")&&game.collideswith(a, "any", "ghost")) {
       
        // fastna i ytan: nolla hastigheten, kortare liv
        a.vx = 0; a.vy = 0; a.ay = 0; a.stuck = true;
        a.life = Math.min(a.life, 45);
        // valfritt: gnist-partiklar här
      }


    }


  }
}

const SHIELD_AI = {
  SPEED: 1.4,
  CHASE_SPEED: 2.4,
  TURN_CD_FR: 80,     // långsam vändning
  BLOCK_FR: 9999,     // default: block aktivt
  BASH_RANGE: 50,     // om spelaren är nära → bash
  BASH_FR: 24,
  COOLDOWN_FR: 40,
};

function initShield(r){
  if (r.ai) return;
  r.ai = {
    state:'patrol',
    dir: (r.fliped ? -1 : 1),
    vx:0, timer:0,
    target:null,
    turnCD:0,       // <— NYTT
    alertT:0,        // <— NYTT (för “!” och ev. ‘alert’-animation)
    vy:0,
    
    losCD: 0,
    canSee: false,
    lastSeenX:r.x,
    lastSeenY:r.y,
    huntT: 0,
    tturn:false,
    hurt: r.health
  };
}

function updateShields(){
  const shields = game.getobjecttype("tank")?.objects || [];
  const players = game.getobjecttype("swordguy")?.objects || [];
  if (!players.length) return;

  for (const r of shields){
    initShield(r);
    updatePhysics(r);
    if(!r.isonscreen)continue;  
    r.animation = 0;
    // din grav / dual hack
    r.y += 11; 
    r.dual = 35;


    // target + avstånd
    if (!r.ai.target) r.ai.target = nearestPlayer(r);
    const P = r.ai.target;
    let dx=0, dy=0, distX=1e9;
    if (P){ dx=P.x-r.x; dy=P.y-r.y; distX=Math.abs(dx); }

    // tick timers
    if (r.ai.turnCD > 0){ r.ai.turnCD--;}
    if (r.alertT > 0) r.alertT--;

    // ——— LOS (uppdateras inte varje frame)
    if (r.ai.losCD > 0) r.ai.losCD--;
    if (r.ai.losCD === 0 && P && r.isonscreen){
      r.ai.losCD = 6; // testa 4..10 (lägre = snabbare reaktion, mer CPU)
      const gridStat = window.G5?.gridStat;

      const eyeX = r.x + r.dimx*0.5;
      const eyeY = r.y + r.dimy*0.35;
      const px   = P.x + P.dimx*0.5;
      const py   = P.y + P.dimy*0.35;

      r.ai.canSee = window.G5?.hasLineOfSight?.(gridStat, eyeX, eyeY, px, py, {
        pad: 2,
        filter: (S) => true // här kan du senare ignorera "see-through" walls
      }) ?? true;
    }
    if(!r.ai.canSee)r.isvisable=false;
    else r.isvisable=true;
    
    const desiredDir = (dx < 0 ? -1 : 1);
    const seesPlayer = (P && distX < RAT_AI.SIGHT_X && Math.abs(dy) < RAT_AI.SIGHT_Y && r.ai.canSee&&r.ai.dir=== desiredDir);
    if (r.ai.state==='patrol' && seesPlayer){ 
      r.ai.state = 'chase'; 
      r.alertT = RAT_AI.ALERT_T_FR;          // <— visa “!”
     r.ai.tturn=true;
      // valfritt: setta animation “alert”
    }
    if (r.ai.state!=='patrol' && (!P || (distX>RAT_AI.FORGET_X && r.ai.tturn===false))){
      r.ai.state = 'patrol'; r.ai.target=null;
    }

    // ——— Vändhantering: om spelaren är på andra sidan → vänd + turn cooldown
    // Ger ett “backstab-fönster”: under turnCD kan råttan inte starta attack.
    
    if (P){
      
      if (desiredDir !== r.ai.dir&&(r.ai.tturn||r.ai.hurt!==r.health)){
          
          if(r.ai.turnCD==0)r.ai.turnCD = RAT_AI.TURN_CD_FR
          if(r.ai.turnCD==1){r.ai.dir   = desiredDir;r.ai.tturn=false;r.ai.state = 'patrol';r.ai.hurt=r.health;}

      }
    }

    // ——— State machine
    switch (r.ai.state){
      case 'patrol': {
        r.ai.vx = RAT_AI.SPEED * r.ai.dir;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }
        break;
      }

      case 'chase': {
        r.ai.vx = RAT_AI.CHASE_SPEED * r.ai.dir;
        r.ai.tturn=true;
        if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.ai.dir = +1;
          if (game.collideswith(r,'any','right')) r.ai.dir = -1;
        }

        // Attack bara när:
        // - vi är inom range
        // - vi FAKTISKT FÖR rätten (dx*dir > 0)
        // - och vi är inte i vänd-cooldown
        if (P && game.collideswith(r, "swordguy", "ghost") && (dx * r.ai.dir) > 0 && r.ai.turnCD === 0){
          r.ai.state = 'windup';
          r.ai.timer = RAT_AI.WINDUP_FR;
          r.ai.vx = 0;
           r.animation = 1;
        }
        break;
      }

      case 'windup': {
        r.ai.vx = 0;
        r.animation = 1; // attack animation

        r.ai.timer--;

        // När halva windupen passerat → träffen går igenom
        if (r.ai.timer === Math.floor(RAT_AI.WINDUP_FR/2)) {
          handleCombat("tank", ["swordguy"], 10);
        }

        if (r.ai.timer <= 0) {
          r.ai.state = 'cooldown';
          r.ai.timer = RAT_AI.ATTACK_CD_FR;
        }
        break;
      }

      case 'cooldown': {
        r.ai.vx = -0.6 * r.ai.dir; // backa liten bit
        r.ai.timer--;
        if (r.ai.timer <= 0) r.ai.state = 'chase';
        break;
      }
    }

    // Rörelse + facing
    if(desiredDir === r.ai.dir|| (r.ai.state=='patrol'&&r.ai.tturn==false))r.x += r.ai.vx;

    r.fliped = (r.ai.dir < 0);
    r.direction = r.fliped ? 'left' : 'right';
  }
}
function attackFromFront(attacker, defender){
  // Riktningen defendern tittar åt
  const ddir = defender.fliped ? -1 : 1;

  // Delta mellan attacker och defender
  const dx = (attacker.x + attacker.dimx/2) - (defender.x + defender.dimx/2);

  // Om attacker är framför shielden (i samma riktning som defender tittar)
  return (dx * ddir > 0);
}
// ===== Tunables =====
const BAT_AI = {
  SIGHT_X:        460,  // ser spelaren
  SIGHT_Y:        840,
  HOVER_SPEED:    1.6,
  SWOOP_SPEED:    6.6,
  RETREAT_SPEED:  3.4,
  HOVER_AMPL:     10,   // sinus-amplitud
  HOVER_FREQ:     0.12, // sinus-hastighet
  SWOOP_COOLDOWN: 40,   // frames mellan dyk
  CONTACT_DMG:    8,
};

function initBat(b){
  if (b.ai) return;
  b.dual=5;
  b.ai = {
    state: 'perch', // 'perch' | 'hover' | 'swoop' | 'retreat' | 'cooldown'
    dir: (b.fliped ? -1 : 1),
    t: 0,
    cd: 0,
    homeY: b.y,          // baseline för hover/retreat
  };
  b.vx = 0; b.vy = 0;    // flygare – ingen grav
}

function updateBats(){
  const bats = game.getobjecttype("bat")?.objects || [];
  const player = game.getobjecttype("swordguy")?.objects?.[0];
  if (!player) return;

  for (const b of bats){
    initBat(b);
    if(!b.isonscreen)continue;  
    const dx = player.x - b.x;
    const dy = player.y - b.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sgn = dx < 0 ? -1 : 1;
    b.fliped = (sgn < 0);
    b.direction = b.fliped ? "left":"right";

    if (b.ai.cd > 0) b.ai.cd--;
    b.ai.t++;

    const sees = (adx < BAT_AI.SIGHT_X && ady < BAT_AI.SIGHT_Y);
        
        
    switch (b.ai.state){

      case 'perch': { // hänger “sovande”
        b.fliped = (sgn > 0);
        b.direction = b.fliped ? "left":"right";      
        b.animation=0;
        b.rot=180;
        b.vx = b.vy = 0;
        if (sees) {
          b.ai.state = 'hover';
          b.ai.homeY = b.y - 24; // dra upp lite innan hover
        }
        break;
      }

      case 'hover': { // sväva i sinus, håll avstånd horisontellt
        b.animation=1;  
        b.rot=0;
        b.vx = sgn * BAT_AI.HOVER_SPEED * 0.6;
        b.vy = Math.sin(b.ai.t * BAT_AI.HOVER_FREQ) * 0.6;

        // undvik väggar lätt
        if (game.collideswith(b,"any","left"))  b.vx = Math.abs(b.vx);
        if (game.collideswith(b,"any","right")) b.vx = -Math.abs(b.vx);

        // starta swoop när rätt avstånd
        if (sees && b.ai.cd === 0 && adx < 180){
          b.ai.state = 'swoop';
        } else if (!sees){
          // tappa target → glid tillbaka mot homeY
          b.vy += (b.ai.homeY - b.y) * 0.02;
        }
        break;
      }

      case 'swoop': { // dyk mot spelarens position
        b.animation=0;  
        b.rot=0;
        const len = Math.max(1, Math.hypot(dx, dy));
        b.vx = (dx/len) * BAT_AI.SWOOP_SPEED;
        b.vy = (dy/len) * BAT_AI.SWOOP_SPEED;

        // Om vi passerat under spelaren eller nära → gå till retreat
        if (b.y > player.y + 10 || len < 24){
          b.ai.state = 'retreat';
          b.ai.cd = BAT_AI.SWOOP_COOLDOWN;
        }
        break;
      }

      case 'retreat': { // dra uppåt till baseline
        b.animation=1;
        b.rot=0;
        // uppåt + bort lite
        b.vx = -sgn * BAT_AI.RETREAT_SPEED * 0.6;
        b.vy = -BAT_AI.RETREAT_SPEED;

        // när vi är tillbaka nära homeY → hover
        if (b.y <= b.ai.homeY){
          b.y = b.ai.homeY;
          b.ai.state = 'hover';
        }
        break;
      }
    }

    // position uppdateras
    b.x += b.vx;
    b.y += b.vy;

    
    
      if (!b.hitCD || b.hitCD <= 0){
        handleCombat("bat", ["swordguy"], 2.5);   // din funktion


        b.hitCD = 30;
      }
      if (b.hitCD && b.hitCD > 0) b.hitCD--;
    }
    
}
const MAGE_AI = {
  SIGHT_X:       600,
  ATTACK_RANGE:  260,
  MIN_DISTANCE:  120,
  WINDUP_FR:      60,   // längre än archer
  COOLDOWN_FR:    60,
  SPEED:         1.6,
};

function initMage(r){
  if (r.ai) return;
  r.ai = { state:"idle", dir:(r.fliped?-1:1), timer:0, target:null,canSee:false,losCD:0 };
}

function updateMages(){
  const mages = game.getobjecttype("mage")?.objects || [];
  const players = game.getobjecttype("swordguy")?.objects || [];
  if (!players.length) return;

  for (const r of mages){
    initMage(r);
    updatePhysics(r);
    r.y+=11;
    if(!r.isonscreen)continue;  
    const p = players[0];
    const dx = p.x - r.x;
    const dy = p.y - r.y;
    const dist = Math.hypot(dx,dy);
    let dir = r.fliped ? -1 : 1;
    
    if(Math.abs(dx)>10)r.fliped = dir<0;
    r.direction = r.fliped ? "left":"right";

    if (r.ai.timer>0) r.ai.timer--;
    
    // ——— LOS (uppdateras inte varje frame)
    if (r.ai.losCD > 0) r.ai.losCD--;
    if (r.ai.losCD === 0 && p && dist < MAGE_AI.SIGHT_X ){
      r.ai.losCD = 6; // testa 4..10 (lägre = snabbare reaktion, mer CPU)
      const gridStat = window.G5?.gridStat;

      const eyeX = r.x + r.dimx*0.5;
      const eyeY = r.y + r.dimy*0.35;
      const px   = p.x + p.dimx*0.5;
      const py   = p.y + p.dimy*0.35;

      r.ai.canSee = window.G5?.hasLineOfSight?.(gridStat, eyeX, eyeY, px, py, {
        pad: 2,
        filter: (S) => true // här kan du senare ignorera "see-through" walls
      }) ?? true;
    }
    if(!r.ai.canSee)r.ai.state="idle";
    
    switch(r.ai.state){
      case "idle": {
              
              if (!game.collideswiths(r,'swordguy')){
          if (game.collideswith(r,'any','left'))  r.fliped=false;
          if (game.collideswith(r,'any','right')) r.fliped=true;
        }
              
              dir = r.fliped ? -1 : 1;
              r.x += dir * MAGE_AI.SPEED*0.6;
        // börja jaga om spelaren nära nog
        if (dist < MAGE_AI.SIGHT_X&&r.ai.canSee){
          r.ai.state = "chase";
        }
        break;
      }

      case "chase": {
         dir = dx<0 ? -1 : 1; 
         r.fliped = dir<0;
        // håll avstånd
        if(dist<10){}
        else if (dist < MAGE_AI.MIN_DISTANCE){
          r.x -= dir * MAGE_AI.SPEED;
        } else if (dist > MAGE_AI.ATTACK_RANGE){
          r.x += dir * MAGE_AI.SPEED * 0.6;
        }

        // attack
        if (dist < MAGE_AI.ATTACK_RANGE && r.ai.timer===0){
          r.ai.state="windup";
          r.ai.timer=MAGE_AI.WINDUP_FR;
          r.animation=1; // “cast”-pose
        }
        break;
      }

      case "windup": {
        r.ai.timer--;
        r.animation=1; // glow
        if (r.ai.timer<=0){
          shootFireball(r,dir);
          r.ai.state="cooldown";
          r.ai.timer=MAGE_AI.COOLDOWN_FR;
        }
        break;
      }

      case "cooldown": {
        r.ai.timer--;
        r.animation=0;
        if (r.ai.timer<=0) r.ai.state="chase";
        break;
      }
    }
  }
}
function shootFireball(r,dir){
  const F = game.getobjecttype("fire");
  const f = game.addobject(F, r.x+(dir*20), r.y+10, 36, 36, 0, (dir<0));

  f.vx = dir*4.0;
  f.vy = -0.5;   // liten båge
  f.ay = 0.1;    // lätt grav
  f.life = 120;  // 2 sek
  f.damage = 12;
}
function updateFireballs(){
  const F = game.getobjecttype("fire");
  const P = game.getobjecttype("swordguy")?.objects?.[0];
  if (!F) return;

  for (let i=F.objects.length-1;i>=0;--i){
    const f = F.objects[i];
    if (--f.life<=0){ game.removeobject(F,f); continue; }

    f.vy += (f.ay||0);
    f.x += f.vx;
    f.y += f.vy;

    // träffar spelaren?
    if (P && game.collideswith(f,"swordguy","ghost")){
      handleCombat("fire", ["swordguy"], 10);
      spawnHitParticles(P.x+P.dimx/2,P.y,10,"#ff9933");
      cameraShake(4,120);
      hitStop(3);
      game.removeobject(F,f);
      continue;
    }

    // krockar med vägg
    if (game.collideswith(f,"any","down") || game.collideswith(f,"any","left") || game.collideswith(f,"any","right")){
      spawnHitParticles(f.x+f.dimx/2,f.y+f.dimy/2,12,"#ff6600");
      game.removeobject(F,f);
    }
  }
}

// ================== Tunables ==================
const WARLOCK_AI = {
  HP: 400,

  SPEED: 1.2,
  SIGHT_X: 9999,

  WINDUP_FR: 26,
  COOLDOWN_FR: 40,

  FIREBALL_DMG: 14,
  FIREBALL_VX: 4.2,

  PILLAR_COUNT: 3,
  PILLAR_SPACING: 40,
  PILLAR_DELAY_FR: 12,

  SUMMON_COUNT: 2,
  SUMMON_CD_FR: 900,

  DASH_SPEED: 5.2,
  DASH_FR: 24,
  DASH_DMG: 12,

  SHIELD_T_FR: 10,       // hur länge skölden ligger uppe i fas 3
  TELEPORT_CD_FR: 180,

  HURT_KNOCK: 4
};
const WARLOCK_SHIELD = {
  ON_FR:   50,  // block
  WARN_FR: 14,  // blink
  OFF_FR:  18   // öppet
};

function updateShieldCycle(b){
  const C = WARLOCK_SHIELD;
  const CYC = C.ON_FR + C.WARN_FR + C.OFF_FR;
  b.ai.shieldTick = (b.ai.shieldTick+1) % CYC;

  if (b.ai.shieldTick < C.ON_FR){
    b.ai.shieldState = 'on';
    b.flashTimer = 0; // ingen blink
  } else if (b.ai.shieldTick < C.ON_FR+C.WARN_FR){
    b.ai.shieldState = 'warn';
    b.flashTimer = 4;               // blinka några frames
    b.flashTimercolor = "rgba(168, 199, 255, 0.6)";  // blå glöd
  } else {
    b.ai.shieldState = 'off';
    b.flashTimer = 0;
  }
}


// =============== Init boss ====================
function initWarlock(b){
  if (b.ai) return;
  b.maxHealth = WARLOCK_AI.HP;
  b.health = b.maxHealth;
  b.ai = {
    state: 'idle', dir: (b.fliped?-1:1),
    timer: 0, cd: 0, phase: 1,
    shieldUp: false, tpCD: 0, summonCD: 60,shieldState:'off',shieldTick:0
  };
  b.vx = 0; b.vy = 0;
}

// =============== Main update ==================
function updateWarlocks(){
  const W = game.getobjecttype('warlock')?.objects || [];
  const P = game.getobjecttype('swordguy')?.objects?.[0];
  if (!P) return;

  for (const b of W){
    initWarlock(b);
    // fas efter HP
    if(b.isonscreen&&!audio.src.endsWith("drak.mp3")){audio.src = "sounds/drak.mp3";audio.play();}
    
    const hpPct = b.health / b.maxHealth;
    b.ai.phase = (hpPct > 0.70) ? 1 : (hpPct > 0.35 ? 2 : 3);

    // grundriktning mot spelaren
    const dx = P.x - b.x-b.dimx/3, dy = P.y - b.y;
    const dir = dx < 0 ? -1 : 1;
    b.fliped = (dir<0);
    b.direction = b.fliped ? 'left':'right';

    // timers
    if (b.ai.timer>0) b.ai.timer--;
    if (b.ai.cd>0) b.ai.cd--;
    if (b.ai.tpCD>0) b.ai.tpCD--;
    if (b.ai.summonCD>0) b.ai.summonCD--;

    // enkel “grav” så han står på mark
    b.y += 11; b.dual = 50;

    switch(b.ai.state){

      case 'idle': {
        // glid långsamt i sidled för att hålla liv i fighten
        b.x += dir * WARLOCK_AI.SPEED * 0.5;

        // fasbeteende
        if (b.ai.phase===1){
          if (b.ai.cd===0){ startCast(b, 'fireball'); }
        } else if (b.ai.phase===2){
          // teleporta ibland + fireball / pillar
          if (b.ai.tpCD===0 && Math.random()<0.02){
            doTeleport(b, P);
            b.ai.tpCD = WARLOCK_AI.TELEPORT_CD_FR;
          } else if (b.ai.summonCD===0){
            startCast(b, 'summon');
            b.ai.summonCD = WARLOCK_AI.SUMMON_CD_FR;
          } else if (b.ai.cd===0){
            if (Math.random()<0.5) startCast(b, 'fireball');
            else startCast(b, 'pillar');
          }
        } else { // phase 3
            updateShieldCycle(b); // sköter flash+state

            if (b.ai.cd===0){
              if (Math.random()<0.45) startCast(b, "tri_fire");
              else startCast(b, "dash");
            }
        }
        break;
      }

      case 'windup': {
        if (b.ai.timer <= 0){
          const handled = resolveCast(b, P, dir); // boolean
          if (!handled){                          // endast enkla casts
            b.ai.state = 'cooldown';
            b.ai.timer = WARLOCK_AI.COOLDOWN_FR;
          }
        }
        break;
      }

      case 'cooldown': {
        if (b.ai.timer<=0){
          b.ai.state='idle';
          b.ai.cd = 140; // liten allmän CD
        }
        break;
      }

      case 'dash': {
        b.x += b.ai.dashDir * WARLOCK_AI.DASH_SPEED;
        b.ai.timer--;
        // skada spelaren vid kontakt
        if (game.collideswith(b, 'swordguy','ghost')){
          handleCombat("warlock", ["swordguy"], 10);
          const k = (b.x<P.x)?+1:-1;
          P.vx = (P.vx||0) + k*5; P.vy = -6;
        }
        if (b.ai.timer<=0){ b.ai.state='cooldown'; b.ai.timer=WARLOCK_AI.COOLDOWN_FR; }
        break;
      }
    }

    // slå av sköld om tiden ute i fas 3
    if (b.ai.phase===3 && b.ai.shieldUp && b.ai.shieldT<=0) b.ai.shieldUp=false;
  }
}

// =============== Casting helpers ==============
function startCast(b, type){
  b.ai.state = 'windup';
  b.ai.timer = WARLOCK_AI.WINDUP_FR;
  b.ai.castType = type;
  b.animation = 1; // “casting”-pose i dina sprites
}



// =============== Attacks ======================
function shootFireballFrom(b, dir, angle){
  const F = game.getobjecttype('fire');
  const f = game.addobject(F, b.x+b.dimx/2 + dir*22, b.y + 6, 36, 36, 0, (dir<0));
  const base = WARLOCK_AI.FIREBALL_VX;
  const vx = dir * base * Math.cos(angle);
  const vy = base * Math.sin(angle) * -1; // lätt uppåt
  f.vx = vx; f.vy = vy; f.ay = 0.12; f.life = 120; f.damage = WARLOCK_AI.FIREBALL_DMG;
}



// enkel scheduler (ramräknare). Kör i din mainloop: runScheduled()
let _sched = [];
function schedule(fn, delay){ _sched.push({fn, t:delay}); }
function runScheduled(){
  for (let i=_sched.length-1;i>=0;--i){
    const s=_sched[i]; s.t--;
    if (s.t<=0){ try{s.fn();}finally{_sched.splice(i,1);} }
  }
}
// kalla runScheduled() varje frame i din loop.



// Minions (t.ex. bat/archer)
function summonMinionsNear(b){
  const types = ['bat','archer'];
  for (let i=0;i<WARLOCK_AI.SUMMON_COUNT;i++){
    const t = game.getobjecttype(types[i%types.length]);
    const x = b.x + (Math.random()<0.5?-1:1)*(60 + Math.random()*40);
    const y = b.y - 10;
    game.addobject(t, x, y, t.standarddimx||32, t.standarddimy||32, 0, (x<b.x));
  }
}

// teleport – kort blink till en plats 140px åt valfri sida med fri mark
function doTeleport(b, P){
  const dir = (Math.random()<0.5)? -1 : 1;
  const nx = b.x + dir*640;
  b.x = nx; // kan göras mjukare med effekter
  cameraShake(3,120);
}



//=== resolveCast: ersätt bara 'pillar'-fallet ===
function resolveCast(b, P, dir){
  const type = b.ai.castType; 
  b.animation = 2;

  if (type==='fireball'){
    shootFireballFrom(b, dir, 0);
    return false;
  }
  if (type==='tri_fire'){
    shootFireballFrom(b, dir, -0.18);
    shootFireballFrom(b, dir,  0);
    shootFireballFrom(b, dir, +0.18);
    return false;
  }
  if (type==='pillar'){
    castFirePillarsAtTarget(P);   // <— NY
    return false;
  }
  if (type==='summon'){
    summonMinionsNear(b);
    return false;
  }
  if (type==='dash'){
    b.ai.state  = 'dash';
    b.ai.dashDir = dir;
    b.ai.timer  = WARLOCK_AI.DASH_FR;
    return true;
  }
}

// === Nya/justerade tunables ===
Object.assign(WARLOCK_AI, {
  PILLAR_TELEGRAPH_FR: 12,   // markvarningstid
  PILLAR_DESCENT_FR:   26,   // större = långsammare
  PILLAR_LINGER_FR:    16,   // efterbränna
  PILLAR_WIDTH:        20,   // smal blixt
  PILLAR_TIP_H:        18,   // skadande spets
  PILLAR_TIP_DMG:      14,
  PILLAR_LINGER_DMG:    6,
  // start-höjd ovanför fötter (random inom intervallet)
  PILLAR_START_MIN:   600,
  PILLAR_START_MAX:   800
});

// === Kalla denna vid cast (behåll gärna din tri_fire etc) ===
function castFirePillarsAtTarget(target){
  const w = (target?.dimx || 32);
  const h = (target?.dimy || 32);
  const centerX = (target?.x || 0) + w/2;
  const groundY = (target?.y || 0) + h; // fötter vid cast-ögonblicket

  for (let i=0; i<WARLOCK_AI.PILLAR_COUNT; i++){
    const x = centerX + (i-1)*WARLOCK_AI.PILLAR_SPACING;
    schedule(() => spawnFirePillar(x, groundY), i*WARLOCK_AI.PILLAR_DELAY_FR);
  }
}

// === Spawner: lås X; starta högt upp, väx nedåt ===
function spawnFirePillar(xCenter, groundY){
  const PILL = game.getobjecttype('firepillar');
  if (!PILL) return;

  const w = WARLOCK_AI.PILLAR_WIDTH;
  const startH = WARLOCK_AI.PILLAR_START_MIN +
                 Math.random()*(WARLOCK_AI.PILLAR_START_MAX - WARLOCK_AI.PILLAR_START_MIN);
  const startY = groundY - startH;           // 600–800 px ovanför fötter

  // Vi börjar med en mark-telegraph (tunn linje på marken)
  const p = game.addobject(PILL, xCenter - w/2, groundY - 4, w, 4, 0, false);

  // Lås X och stäng av fysik så den aldrig glider
  p.lockX = xCenter - w/2;
  p.vx = p.vy = p.ax = p.ay = 0;
  p.ghost = true;
  p.rot = 0; p.fliped = false;

  // interna fält
  p.mode       = 'telegraph';
  p.t          = WARLOCK_AI.PILLAR_TELEGRAPH_FR;
  p.animation  = 0;

  // fall/kolonn-data
  p.startY     = startY;          // översta Y (fix)
  p.groundY    = groundY;         // dit vi växer
  p.fullH      = groundY - startY; // totala höjden när klar
  p.tipH       = WARLOCK_AI.PILLAR_TIP_H;
  p.curH       = 0;               // nuvarande höjd (växer från 0 → fullH)
  p.growPerFr  = (groundY - startY) / WARLOCK_AI.PILLAR_DESCENT_FR;
  p.lingerT    = WARLOCK_AI.PILLAR_LINGER_FR;
  p.hitCD=0;
}

// === Uppdatering: väx nedåt, skada bara i spetsen, lås X varje frame ===
function updateFirePillars(){
  const PILL = game.getobjecttype('firepillar');
  const P    = game.getobjecttype('swordguy')?.objects?.[0];
  if (!PILL) return;

  const Pw = (P?.dimx || 32), Ph = (P?.dimy || 32);
  const overlap = (ax,ay,aw,ah,bx,by,bw,bh) =>
    (ax < bx + bw) && (ax + aw > bx) && (ay < by + bh) && (ay + ah > by);

  for (let i=PILL.objects.length-1; i>=0; --i){
    const p = PILL.objects[i];

    // Lås X + nolla fysik
    p.x = p.lockX;
    p.vx = p.vy = p.ax = p.ay = 0;

    if (p.mode === 'telegraph'){
      p.animation = 0;
      p.t--;
      // (valfritt: blinka bredd/alpha här)
      if (p.t <= 0){
        // Växande kolonn: placera överst och börja med 0 höjd
        p.mode = 'fall';
        p.animation = 0;
        p.curH = 0;
        p.dimx = WARLOCK_AI.PILLAR_WIDTH;
        p.dimy = 0;                // börjar osynlig
        p.y    = p.startY;         // takposition (fix)
      }
      continue;
    }

    if (p.mode === 'fall'){
      // Väx nedåt genom att öka höjden
      p.curH += p.growPerFr;
      if (p.curH > p.fullH) p.curH = p.fullH;

      // Kolonnens hitbox = hela det som syns
      p.dimx = WARLOCK_AI.PILLAR_WIDTH;
      p.dimy = p.curH;
      p.y    = p.startY; // toppläget är konstant, vi växer nedåt

      // Spetsens hitbox: nedersta tipH
      if (p.curH >= p.tipH){
        const tipY = p.startY + p.curH - p.tipH;
        if (P && overlap(p.x, tipY, p.dimx, p.tipH, P.x, P.y, Pw, Ph)){
            
            
           if (!p.hitCD || p.hitCD <= 0){
            handleCombat("firepillar", ["swordguy"], 10); // din funktion


             p.hitCD = 30;
           }
           if (p.hitCD && p.hitCD > 0) p.hitCD--;  
            
            
          
          P.vy = -3; P.vx = (P.x < (p.x + p.dimx/2) ? -2 : 2);
        }
      }

      // Träffat mark/fötter → linger
      if (p.curH >= p.fullH){
        p.mode = 'linger';
        p.animation = 0;
        // låt dimy vara hela kolonnens höjd; y förblir startY
      }
      continue;
    }

    if (p.mode === 'linger'){
      p.lingerT--;
      if (P && game.collideswith(p, 'swordguy', 'ghost')){
        if (!p.hitCD || p.hitCD <= 0){  
            handleCombat("firepillar", ["swordguy"], 10);
            p.hitCD = 30;
        }
        if (p.hitCD && p.hitCD > 0) p.hitCD--;  
      }
      if (p.lingerT <= 0){
        game.removeobject(PILL, p);
      }
    }
  }
}







        </script>
        
        
        
        
        
        
        
        
        
    </body>
</html>
