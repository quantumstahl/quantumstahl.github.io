<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>MaxAnimate ‚Äì v0 prototype</title>
  <style>
    :root{
      --bg:#0f0f10; --panel:#1b1c1f; --ink:#fff; --muted:#9aa1aa; --accent:#39d353;
      --pad:12px; --r:14px; --shadow:0 14px 28px rgba(0,0,0,.35);
      --ui-scale:clamp(.9, min(100vw,100vh)/1100, 1.1);
      font-size:calc(16px*var(--ui-scale));
    }
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.3 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    button{cursor:pointer}

    /* === Top frame strip === */
    #topBar{position:fixed;left:12px;right:12px;top:12px;display:flex;gap:10px;align-items:center;z-index:50}
    #frames{display:flex;gap:10px;overflow:auto;padding:10px;background:var(--panel);border-radius:var(--r);box-shadow:var(--shadow)}
    #frames::-webkit-scrollbar{height:10px}
    .frame{min-width:84px;max-width:84px;display:grid;gap:6px;place-items:center;padding:8px;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:#232428;position:relative}
    .frame canvas{width:64px;height:64px;image-rendering:pixelated;background:#4d4d4d;border-radius:6px;border:1px solid rgba(255,255,255,.06)}
    .frame .idx{position:absolute;top:6px;left:6px;font-size:.75rem;color:#c7cbd1;background:rgba(0,0,0,.35);padding:.1rem .35rem;border-radius:999px}
    .frame.active{outline:2px solid var(--accent)}

    .fbtns{display:flex;gap:8px}
    .fbtns button{background:#2b2d33;color:#fff;border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:.45rem .7rem}

    /* === Left tools === */
    #tools{position:fixed;left:12px;top:92px;bottom:84px;width:56px;display:grid;align-content:start;gap:10px;padding:10px;background:var(--panel);border-radius:var(--r);box-shadow:var(--shadow)}
    #tools button{height:44px;border-radius:10px;border:1px solid rgba(255,255,255,.1);background:#2b2d33;color:#fff;font-size:20px}
    #tools button.is-active{outline:2px solid var(--accent)}

    /* === Bottom dock === */
    #bottom{position:fixed;left:12px;right:12px;bottom:12px;display:flex;gap:10px}
    #dock{display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:10px 12px;background:var(--panel);border-radius:var(--r);box-shadow:var(--shadow)}
    .swatch{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,.15);}
    .label{color:var(--muted)}

    /* === Stage === */
    #stageWrap{position:fixed;inset:0;display:grid;place-items:center}
    #stage{width:76vmin;max-width:min(92vw,92vh);aspect-ratio:1/1;background:#1a1a1a;border-radius:18px;display:grid;place-items:center;box-shadow:var(--shadow);padding:18px}
    #main{width:512px;height:512px;max-width:100%;max-height:100%;image-rendering:pixelated;background:#4d4d4d;border-radius:12px;border:1px solid rgba(255,255,255,.08)}

    /* Onion-skin badge */
    #onionBadge{position:fixed;right:20px;top:20px;background:#222;border:1px solid rgba(255,255,255,.1);padding:.35rem .6rem;border-radius:10px;color:var(--muted)}

    @media (max-width: 900px){
      #tools{top:92px;left:12px;right:12px;height:54px;display:flex;width:auto}
      #stage{padding:10px}
    }
  </style>
</head>
<body>
  <!-- TOP: frames strip -->
  <div id="topBar">
    <div id="frames" aria-label="Frames strip"></div>
    <div class="fbtns">
      <button id="btnAdd" title="L√§gg till ny bild (N)">Ôºã</button>
      <button id="btnDup" title="Duplicera bild (D)">‚ßâ</button>
      <button id="btnDel" title="Ta bort bild (Delete)">üóë</button>
      <button id="btnPlay" title="Spela/pausa (Space)">‚ñ∂Ô∏é</button>
      <label class="label" style="display:flex;align-items:center;gap:6px">FPS <input id="fps" type="range" min="1" max="24" value="8"/></label>
      <button id="btnExport" title="Exportera spritesheet + JSON">‚¨áÔ∏é Export</button>
    </div>
  </div>

  <!-- LEFT: tools -->
  <div id="tools">
    <button id="tool-pen" class="is-active" title="Pen (B)">‚úèÔ∏è</button>
    <button id="tool-eraser" title="Eraser (E)">ü©π</button>
    <button id="tool-onion" title="Onion skin (O)">üßÖ</button>
    <button id="tool-clear" title="Rensa (Ctrl+K)">üßº</button>
  </div>

  <!-- CENTER: stage -->
  <div id="stageWrap">
    <div id="stage">
      <canvas id="main" width="320" height="320"></canvas>
    </div>
  </div>

  <!-- BOTTOM: color/brush/zoom -->
  <div id="bottom">
    <div id="dock">
      <span class="label">F√§rg:</span>
      <div id="palette"></div>
      <span class="label">Pensel:</span>
      <input id="size" type="range" min="1" max="32" value="2"/>
      <span id="sizeVal" class="label">2 px</span>
      <span class="label">Zoom:</span>
      <input id="zoom" type="range" min="50" max="800" value="100"/>
      <span id="zoomVal" class="label">100%</span>
    </div>
  </div>

  <div id="onionBadge" hidden>Onion: P√•</div>

<script>
(() => {
  // ===== Abstraktion: CanvasEngine (s√• vi kan byta till MaxPaints motor senare) =====
  // API: engine.init(el, W, H) ‚Üí { viewCtx }
  //      engine.screenToDoc(x,y) ‚Üí {dx,dy}
  //      engine.drawDot(dx,dy, size, color|null for erase)
  //      engine.drawLine(dx0,dy0,dx1,dy1, size, color|null)
  //      engine.clear()
  //      engine.setZoom(z)
  //      engine.setPan(px,py)
  //      engine.drawFrameToView(sourceCanvas, onionPrevCanvas?)

  const W = 320, H = 320; // arbetsyta per frame
  const main = document.getElementById('main');

  // --- Hj√§lpare ---
  const clamp = (n,min,max)=> Math.max(min, Math.min(max, n));
  const iSnap = (v)=> Math.round(v); // helpixel-snappning i docs

  // ===== Enkel motor nu (kan bytas till MaxPaints komplexa senare) =====
  const SimpleEngine = () => {
    const view = main.getContext('2d', { willReadFrequently:true });
    view.imageSmoothingEnabled = false;
    let zoom = 1, panX = 0, panY = 0; // pan i doc-pixlar

    function docToViewRect(){
      const vw = Math.floor(W*zoom), vh = Math.floor(H*zoom);
      const ox = Math.floor((main.width - vw)/2 - panX*zoom);
      const oy = Math.floor((main.height - vh)/2 - panY*zoom);
      return { ox, oy, vw, vh };
    }
    function screenToDoc(sx,sy){
      const rect = main.getBoundingClientRect();
      const { ox, oy } = docToViewRect();
      const vx = (sx-rect.left) * (main.width/rect.width);
      const vy = (sy-rect.top)  * (main.height/rect.height);
      const dx = Math.floor((vx-ox)/zoom);
      const dy = Math.floor((vy-oy)/zoom);
      return { dx, dy };
    }
    function setZoom(z){ zoom = clamp(z, 0.25, 8); }
    function setPan(px,py){ panX = px; panY = py; }

    function drawFrameToView(source, onion){
      view.setTransform(1,0,0,1,0,0); view.clearRect(0,0,main.width, main.height);
      const { ox, oy } = docToViewRect();
      view.save(); view.imageSmoothingEnabled=false; view.translate(ox,oy); view.scale(zoom,zoom);
      if(onion){ view.globalAlpha=.35; view.drawImage(onion,0,0); view.globalAlpha=1; }
      view.drawImage(source,0,0);
      view.restore();
    }

    function drawDotOn(canvas, dx,dy, size, color){
      const g = canvas.getContext('2d'); g.imageSmoothingEnabled=false;
      const x = iSnap(dx - Math.floor(size/2));
      const y = iSnap(dy - Math.floor(size/2));
      if(color==null) g.clearRect(x,y,size,size);
      else { g.fillStyle = color; g.fillRect(x,y,size,size); }
    }
    function drawLineOn(canvas, x0,y0,x1,y1, size, color){
      const g = canvas.getContext('2d'); g.imageSmoothingEnabled=false;
      let dx = Math.abs(x1-x0), dy = Math.abs(y1-y0), sx = x0<x1?1:-1, sy = y0<y1?1:-1; let err = dx-dy;
      while(true){
        const x = iSnap(x0 - Math.floor(size/2));
        const y = iSnap(y0 - Math.floor(size/2));
        if(color==null) g.clearRect(x,y,size,size); else { g.fillStyle=color; g.fillRect(x,y,size,size); }
        if(x0===x1 && y0===y1) break; const e2=2*err; if(e2>-dy){ err-=dy; x0+=sx;} if(e2<dx){ err+=dx; y0+=sy; }
      }
    }

    return {
      init:()=>({ viewCtx:view }),
      screenToDoc,
      drawDot:(canvas,dx,dy,size,color)=> drawDotOn(canvas,dx,dy,size,color),
      drawLine:(canvas,dx0,dy0,dx1,dy1,size,color)=> drawLineOn(canvas,dx0,dy0,dx1,dy1,size,color),
      clear:(canvas)=> canvas.getContext('2d').clearRect(0,0,W,H),
      setZoom, setPan,
      drawFrameToView,
      // F√∂r ev. framtida kompat:
      getState:()=>({ zoom, panX, panY })
    };
  };

  // ===== Projekt/frames =====
  function makeFrame(){ const c=document.createElement('canvas'); c.width=W; c.height=H; const g=c.getContext('2d',{willReadFrequently:true}); g.imageSmoothingEnabled=false; g.clearRect(0,0,W,H); return c; }
  const frames = [makeFrame()];
  let current = 0, playing = false, onion = false;

  // ===== UI refs =====
  const framesEl = document.getElementById('frames');
  const btnAdd = document.getElementById('btnAdd');
  const btnDup = document.getElementById('btnDup');
  const btnDel = document.getElementById('btnDel');
  const btnPlay = document.getElementById('btnPlay');
  const fpsEl = document.getElementById('fps');
  const btnExport = document.getElementById('btnExport');
  const onionBadge = document.getElementById('onionBadge');
  const toolPen = document.getElementById('tool-pen');
  const toolEraser = document.getElementById('tool-eraser');
  const toolOnion = document.getElementById('tool-onion');
  const toolClear = document.getElementById('tool-clear');
  const palEl = document.getElementById('palette');
  const sizeEl = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const zoomEl = document.getElementById('zoom');
  const zoomVal = document.getElementById('zoomVal');

  // ===== Engine init =====
  const engine = SimpleEngine();
  engine.init();

  // ===== Palette/brush =====
  let brushColor = '#000000'; let brushSize = 2; let erasing = false; let zoom = 1; let panDX=0, panDY=0; let panning=false; let panStart={x:0,y:0,dx:0,dy:0};
  const COLORS=['#000','#fff','#ff0000','#00ff00','#0000ff','#ffff00','#ff7f00','#ff00ff','#00ffff','#7f7f7f'];
  COLORS.forEach(c=>{ const b=document.createElement('button'); b.className='swatch'; b.style.background=c; b.title=c; b.addEventListener('click',()=>{ brushColor=c; erasing=false; setActiveTool(toolPen);}); palEl.appendChild(b); });
  sizeEl.addEventListener('input', ()=>{ brushSize=+sizeEl.value; sizeVal.textContent=brushSize+" px"; });
  zoomEl.addEventListener('input', ()=>{ zoom=+zoomEl.value/100; engine.setZoom(zoom); zoomVal.textContent=Math.round(zoom*100)+"%"; draw(); });

  // ===== Timeline UI =====
  function renderFrames(){ framesEl.innerHTML=''; frames.forEach((f,i)=>{ const wrap=document.createElement('div'); wrap.className='frame'+(i===current?' active':''); const idx=document.createElement('div'); idx.className='idx'; idx.textContent=i+1; wrap.appendChild(idx); const t=document.createElement('canvas'); t.width=64; t.height=64; const t2=t.getContext('2d'); t2.imageSmoothingEnabled=false; t2.clearRect(0,0,64,64); t2.drawImage(f,0,0,64,64); wrap.appendChild(t); wrap.addEventListener('click',()=>{ current=i; draw(); renderFrames(); }); framesEl.appendChild(wrap); }); }
  function addFrame(){ frames.splice(current+1,0,makeFrame()); current++; renderFrames(); draw(); }
  function dupFrame(){ const c=makeFrame(); c.getContext('2d').drawImage(frames[current],0,0); frames.splice(current+1,0,c); current++; renderFrames(); draw(); }
  function delFrame(){ if(frames.length<=1) return; frames.splice(current,1); current=Math.max(0,current-1); renderFrames(); draw(); }
  btnAdd.onclick=addFrame; btnDup.onclick=dupFrame; btnDel.onclick=delFrame;

  // ===== Ritinteraktion =====
  let painting=false, lastDX=0, lastDY=0;
  function startPaint(e){ const {dx,dy}=engine.screenToDoc(e.clientX,e.clientY); engine.drawDot(frames[current],dx,dy,brushSize, erasing?null:brushColor); painting=true; lastDX=dx; lastDY=dy; main.setPointerCapture(e.pointerId); draw(); }
  function movePaint(e){ if(!painting) return; const {dx,dy}=engine.screenToDoc(e.clientX,e.clientY); engine.drawLine(frames[current],lastDX,lastDY,dx,dy,brushSize, erasing?null:brushColor); lastDX=dx; lastDY=dy; draw(); }
  function endPaint(){ painting=false; }

  // Panning: h√•ll Space och dra (eller middle mouse)
  function startPan(e){ panning=true; panStart={x:e.clientX,y:e.clientY,dx:panDX,dy:panDY}; }
  function movePan(e){ if(!panning) return; const dx=(e.clientX-panStart.x)/ (16*zoom); const dy=(e.clientY-panStart.y)/ (16*zoom); panDX = panStart.dx - dx; panDY = panStart.dy - dy; engine.setPan(panDX,panDY); draw(); }
  function endPan(){ panning=false; }

  main.addEventListener('pointerdown', e=>{
    if(e.button===1 || e.buttons===4 || e.getModifierState(' ')) { startPan(e); return; }
    startPaint(e);
  });
  main.addEventListener('pointermove', e=>{ if(panning) movePan(e); else movePaint(e); });
  window.addEventListener('pointerup', ()=>{ endPaint(); endPan(); });

  // ===== View draw (onion) =====
  function draw(){ const prev = onion && frames.length>1 ? frames[(current-1+frames.length)%frames.length] : null; engine.drawFrameToView(frames[current], prev); renderFrames(); }

  // ===== Verktyg =====
  function setActiveTool(btn){ [toolPen,toolEraser,toolOnion].forEach(b=>b.classList.remove('is-active')); btn.classList.add('is-active'); }
  toolPen.onclick=()=>{ erasing=false; setActiveTool(toolPen); };
  toolEraser.onclick=()=>{ erasing=true; setActiveTool(toolEraser); };
  toolOnion.onclick=()=>{ onion=!onion; onionBadge.hidden=!onion; setActiveTool(toolOnion); draw(); };
  toolClear.onclick=()=>{ const g=frames[current].getContext('2d'); g.clearRect(0,0,W,H); draw(); };

  // ===== Playback =====
  let raf,lastTime=0,acc=0; function loop(ts){ if(!playing){ raf=requestAnimationFrame(loop); return;} const fps=+fpsEl.value; const step=1000/fps; if(!lastTime) lastTime=ts; const dt=ts-lastTime; lastTime=ts; acc+=dt; if(acc>=step){ acc%=step; current=(current+1)%frames.length; draw(); } raf=requestAnimationFrame(loop);} raf=requestAnimationFrame(loop);
  btnPlay.onclick=()=>{ playing=!playing; btnPlay.textContent=playing?'‚è∏':'‚ñ∂Ô∏é'; };

  // ===== Export =====
  btnExport.onclick=()=>{ const sheet=document.createElement('canvas'); sheet.width=W*frames.length; sheet.height=H; const g=sheet.getContext('2d'); g.imageSmoothingEnabled=false; frames.forEach((f,i)=> g.drawImage(f,i*W,0)); sheet.toBlob(b=>{ const url=URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download='spritesheet.png'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); },'image/png'); const meta={ width:W,height:H,frames:frames.length,fps:+fpsEl.value,layout:'row'}; const blob=new Blob([JSON.stringify(meta,null,2)],{type:'application/json'}); const url2=URL.createObjectURL(blob); const a2=document.createElement('a'); a2.href=url2; a2.download='spritesheet.json'; a2.click(); setTimeout(()=>URL.revokeObjectURL(url2),1000); };

  // ===== Shortcuts =====
  window.addEventListener('keydown', e=>{ if(e.target.matches('input,textarea')) return; if(e.code==='Space'){ e.preventDefault(); } if(e.key==='n'||e.key==='N'){ addFrame(); } else if(e.key==='d'||e.key==='D'){ dupFrame(); } else if(e.key==='Delete'||e.key==='Backspace'){ delFrame(); } else if(e.code==='Space' && !playing){ /* pan handled via pointer */ } else if(e.key==='b'||e.key==='B'){ toolPen.click(); } else if(e.key==='e'||e.key==='E'){ toolEraser.click(); } else if(e.key==='o'||e.key==='O'){ toolOnion.click(); } else if((e.ctrlKey||e.metaKey)&& e.key.toLowerCase()==='k'){ toolClear.click(); } });

  // ===== F√∂rsta rendern =====
  engine.setZoom(zoom); engine.setPan(panDX,panDY); renderFrames(); draw();
})();
</script>
</body>
</html>
