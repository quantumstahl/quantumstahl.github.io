
<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/guarddown1.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game4.js"></script>
        
        <!-- === Highscore overlay UI (kan l√§ggas precis innan </body>) === -->
<style>
  #highscoreOverlay {
    position: fixed; inset: 0;
    display: none; justify-content: center; align-items: center; flex-direction: column;
    background: rgba(0,0,0,0.8); color: #fff; z-index: 9999; font-family: system-ui, sans-serif;
  }
  #highscoreBox { background:#222; padding:20px; border-radius:12px; width:min(90%, 360px); }
  #highscoreBox h2 { margin:0 0 10px; text-align:center; }
  #highscoreList { margin-top:10px; display:grid; gap:6px; }
  #highscoreList .row { display:flex; justify-content:space-between; font-variant-numeric: tabular-nums; }
  #highscoreClose { margin-top:14px; width:100%; padding:10px; border:0; border-radius:8px; background:#ff4757; color:#fff; cursor:pointer; }
</style>

<style>
  #hudTopRight{
    position:absolute; top:10px; right:10px; z-index:110;
    display:flex; flex-direction:column; align-items:flex-end; gap:8px;
    font-family:system-ui, sans-serif;
  }
  #hudTime{
    padding:6px 10px; border-radius:10px;
    background:rgba(0,0,0,.55); color:#fff; font-weight:800;
    font-size:44px; line-height:1;
  }
  #hudHigh{
    padding:8px 10px; border-radius:10px;
    background:rgba(0,0,0,.45); color:#fff; text-align:right;
  }
  #hudHigh .title{ font-size:18px; opacity:.9; margin-bottom:4px; }
  #hudHSList{ margin:0; padding-left:22px; font-size:18px; line-height:1.25; }
  
  
  
  
</style>





<!-- === Firebase (compat) ‚Äì INTE module === -->
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore-compat.js"></script>
        
        
    </head>
    <body>
        
        <div id="highscoreOverlay">
  <div id="highscoreBox">
    <h2>üèÜ Highscores üèÜ</h2>
    <div id="highscoreList">Laddar‚Ä¶</div>
    <button id="highscoreClose" onclick="hideHighscores()">St√§ng</button>
  </div>
</div>
        <div id="build-ui" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">
  <button id="build-base-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkgreen;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Bygg bas</button>
  <button id="build-barracks-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: darkred;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* <-- G√ñMD TILLS VIDARE */
">
  Bygg barack
  <button id="build-house-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: saddlebrown;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* visas n√§r bas √§r klar */
">
  Bygg hus

  
  
  
</button>
  
  
</div>
        
<div id="build-ui2" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-worker-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Tr√§na arbetare</button>
 
  
</div>        
<div id="build-ui3" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-warrior-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: red;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Tr√§na krigare</button>
 <button id="train-archer-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: orange;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Tr√§na archer</button>
  
</div>            

<div id="end-screen" style="
  position:fixed; inset:0; display:none; 
  align-items:center; justify-content:center; 
  background:rgba(0,0,0,0.8); z-index:2000; color:#fff; font-family:sans-serif;">
  <div style="text-align:center;">
    <div id="end-title" style="font-size:64px; font-weight:800; margin-bottom:16px;"></div>
    <div id="end-sub" style="font-size:22px; opacity:0.85; margin-bottom:28px; white-space:pre-line;"></div>
    <button id="btn-restart" style="
      font-size:18px; padding:12px 20px; border:0; border-radius:10px; 
      background:linear-gradient(180deg,#48bb78,#2f855a); color:#fff; cursor:pointer;">
      Spela igen
    </button>
  </div>
</div>

<div id="place-hint" style="
  position:fixed; bottom:84px; left:0; right:0; text-align:center;
  color:#fff; font:600 36px/1.2 system-ui, sans-serif;
  text-shadow:0 1px 2px rgba(0,0,0,.6); display:none; z-index:1200;">
  Tryck p√• kartan f√∂r att placera
</div>

<div id="hint-pan" style="
  position:fixed; bottom:50%; left:50%; transform:translate(-50%, 50%);
  background:rgba(0,0,0,0.6);
  color:#fff; padding:6px 10px;
  border-radius:6px;
  font:600 50px system-ui, sans-serif;
  text-align:center;
  z-index:2000;
  display:none;">
</div>





        
<div id="resourceUI" style="position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; font-family: sans-serif; font-size: 50px; z-index: 100;">
    <img src="images/gold.png" style="width:50px; vertical-align: middle;">Guld: <span id="goldCount">0</span><br>
    <img src="images/wood.png" style="width:50px; vertical-align: middle;">Tr√§: <span id="woodCount">0</span><br>
    <img src="images/husikon.png" style="width:50px; vertical-align: middle;">Pop: <span id="popCount">0/0</span>
</div>   
  
<!-- HUD: klocka + topp-5 highscore -->
<div id="hudTopRight">
  <div id="hudTime">0:00</div>

  <div id="hudHigh">
    <div class="title">Highscores (b√§st tid)</div>
    <ol id="hudHSList"></ol>
  </div>
</div>    
        
        
        
        
        
        
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
        <button onclick="showHighscores()" 
        style="position:absolute; top:200px; left:10px; z-index:10;display:none">
  Visa Highscores
</button>
        <script>

// --- Din Firebase-konfiguration (byt till din egen fr√•n Firebase Console) ---
  const firebaseConfig = {
    apiKey: "AIzaSyBYYt70RjAeGaWWoVAWg2Avz0ePieN3Yzg",
    authDomain: "rts-highscores.firebaseapp.com",
    projectId: "rts-highscores",
    storageBucket: "rts-highscores.firebasestorage.app",
    messagingSenderId: "122151559134",
    appId: "1:122151559134:web:1f35afba47b5729390c74f"
  };

  // Initiera
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // Formattera tid som m:ss.hh (hundradelar)
  function formatTime(t) {
  let s = Number(t) || 0;
  const m = Math.floor(s / 60);
  const sec = Math.floor(s % 60);
  const hh = Math.floor((s - Math.floor(s)) * 100);

  if (m > 0) {
    // Har minuter
    return hh > 0
      ? `${m}:${String(sec).padStart(2, "0")}.${String(hh).padStart(2, "0")}`
      : `${m}:${String(sec).padStart(2, "0")}`;
  } else {
    // Inga minuter
    return hh > 0
      ? `${sec}.${String(hh).padStart(2, "0")}`
      : `${sec}`;
  }
}

  // Spara highscore (name: str, time: number i sekunder)
  function saveHighscore(name, time) {
    return db.collection("highscores").add({
      name: String(name).slice(0, 24), // liten sanitering
      time: Number(time),
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });
  }

  // H√§mta topp 10 (sorterat p√• tid, sen namn)
  function getHighscores() {
    return db.collection("highscores")
      .orderBy("time", "asc")
      .orderBy("name", "asc")
      .limit(10)
      .get()
      .then(snap => snap.docs.map(d => d.data()));
  }

  // UI: visa/d√∂lj overlay
  function showHighscores() {
    const listDiv = document.getElementById("highscoreList");
    listDiv.textContent = "Laddar‚Ä¶";
    getHighscores().then(scores => {
      if (!scores.length) {
        listDiv.textContent = "Inga highscores √§nnu.";
        return;
      }
      listDiv.innerHTML = scores.map((s, i) => `
        <div class="row">
          <span>${i+1}. ${s.name}</span>
          <span>${formatTime(s.time)}</span>
        </div>
      `).join("");
    }).catch(err => {
      console.error(err);
      listDiv.textContent = "Kunde inte h√§mta highscores.";
    });
    document.getElementById("highscoreOverlay").style.display = "flex";
  }
  function hideHighscores() {
    document.getElementById("highscoreOverlay").style.display = "none";
  }

  // === Anropa denna n√§r spelaren vinner ===
  // Ex: playerWon(elapsedMs/1000)
  function playerWon(timeInSeconds) {
  const name = prompt("Grattis! Du vann! Skriv in ditt namn:");
  if (!name || !name.trim()) return;
  saveHighscore(name.trim(), Number(timeInSeconds))
    .then(() => {
      loadTopHighscoreHUD();  // uppdatera HUD direkt
      showHighscores();       // visa listan
    })
    .catch(err => {
      console.error("Kunde inte spara highscore:", err);
      alert("Kunde inte spara highscore just nu.");
    });
}

  // Exponera globalt (andra script kan kalla dessa)
  window.playerWon = playerWon;
  window.showHighscores = showHighscores;
  window.hideHighscores = hideHighscores;

async function loadTopHighscoreHUD(limit = 5) {
  const listEl = document.getElementById("hudHSList");
  if (!listEl) return;

  try {
    let scores = await getHighscores();           // antas ge topp-lista
    if (!Array.isArray(scores)) scores = [];

    // S√§kerst√§ll sortering: l√§gst tid = b√§st
    scores = scores.slice().sort((a,b) => (a.time ?? 9e9) - (b.time ?? 9e9));

    const top = scores.slice(0, limit);
    listEl.innerHTML = "";

    if (top.length === 0) {
      listEl.innerHTML = `<li>‚Äì</li>`;
      return;
    }

    for (let i = 0; i < top.length; i++) {
      const s = top[i];
      const name = (s.name && String(s.name).trim()) || "Ok√§nd";
      const timeStr = typeof formatTime === "function"
        ? formatTime(Number(s.time || 0))
        : (Number(s.time||0)).toFixed(1) + "s";

      const li = document.createElement("li");
      li.textContent = `${name} ‚Äì ${timeStr}`;
      listEl.appendChild(li);
    }
  } catch (e) {
    console.error("Kunde inte ladda highscores till HUD:", e);
  }
}
const gameClock = (() => {
  let accMs = 0;             // ackumulerad aktiv tid i ms
  let running = true;        // k√∂rs nu?
  let last = performance.now();

  function pause() {
    if (!running) return;
    accMs += performance.now() - last;
    running = false;
  }
  function resume() {
    if (running) return;
    last = performance.now();
    running = true;
  }
  function reset() {
    accMs = 0;
    last = performance.now();
    running = true;
  }
  function seconds() {
    return (accMs + (running ? (performance.now() - last) : 0)) / 1000;
  }
  return { pause, resume, reset, seconds, get running(){ return running; } };
})();
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

            game = new Game4("Spelet");
            var audio = new Audio('sounds/war3.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
            window.allowSelection = function() {
                return !buildMode; // till√•t bara selektion n√§r man inte bygger
            };
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                      if (buildMode && ghostBuilding) {
                        const t = e.touches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        const gx = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        const gy = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        ghostBuilding.x = gx;
                        ghostBuilding.y = gy;
                        lastTouchPos = {x: gx, y: gy};
                      }
                    if (buildMode && !fromUI(e.target)) {
                        buildArmed = true; // nu f√•r man placera
                      }
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/war3.mp3';context.resume();
                        gameClock.resume();
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
                   gameClock.pause();
              }
          });

           
            
            
            let keysPressed = {};
                document.addEventListener('click', (event) => {
        
               
                try{if(audio.paused){ 
                        audio.play();
                    }
                }catch(error){};
             });

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            document.addEventListener("keydown", function(e) {
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
            });
            let buildMode = false;
            let buildType = null;
            let ghostBuilding = null;
            let pendingBuilds = [];
            let selectedWorkersBeforeBuild = [];
            let selectedWorkers = [];
            let lastTouchPos = null;
            let gold = 600;
            let wood = 500;
            let rgold = 600;
            let rwood = 500;
            let gameOver = false;
            let buildArmed = false;
            let popUsed = 0, popCap = 0;
            let rpopUsed = 0, rpopCap = 0;
            let gameStartTime = Date.now();
            
            // --- Archer-nerf ---
            const ARCHER_MAX_HP       = 55;    // s√§nk max-hp (g√§ller archer + rarcher)
            const ARCHER_SLOW_MS      = 1400;   // s√• l√§nge g√•r de l√•ngsammare efter ett skott
            const ARCHER_SLOW_MULT    = 0.55;  // r√∂relsehastighet under ‚Äúskjuter‚Äù
            function nowMs(){ return (typeof performance!=="undefined" ? performance.now() : Date.now()); }

            const POP_COST = {
              worker: 1, guard: 1, archer: 1,
              rworker: 1, rguard: 1, rarcher: 1
            };
            
            
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}
            const IS_TOUCH = mobileAndTabletCheck();

            function clearSelection() {
              const all = game.getAllObjects();
              for (const o of all) o.selected = false;
            }
            function fromUI(evtTarget){
                return !!(evtTarget && evtTarget.closest &&
                  evtTarget.closest('#build-ui, #build-ui2, #build-ui3, button'));
              }
            function setBuildUIActive(on) {
                
                const hint = document.getElementById("place-hint");
                if (hint) hint.style.display = on ? "block" : "none";
                
                const btn = document.getElementById(buildType === "base" ? "build-base-btn" : "build-barracks-btn");
                if (!btn) return;
                btn.style.outline = on ? "3px solid gold" : "none";
                btn.style.boxShadow = on ? "0 0 12px gold" : "none";
              }  
            function showPanHint(){
                const el = document.getElementById("hint-pan");
                if (el) {
                  el.innerText = IS_TOUCH
                    ? "Anv√§nd tv√• fingrar f√∂r att flytta kartan"
                    : "Anv√§nd W A S D f√∂r att flytta kartan";
                  el.style.display = "block";
                  setTimeout(()=> el.style.display = "none", 3000);
                }
            } 
              
            document.getElementById("btn-restart").addEventListener("click", () => {
                // enklaste reset: ladda om
                location.reload();
              });
            
            
            document.getElementById("build-base-btn").innerHTML = "Bygg bas<br>500 guld / 500 tr√§";
            document.getElementById("build-barracks-btn").innerHTML = "Bygg barrack<br>150 guld / 150 tr√§";
            document.getElementById("build-house-btn").innerHTML = "Bygg hus<br>50 tr√§";
            document.getElementById("train-worker-btn").innerHTML = "Tr√§na arbetare<br>50 guld";
            document.getElementById("train-warrior-btn").innerHTML = "Tr√§na warrior<br>75 guld";
            document.getElementById("train-archer-btn").innerHTML = "Tr√§na archer<br>75 guld / 75 tr√§";
            document.getElementById("build-base-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=500&&wood>=500){gold-=500;wood-=500;}    
                else return;    
                buildMode = true;
                buildType = "base";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("base"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("build-barracks-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=150&&wood>=150){gold-=150;wood-=150;}    
                else return;    
                buildMode = true;
                buildType = "bar";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("bar"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("build-house-btn").addEventListener("click", function() {
                    if (ghostBuilding) ghostBuilding.animation = 2;

                    // Kr√§ver f√§rdig base
                    const haveReadyBase = game.getAllObjectsoftype(game.getobjecttype("base"))
                                             .some(b => b.animation === 1 && !b.ghost);
                    if (!haveReadyBase) return;

                    // Kostnad
                    if (wood >= 50) {wood -= 50; }
                    else return;

                    buildMode = true;
                    buildType = "house";

                    selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected);
                    game.getAllObjects().forEach(o => { if (!selectedWorkersBeforeBuild.includes(o)) o.selected = false; });

                    // Ghost
                    const t = game.getobjecttype("house");
                    ghostBuilding = game.addobject(t, 0, 0, t.standarddimx || 100, t.standarddimy || 100, 0, false);
                    ghostBuilding.ghost = true;
                    ghostBuilding.selectable = false;
                    ghostBuilding.animation = 2; // bygg-ghost
                    setBuildUIActive(true);
                  });
            
            
            document.getElementById("train-worker-btn").addEventListener("click", () => {
                const base = game.getAllObjectsoftype(game.getobjecttype("base")).find(b => b.selected);
                if (!base) return;
                if (!canAddUnitToPopQueue("worker")) return;
                if (gold >= 50) {
                    gold -= 50;

                    base.buildQueue = base.buildQueue || [];
                    base.buildQueue.push("worker");
                } else {
                   
                }
            });    
            document.getElementById("train-warrior-btn").addEventListener("click", () => {
                const bar = game.getAllObjectsoftype(game.getobjecttype("bar")).find(b => b.selected);
                if (!bar) return;
                if (!canAddUnitToPopQueue("guard")) return;
                if (gold >= 75) {
                    gold -= 75;

                    bar.buildQueue = bar.buildQueue || [];
                    bar.buildQueue.push("guard");
                } else {
                   
                }
            }); 
            document.getElementById("train-archer-btn").addEventListener("click", () => {
                const bar = game.getAllObjectsoftype(game.getobjecttype("bar")).find(b => b.selected);
                if (!bar) return;
                if (!canAddUnitToPopQueue("archer")) return;
                if (gold >= 75 && wood>=75) {
                  gold -= 75;wood -= 75;
                  bar.buildQueue = bar.buildQueue || [];
                  bar.buildQueue.push("archer");
                }
              });
            
            document.addEventListener("touchmove", function(e) {
                                if (e.target.closest("#build-ui")) {return;}
                                 if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;}
                if (e.touches.length >= 2 && buildMode) {
                    cancelBuildMode();
                    return;
                }
                
                
    
              if (buildMode && ghostBuilding) {
    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
    let touch = e.touches[0];
    lastTouchPos = {
        x: touch.clientX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2,
        y: touch.clientY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2
    };
    ghostBuilding.x = lastTouchPos.x;
    ghostBuilding.y = lastTouchPos.y;
    ghostBuilding.animation=0;
    isPlacingBuilding = true;
}
            
            
            });
            
            document.addEventListener("touchend", function(e) {
				selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
				
							if(w.counter2>10){
                            if(w.workobject)w.workobject.occupied=false;                                
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
							}
                        }
                
                
                 if(ghostBuilding!=null&&isBuildPlacementValid(ghostBuilding)==false){return;}
        
                if (buildMode && ghostBuilding) {
                    
                    if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;} // <-- inga ‚Äúdubbeltryck p√• knappen‚Äù-placeringar
                    buildArmed = false; // kr√§ver nytt tryck p√• kartan f√∂r n√§sta bygge
  
                    
                    
                    
                    if (lastTouchPos == null) {
                        const t = e.changedTouches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        ghostBuilding.x = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        ghostBuilding.y = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        
                    }

                      if (isBuildPlacementValid(ghostBuilding) === false) return;

                    
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    isPlacingBuilding = false;
                    ghostBuilding.iscontrollable=true;
                    ghostBuilding.animation=0;
                    ghostBuilding.health=1;
                    setBuildUIActive(false);
                    
                    
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {
                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        clearSelection();
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
                
                
                
                
                
                
                
                
                
                
            });
            
            document.addEventListener("contextmenu", function(e) {
                e.preventDefault(); // f√∂rhindra browserns meny
                
                
                if (buildMode) {
            
                    cancelBuildMode();
                }
            });

            
            document.addEventListener("mousemove", function(e) {
                cursorX = e.clientX;
                cursorY = e.clientY;
                lastTouchPos = null; // ‚Üê detta s√§ger "vi √§r i PC-l√§ge"
                ghostBuilding.animation=0;
            });
            document.addEventListener("mousedown", function(e) {
                selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
                            if(w.workobject)w.workobject.occupied=false;
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
                            
                        }
                
                
                if(isBuildPlacementValid(ghostBuilding)==false)return;
                
                if (fromUI(e.target)) return;   // ignorera klick i UI
                if (buildMode) buildArmed = true;
                
                
                
                if (e.button === 2 && buildMode) {
                    e.preventDefault(); // hindra fokus/kontext
                    return; // inget mer k√∂rs
                }
                
                
                if (buildMode && ghostBuilding) {
                    const currentMap = game.maps[game.currentmap];
                    const x = ghostBuilding.x;
                    const y = ghostBuilding.y;

                    if (!buildArmed) return;      // inte armat ‚Üí ingen placering
                    // commit bygget (din befintliga kod)
                    buildArmed = false;  
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    ghostBuilding.iscontrollable=true;
                    setBuildUIActive(false);
                    ghostBuilding.health=1;
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {

                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
            });
            
            let inputClick = null;  // world-coords f√∂r senaste klick/tap

            function toWorldCoords(clientX, clientY){
              const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
              return {
                x: clientX/zoom - game.maps[game.currentmap].camerax,
                y: clientY/zoom - game.maps[game.currentmap].cameray
              };
            }

            document.addEventListener('mousedown', (e) => {
              inputClick = toWorldCoords(e.clientX, e.clientY);
            });

            document.addEventListener('touchend', (e) => {
              const t = e.changedTouches[0];
              inputClick = toWorldCoords(t.clientX, t.clientY);
            });
            function pointInObj(px, py, o){
                return px >= o.x && px <= o.x + o.dimx && py >= o.y && py <= o.y + o.dimy;
              }
            function pressedThisFrame(o){
              if (o.mousepressed) return true;                 // desktop
              if (inputClick && pointInObj(inputClick.x, inputClick.y, o)) return true; // mobil/desktop
              return false;
            }
            function consumeInputClick(){ inputClick = null; }
            
             showPanHint();
             loadTopHighscoreHUD();
             
             var check = function(){
                 
                // HUD: uppdatera speltid i sekunder ‚Üí formatTime
                // HUD: speltid
                const elapsedSec = gameClock.seconds();
                const hudTimeEl = document.getElementById("hudTime");
                if (hudTimeEl) hudTimeEl.textContent = formatTime(elapsedSec);
                 
                canvas.width=document.body.clientWidth;
                canvas.height=document.body.clientHeight-8;
                 
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
                
                const camSpeed = 15;
                const currentMap = game.maps[game.currentmap];

                if (keyState.w) currentMap.cameray += camSpeed;
                if (keyState.s) currentMap.cameray -= camSpeed;
                if (keyState.a) currentMap.camerax += camSpeed;
                if (keyState.d) currentMap.camerax -= camSpeed;
                
                recalcPopulation();
                document.getElementById("goldCount").textContent = gold;
                document.getElementById("woodCount").textContent = wood;
                document.getElementById("popCount").textContent  = `${popUsed}/${popCap}`;
                
                
                let anyWorkerSelected = false;
                if (game.maps.length > 0) {
                    const workers = game.getobjecttype("worker");
                    if (workers) {
                        anyWorkerSelected = workers.objects.some(o => o.selected);
                    }
                }
                document.getElementById("build-ui").style.display = anyWorkerSelected ? "flex" : "none";
                
                
                game.updateanimation(ctx);
                
                drawHealthBars();
		gras= game.getobjecttype("ground"); 				
                guard =game.getobjecttype("guard"); 
                worker =game.getobjecttype("worker"); 
                tree =game.getobjecttype("tree"); 
                goldmine =game.getobjecttype("goldmine"); 
                base=game.getobjecttype("base"); 
                archer=game.getobjecttype("archer"); 
                house=game.getobjecttype("house");
                
                //ENEMYS
                rbar =game.getobjecttype("rbar"); 
                rbase =game.getobjecttype("rbase"); 
                rguard =game.getobjecttype("rguard"); 
                rworker =game.getobjecttype("rworker"); 
                rarcher=game.getobjecttype("rarcher"); 
                rhouse=game.getobjecttype("rhouse");
                
                //projectiles
                arrow =game.getobjecttype("arrow"); 
                
                
                if (buildMode && ghostBuilding&& lastTouchPos === null) {
                    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                    ghostBuilding.x = cursorX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2;
                    ghostBuilding.y = cursorY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2;
                }
                
                
                
                
                
                
                
                
                if(guard!=null){
                    
                    // Vilka av dina enheter ska lyda ordern?
                    const selectedUnits = [
                      ...game.getAllObjectsoftype(game.getobjecttype("guard")).filter(u => u.selected),
                      ...game.getAllObjectsoftype(game.getobjecttype("worker")).filter(u => u.selected),
                    ];

                    function orderFollow(target) {
                      for (const u of selectedUnits) {
                        u.followTarget = true;         // flagga f√∂r ‚Äúh√•ll fast vid m√•let‚Äù
                        u.targetObject = target;       // <- viktigt
                        u.workobject = null;           // sl√§pp ev. jobb
                        u.deliveryTarget = null;
                        u.returning = false;
                        u.lockDirection = false;       // vi vill kunna sv√§nga efter m√•let

                        const cx = target.x + target.dimx/2;
                        const cy = target.y + target.dimy/2;
                        u.targetX = cx - u.dimx/2;     // initial chase s√• de b√∂rjar g√• direkt
                        u.targetY = cy - u.dimy/2;
                      }
                    }

                    // Kolla klick p√• fiender (enheter + byggnader)
                    let enemyClicked = null;
                    for (const e of (game.getobjecttype("rguard")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rworker")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbase")?.objects  || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbar")?.objects   || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rhouse")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (enemyClicked && selectedUnits.length) {
                      orderFollow(enemyClicked);
                      if (IS_TOUCH) clearSelection();
                    }
                    
                    
                    function isAlive(o){
                        return !!o && !o.ghost && game.getAllObjects().includes(o);
                      }

                      // Alla dina guards + workers ska ‚Äújaga‚Äù sitt target om followTarget=true
                      const myUnits = [
                        ...game.getobjecttype("guard")?.objects || [],
                        ...game.getobjecttype("worker")?.objects || [],
                      ];

                      for (const u of myUnits) {
                        if (u.followTarget && u.targetObject) {
                          if (!isAlive(u.targetObject)) {
                            // m√•let dog/f√∂rsvann ‚Üí sl√§pp
                            u.followTarget = false;
                            u.targetObject = null;
                            continue;
                          }
                          const t = u.targetObject;
                          const cx = t.x + t.dimx/2;
                          const cy = t.y + t.dimy/2;
                          u.targetX = cx - u.dimx/2;   // uppdatera mot m√•lets nuvarande position
                          u.targetY = cy - u.dimy/2;
                        }
                      }
                    
                    
                    
                    
                    
                    
                    
                    
                    const anyBaseSelected = game.getAllObjectsoftype(game.getobjecttype("base")).some(o => o.selected);
                    document.getElementById("build-ui2").style.display = anyBaseSelected ? "flex" : "none";
                    
                    const anyBarSelected = game.getAllObjectsoftype(game.getobjecttype("bar")).some(o => o.selected);
                    document.getElementById("build-ui3").style.display = anyBarSelected ? "flex" : "none";
                    
                    
                    const canAffordBase = gold >= 500 && wood >= 500;
                    const canAffordWorker = gold >= 50 && wood >= 0;
                    const canAffordWarrior = gold >= 75 && wood >= 0;
                    
                    const canAffordArcher  = gold >= 75 && wood >= 75;
                    const hasPopForArcher  = canAddUnitToPopQueue("archer");
                    
                    const hasPopForWorker  = canAddUnitToPopQueue("worker");
                    const hasPopForWarrior = canAddUnitToPopQueue("guard");
                    
                    const canAffordBar = gold >= 150 && wood >= 150;
                    const canAffordHouse = wood >= 50;
                    
                    
                    function paintBtn(id, ok){
                        const el = document.getElementById(id);
                        if (!el) return;
                        // aldrig genomskinlig:
                        el.style.opacity = "1";
                        // tydlig f√§rgkod:
                        el.style.backgroundColor = ok ? "#37c96b" : "#ff7a7a"; // gr√∂n / ljusr√∂d
                        el.style.color = "#fff";
                        el.style.borderRadius = "10px";
                        el.style.border = "1px solid rgba(255,255,255,.15)";
                        el.style.boxShadow = ok
                          ? "0 0 0 2px rgba(55,201,107,.25) inset"
                          : "0 0 0 2px rgba(255,0,0,.18) inset";
                    }
                    
                    
                    paintBtn("build-house-btn",     canAffordHouse);
                    paintBtn("build-base-btn",      canAffordBase);
                    paintBtn("train-worker-btn",    (canAffordWorker  && hasPopForWorker));
                    paintBtn("train-warrior-btn",   (canAffordWarrior && hasPopForWarrior));
                    paintBtn("build-barracks-btn",  canAffordBar);
                    paintBtn("train-archer-btn",    (canAffordArcher  && hasPopForArcher));
                    
                    if (base.objects.length>0&&base.objects[0].animation==1) {
                        document.getElementById("build-barracks-btn").style.display = "inline-block";
                        document.getElementById("build-house-btn").style.display = "inline-block";
                    }

                    
                  
                    selectedWorkers = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                    
                    const basesAndBars = [
                        ...game.getAllObjectsoftype(game.getobjecttype("base")),
                        ...game.getAllObjectsoftype(game.getobjecttype("bar")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbase")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbar")),
                    ];

                    for (let base of basesAndBars) {
                        if(base.animation==0)break;
                        
                        base.buildQueue = base.buildQueue || [];
                        base.buildTimer = base.buildTimer || 0;

                        if (base.buildQueue.length > 0) {
                            if (!canAddUnitToPopQueue(base.buildQueue[0])) {continue ;}   
                            
                            base.buildTimer++;

                            // s√• l√§nge vi hinner producera
                            while (base.buildQueue.length > 0 && base.buildTimer >= 1000) {
                                const unitType = game.getobjecttype(base.buildQueue[0]);
                                  
                                const spacing = 100;
                                const directions = [
                                    [spacing, 0], [-spacing, 0], [0, spacing], [0, -spacing],
                                    [spacing, spacing], [-spacing, -spacing], [spacing, -spacing], [-spacing, spacing]
                                ];

                                let placed = false;

                                for (let [dx, dy] of directions) {
                                    const px = base.x + base.dimx / 2 + dx;
                                    const py = base.y + base.dimy / 2 + dy;

                                    const newUnit = game.addobject(
                                        unitType,
                                        px,
                                        py,
                                        unitType.standarddimx,
                                        unitType.standarddimy,
                                        0,
                                        false
                                    );

                                    const overlaps = newUnit.collideslist(game.maps, game.currentmap, "any");

                                    if (!overlaps) {
                                        placed = true;
                                        break;
                                    } else {
                                        game.removeobject(unitType, newUnit);
                                    }
                                }

                                if (placed) {
                                    base.buildQueue.shift();
                                    base.buildTimer -= 1000; // üí° forts√§tt direkt om n√§sta ocks√• √§r klar
                                } else {
                                    // avbryt loopen, f√∂rs√∂k igen n√§sta frame
                                    break;
                                }
                            }
                        }
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    for(let i=0;i<goldmine.objects.length;i++){
                        
                        if(goldmine.objects[i].selectable==false){
                            goldmine.objects[i].maxhealth=2500;
                            goldmine.objects[i].health=2500;
                            
                        }
                        
                        goldmine.objects[i].selectable=true;
                        goldmine.objects[i].canMove=false;
                        if(goldmine.objects[i].mousepressed==true&&anyWorkerSelected){

                            for (let w of selectedWorkers) {

                                w.workobject=goldmine.objects[i];
				w.counter2=0;
                                if (IS_TOUCH) w.selected=false;
                            }
                        }


                    }
                    for(let i=0;i<tree.objects.length;i++){
                        
                        if(tree.objects[i].canMove==true){
                            tree.objects[i].maxhealth=30;
                            tree.objects[i].health=30;
                            tree.objects[i].selectable=true;
                            
                        }
                        
                        
                        tree.objects[i].canMove=false;
                    
                        if(tree.objects[i].mousepressed==true&&anyWorkerSelected){
                             
                             assignWorkersToNearestTreesSmart();
                             if (IS_TOUCH) clearSelection();
                        }


                    }
                    
                    
                    
                    
                    for(let i=0;i<guard.objects.length;i++){

                        guard.objects[i].selectable=true;
                        guard.objects[i].iscontrollable=true;
                        if ( guard.objects[i].direction === "up")  guard.objects[i].animation = 0;
                        else if ( guard.objects[i].direction === "right")  guard.objects[i].animation = 1;
                        else if ( guard.objects[i].direction === "down")  guard.objects[i].animation = 2;
                        else if ( guard.objects[i].direction === "left")  guard.objects[i].animation = 3;
                        
                        

                    }
                     for(let i=0;i<archer.objects.length;i++){
                         if(archer.objects[i].selectable==false){
                            clampArcherHP(archer.objects[i]);       // s√§nk start-HP om den var h√∂gre
                        }
                        applyArcherSpeed(archer.objects[i]);
                        archer.objects[i].selectable=true;
                        archer.objects[i].iscontrollable=true;
                        if ( archer.objects[i].direction === "up")  archer.objects[i].animation = 0;
                        else if ( archer.objects[i].direction === "right")  {archer.objects[i].animation = 1;archer.objects[i].fliped=false;}
                        else if ( archer.objects[i].direction === "down")  archer.objects[i].animation = 2;
                        else if ( archer.objects[i].direction === "left") { archer.objects[i].animation = 1;archer.objects[i].fliped=true;}

                    }
                    for(let i=0;i<rarcher.objects.length;i++){
                        rarcher.aiNoLocalAvoid = true;
                        if(rarcher.objects[i].selectable==false){
                            clampArcherHP(rarcher.objects[i]);       // s√§nk start-HP om den var h√∂gre
                        }
                        applyArcherSpeed(rarcher.objects[i]);
                        rarcher.objects[i].selectable=true;
                        if ( rarcher.objects[i].direction === "up")  rarcher.objects[i].animation = 0;
                        else if ( rarcher.objects[i].direction === "right")  {rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=false;}
                        else if ( rarcher.objects[i].direction === "down")  rarcher.objects[i].animation = 2;
                        else if ( rarcher.objects[i].direction === "left") { rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=true;}
                        
                        

                    }
                    
                    for(let i=0;i<rguard.objects.length;i++){

                        rguard.objects[i].selectable=true;
                        rguard.aiNoLocalAvoid = true; // movement anv√§nder mikro-styrning (ovan)
                        rguard.lockDirection  = true; // AI s√§tter facing f√∂r kollisions-attack
                        rguard.aiHoldTarget   = true; // AI sl√§pper sj√§lv m√•let f√∂rst n√§r det vill

                        if ( rguard.objects[i].direction === "up")  rguard.objects[i].animation = 0;
                        else if ( rguard.objects[i].direction === "right")  rguard.objects[i].animation = 1;
                        else if ( rguard.objects[i].direction === "down")  rguard.objects[i].animation = 2;
                        else if ( rguard.objects[i].direction === "left")  rguard.objects[i].animation = 3;
                        
                        

                    }
             
                    for(let i=0;i<worker.objects.length;i++){

                        worker.objects[i].selectable=true;
			worker.objects[i].counter2++;
                        worker.objects[i].iscontrollable=true;
                        
                        
                        
                        
                        if ( worker.objects[i].direction === "up")  worker.objects[i].animation = 0;
                        else if ( worker.objects[i].direction === "right")  {worker.objects[i].animation = 1;worker.objects[i].fliped=false;}
                        else if ( worker.objects[i].direction === "down")  worker.objects[i].animation = 2;
                        else if ( worker.objects[i].direction === "left") { worker.objects[i].animation = 1;worker.objects[i].fliped=true;}
                        
                        
                         for (let j = 0; j < pendingBuilds.length; j++) {
                            let building = pendingBuilds[j];

                            if (game.collideswithanoterobject(worker.objects[i],building)) {
                                building.buildProgress = (building.buildProgress || 0) + 1;
                                 building.health = Math.max(1, Math.floor((building.buildProgress / 1000) * 800));
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                
                                 // bygg-animation

                                if (building.buildProgress > 1000) {
                                    // Klar ‚Äì ta bort fr√•n pendingBuilds
                                    pendingBuilds.splice(j, 1);
                                    building.buildProgress = null;
                                    worker.objects[i].buildingTarget = null;
                                    worker.objects[i].animation = 0; // idle
                                    building.animation=1;
                                }
                                
                            }
                        }
                        
                        
                        
                        // Om m√•lresursen blev utt√∂md: sl√§pp och hitta ny av samma typ
if (worker.objects[i].workobject && isDepleted(worker.objects[i].workobject)&&worker.objects[i].returning==false) {
  const cur = worker.objects[i].workobject;
  const wasType = cur.name;
  cur.occupied = false;
  worker.objects[i].workobject = null;
  worker.objects[i].targetObject = null;
  worker.objects[i].counter = 0;

  const pool = game.getAllObjectsoftype(game.getobjecttype(wasType))
    .filter(n => !n.occupied && !isDepleted(n));
  if (pool.length) {
    let best = null, bestD = Infinity;
    for (const n of pool) {
      const d = game.getDistance(worker.objects[i].x, worker.objects[i].y, n.x, n.y);
      if (d < bestD) { bestD = d; best = n; }
    }
    if (best) {
      best.occupied = (wasType === "tree");
      worker.objects[i].workobject = best;
      worker.objects[i].targetX = best.x + (best.dimx||0)/2;
      worker.objects[i].targetY = best.y + (best.dimy||0)/2;
    }
  }
}
                        
                        
                        
                        
                        
                        
                        if(worker.objects[i].workobject!=null&&worker.objects[i].returning==false){
                            
                            if(worker.objects[i].workobject.name=="goldmine"){
                                
                                worker.objects[i].targetX = worker.objects[i].workobject.x+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                                
                            }
                            else{
                                worker.objects[i].targetX = worker.objects[i].workobject.x;//+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                            }
                            
                        
                            
                            if(worker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(worker.objects[i],"tree");
                                if(oo&&worker.objects[i].workobject!=oo&&oo.ghost==false){worker.objects[i].workobject.occupied=false;worker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<1002) {
                                    if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                    if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                    worker.objects[i].counter++;

                                }
                                if (worker.objects[i].counter > 1000) {
                                    // Hitta n√§rmsta base
                                    if(game.getobjecttype("base").objects.length==0||game.getobjecttype("base").objects[0].ghost==true )continue;
                                    const node = worker.objects[i].workobject;
                                    const available = Math.max(0, (node.health ?? node.maxhealth ?? 0));
                                    const take = Math.min(10, available);
                                    if (node.health != null) node.health -= take;
                                    if (node.health != null && node.health <= 0) markDepleted(node);
                                    
                                    
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = worker.objects[i].x - b.x;
                                        let dy = worker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        worker.objects[i].targetX = closest.x+closest.dimx/2;
                                        worker.objects[i].targetY = closest.y+closest.dimy/2;
                                        worker.objects[i].targetObject=closest;
                                        worker.objects[i].returning = true; // ny flagga
                                        worker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<202) {
                                    worker.objects[i].animation=100;
                                    worker.objects[i].counter++;

                                }
                                
                            if (worker.objects[i].counter > 200) {
                                // Hitta n√§rmsta base
                                if(game.getobjecttype("base").objects.length==0||game.getobjecttype("base").objects[0].ghost==true)continue;
                                
                                
                                const node = worker.objects[i].workobject;
                                const available = Math.max(0, (node.health ?? node.maxhealth ?? 0));
                                const take = Math.min(10, available);
                                if (node.health != null) node.health -= take;
                                if (node.health != null && node.health <= 0) markDepleted(node);
                                
                                
                                let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = worker.objects[i].x - b.x;
                                    let dy = worker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    worker.objects[i].targetX = closest.x+closest.dimx/2;
                                    worker.objects[i].targetY = closest.y+closest.dimy/2;
                                    worker.objects[i].targetObject=closest;
                                    worker.objects[i].returning = true; // ny flagga
                                    worker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (worker.objects[i].returning && worker.objects[i].deliveryTarget) {
                            
                            
                            if(worker.objects[i].workobject.name!="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 6;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 7;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =8;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 7;
                            }
                            if(worker.objects[i].workobject.name=="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 9;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 10;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =11;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                worker.objects[i].returning = false;
                               // worker.objects[i].deliveryTarget = null;
                                worker.objects[i].counter = 0;
                                worker.objects[i].animation = 0; // idle
                                
                                if(worker.objects[i].workobject.name!="tree")gold += 10;
                                if(worker.objects[i].workobject.name=="tree"){wood += 10;}
                                
                                // (Valfritt) √ñka guldm√§ngd h√§r
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
                    
                    for(let i=0;i<rworker.objects.length;i++){

                        rworker.objects[i].selectable=true;
			rworker.objects[i].counter2++;
                        
                        if ( rworker.objects[i].direction === "up")  rworker.objects[i].animation = 0;
                        else if ( rworker.objects[i].direction === "right")  {rworker.objects[i].animation = 1;rworker.objects[i].fliped=false;}
                        else if ( rworker.objects[i].direction === "down")  rworker.objects[i].animation = 2;
                        else if ( rworker.objects[i].direction === "left") { rworker.objects[i].animation = 1;rworker.objects[i].fliped=true;}
                        
                        
                        
                        if(rworker.objects[i].workobject!=null && rworker.objects[i].workobject.name=="rbase")continue;
                        if(rworker.objects[i].buildobject!=null)continue;
                        
                        
                        
                        if (rworker.objects[i].workobject && isDepleted(rworker.objects[i].workobject)&&rworker.objects[i].returning==false) {
  const cur = rworker.objects[i].workobject;
  const wasType = cur.name;
  cur.occupied = false;
  rworker.objects[i].workobject = null;
  rworker.objects[i].targetObject = null;
  rworker.objects[i].counter = 0;

  const pool = game.getAllObjectsoftype(game.getobjecttype(wasType))
    .filter(n => !n.occupied && !isDepleted(n));
  if (pool.length) {
    let best=null, bestD=Infinity;
    for (const n of pool) {
      const d = game.getDistance(rworker.objects[i].x, rworker.objects[i].y, n.x, n.y);
      if (d < bestD) { bestD = d; best = n; }
    }
    if (best) {
      best.occupied = (wasType === "tree");
      rworker.objects[i].workobject = best;
      rworker.objects[i].targetX = best.x + (best.dimx||0)/2;
      rworker.objects[i].targetY = best.y + (best.dimy||0)/2;
    }
  }
}
                       
                                

                        if(rworker.objects[i].workobject!=null&&rworker.objects[i].returning==false){
                            
                            if(rworker.objects[i].workobject.name=="goldmine"){
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y;+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                                
                                
                            }
                            else{
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;//+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                            }
                            
                        
                            
                            if(rworker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(rworker.objects[i],"tree");
                                
                                if(oo&&rworker.objects[i].workobject!=oo&&oo.ghost==false){rworker.objects[i].workobject.occupied=false;rworker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<1002) {
                                    if(rworker.objects[i].animation==0)rworker.objects[i].animation = 3;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 4;
                                    if(rworker.objects[i].animation==2)rworker.objects[i].animation = 5;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 4;
                                    rworker.objects[i].counter++;

                                }
                                if (rworker.objects[i].counter > 1000) {
                                    // Hitta n√§rmsta base
                                    if(game.getobjecttype("rbase").objects.length==0||game.getobjecttype("rbase").objects[0].ghost==true)continue;
                                    const node = rworker.objects[i].workobject;
                                    const available = Math.max(0, (node.health ?? node.maxhealth ?? 0));
                                    const take = Math.min(10, available);
                                    if (node.health != null) node.health -= take;
                                    if (node.health != null && node.health <= 0) markDepleted(node);
                                    
                                    
                                    
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = rworker.objects[i].x - b.x;
                                        let dy = rworker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                        rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                        rworker.objects[i].targetObject=closest;
                                        rworker.objects[i].returning = true; // ny flagga
                                        rworker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<202) {
                                    rworker.objects[i].animation=100;
                                    rworker.objects[i].counter++;

                                }
                                
                            if (rworker.objects[i].counter > 200) {
                                // Hitta n√§rmsta base
                                if(game.getobjecttype("rbase").objects.length==0||game.getobjecttype("rbase").objects[0].ghost==true)continue;
                                const node = rworker.objects[i].workobject;
                                    const available = Math.max(0, (node.health ?? node.maxhealth ?? 0));
                                    const take = Math.min(10, available);
                                    if (node.health != null) node.health -= take;
                                    if (node.health != null && node.health <= 0) markDepleted(node);
                                
                                
                                let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = rworker.objects[i].x - b.x;
                                    let dy = rworker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                    rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                    rworker.objects[i].targetObject=closest;
                                    rworker.objects[i].returning = true; // ny flagga
                                    rworker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (rworker.objects[i].returning && rworker.objects[i].deliveryTarget) {
                            
                            
                            if(rworker.objects[i].workobject.name!="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 6;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 7;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =8;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 7;
                            }
                            if(rworker.objects[i].workobject.name=="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 9;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 10;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =11;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                rworker.objects[i].returning = false;
                                //rworker.objects[i].deliveryTarget = null;
                                rworker.objects[i].counter = 0;
                                rworker.objects[i].animation = 0; // idle
                                
                                if(rworker.objects[i].workobject.name!="tree")rgold += 10;
                                if(rworker.objects[i].workobject.name=="tree"){rwood += 10;}
                                
                                // (Valfritt) √ñka guldm√§ngd h√§r
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
 
                    
                    enemyTryToBuildBase();
                    enemyTryToBuildBar();
                    enemyTryToBuildHouse();
                    updateRedWorkerAI();
                    updateRedTrainingAI();
                    //updateRedGuardAI();
                    updateOBBChaseTest();
                    
                    
                    handleCombat("guard", ["rguard", "rworker", "rbase", "rbar","rarcher","rhouse"], 0.4);
                    handleCombat("worker", ["rguard", "rworker", "rbase", "rbar","rarcher","rhouse"], 0.1);
                    handleCombat("rguard", ["guard", "worker", "base", "bar","archer","house"], 0.4);
                    handleCombat("rworker", ["guard", "worker", "base", "bar","archer","house"], 0.1);
                    updateArcherShooting("archer", ["rguard","rworker","rarcher","rbase","rbar","rhouse"]);
                    updateArcherShooting("rarcher", ["guard","worker","archer","base","bar","house"]);
                    updateArrows();
                    
                    checkWinLose(); 
                }

                 
                
                window.requestAnimationFrame(check);   
            };check();
            
            function isBuildPlacementValid(o) {
                if(!o)return true;
                if (o.collidestest()) return false;
                
                            // Avst√•ndsgr√§ns fr√•n resurser (t.ex. 100 pixlar)
                const minDistanceToResources = 300;
               // var resourceTypes = ["tree", "goldmine","rbase","base","bar","rbar","house","rhouse"]; // eller hur du identifierar resurser
               // if(o.name=="rbar")resourceTypes = ["tree", "goldmine","rbase"];
               var resourceTypes = ["tree", "goldmine","rbase","rbar","rhouse"];
                for (let type of resourceTypes) {
                    const resources = game.getAllObjectsoftype(game.getobjecttype(type));
                    for (let res of resources) {
                        if(o==res)continue;
                        
                        const dist = game.getDistance(o.x, o.y, res.x, res.y);
                        if (dist < minDistanceToResources) {
                            return false; // F√∂r n√§ra en resurs
                        }
                    }
                }
                
                
                
                return o.collideslistan.length === 0;
            }
            function cancelBuildMode() {
   
                
                if (ghostBuilding&&ghostBuilding.name=="base") {
                    gold+=500;wood+=500;
                    game.removeobject(game.getobjecttype("base"),ghostBuilding); // ‚¨ÖÔ∏è Viktigt!
                    ghostBuilding = null;
                }
                else if (ghostBuilding&&ghostBuilding.name=="bar") {
                    gold+=150;wood+=150;
                    game.removeobject(game.getobjecttype("bar"),ghostBuilding); // ‚¨ÖÔ∏è Viktigt!
                    ghostBuilding = null;
                }
                else if (ghostBuilding && ghostBuilding.name == "house") {
                    wood += 50;
                    game.removeobject(game.getobjecttype("house"), ghostBuilding);
                    ghostBuilding = null;
                }
                
                
                setBuildUIActive(false);
                buildMode = false;
                buildType = null;
                selectedWorkersBeforeBuild = [];
                isPlacingBuilding = false;
                console.log("Byggl√§ge avbrutet");
            }
            function assignWorkersToNearestTreesSmart() {
                    const allTrees = game.getAllObjectsoftype(game.getobjecttype("tree"))
                        .filter(t => !t.occupied&& t.animation==0); // inga distansfilter h√§r

                    const assignedTrees = new Set();

                    for (let w of selectedWorkers) {
                        if(w.workobject!=null)return;
                        
                        let bestTree = null;
                        let bestScore = Infinity;

                        for (let t of allTrees) {
                            if (assignedTrees.has(t)) continue;
                            const distToWorker = getManualDistance(t.x, t.y, w.x, w.y);
                      

                            if (distToWorker < bestScore) {
                                //alert(t.x+" "+ t.y+" "+ w.x+" "+ w.y);
                                
                                bestScore = distToWorker;
                                bestTree = t;
                            }
                        }
                        //alert("NY");
                        if (bestTree) {
                            
                            
                            
                            w.targetX = bestTree.x;// + bestTree.dimx / 2;
                            w.targetY = bestTree.y;// + bestTree.dimy / 2;
                            w.workobject = bestTree;
                            w.returning = false;
                            w.counter2 = 0;
                            bestTree.occupied = true;
                            assignedTrees.add(bestTree);
                        }
                    }
                }
            function getManualDistance(x1, y1, x2, y2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function enemyTryToBuildBar() {
                if(!game.getobjecttype("rworker").objects[0]||!game.getobjecttype("rbase").objects[0]||game.getobjecttype("rbase").objects[0].animation==0)return;
                
                const w = game.getobjecttype("rworker").objects[0];
                const rbaseType = game.getobjecttype("rbar");
                
                
                
                if (w.workobject && w.workobject.name=="rbar") {
                    
                    if (game.collideswithanoterobject(w,w.workobject)) {
                        
                        w.workobject.buildProgress += 1;
                        w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                        if(w.animation==0)w.animation = 3;
                        if(w.animation==1&&w.fliped==false)w.animation = 4;
                        if(w.animation==2)w.animation = 5;
                        if(w.animation==1&&w.fliped==true)w.animation = 4;      
                        
                        if (w.workobject.buildProgress > 1000) {
                            w.workobject.ghost = false;
                            w.workobject.selectable = true;
                            w.workobject.animation=1;
                            w.workobject = null;
                            w.buildobject=null;
                        }
                        
                        
                    }
                    
                }
                if (rwood < 150 || rgold < 150 ||(game.getobjecttype("rbar").objects[0])) return;
                
                const mines = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                if (mines.length === 0) return;
                const mine = mines[0]; // anv√§nd f√∂rsta gruvan
                const spacing = 100;
                let bestPos = null;
                let bestScore = Infinity;

                for (let dx = -5; dx <= 5; dx++) {
                    for (let dy = -5; dy <= 5; dy++) {
                        const px = mine.x + dx * spacing;
                        const py = mine.y + dy * spacing;

                        const temp = game.addobject(
                            rbaseType,
                            px,
                            py,
                            rbaseType.standarddimx,
                            rbaseType.standarddimy,
                            0,
                            false

                        );
                        temp.ghost = true;

                        if (isBuildPlacementValid(temp)) {
                            const distToMine = game.getDistance(px, py, mine.x, mine.y);

                            // Hitta n√§rmaste rworker
                            let closestWorkerDist = Infinity;
                         
                                const d = game.getDistance(px, py, w.x, w.y);
                                if (d < closestWorkerDist) closestWorkerDist = d;
                            

                            const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning h√§r

                            if (score < bestScore) {
                                bestScore = score;
                                bestPos = { x: px, y: py };
                            }
                        }

                        game.removeobject(rbaseType, temp);
                    }
                }

                if (bestPos) {
                    const ghost = game.addobject(
                        rbaseType,
                        bestPos.x,
                        bestPos.y,
                        rbaseType.standarddimx,
                        rbaseType.standarddimy,
                        0,
                        false
                    );
                    ghost.ghost = false;
                    ghost.canMove = false;
                    ghost.selectable = false;
                    ghost.enemyBuild = true;
                    ghost.buildProgress = 0;
                    ghost.health=1;
                    w.deliveryTarget=null;
                    w.targetObject=null;
                    w.targetX = bestPos.x;
                    w.targetY = bestPos.y;
                    w.workobject = ghost;
                    w.buildobject=ghost;
                    w.workobject.selectable = true;
                    w.counter2 = 0;
                    

                    rwood -= 150;
                    rgold -= 150;
                }
                
                
                
                
            }
            
            
            function enemyTryToBuildBase() {
                
                  const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
                for (let w of rworkers) {
            
                    if (w.workobject && w.workobject.name=="rbase") {
                        // B√∂rja bygga
                
                        if (game.collideswithanoterobject(w,w.workobject)) {
                            w.workobject.buildProgress += 1;
                            w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                            
                            
                            if(w.animation==0)w.animation = 3;
                                if(w.animation==1&&w.fliped==false)w.animation = 4;
                                if(w.animation==2)w.animation = 5;
                                if(w.animation==1&&w.fliped==true)w.animation = 4;
                            
                            if (w.workobject.buildProgress > 1000) {
                                  w.workobject.ghost = false;
                                  w.workobject.selectable = true;
                                  w.workobject.animation=1;
                                  w.workobject = null;

                            }  
                            
                        }
                        
                        
                        
                        
                        
                        
                        
                    }
                }
                
       if(game.getobjecttype("rbase").objects.length==1)return;         
       if (rwood < 500 || rgold < 500 ) return;
       
    const rbaseType = game.getobjecttype("rbase");

    // Finns redan en bas eller ghost-bygge?
    const baseExists = game.getAllObjects().some(o =>
        o.type === rbaseType && (!o.ghost || o.ghost === true)
    );
    if (baseExists) return;

    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));
    if (mines.length === 0) return;

    if (rworkers.length === 0) return;

    const mine = mines[1]; // anv√§nd f√∂rsta gruvan
    const spacing = 100;
    let bestPos = null;
    let bestScore = Infinity;

    for (let dx = -50; dx <= 50; dx++) {
        for (let dy = -50; dy <= 50; dy++) {
            const px = mine.x + dx * spacing;
            const py = mine.y + dy * spacing;

            const temp = game.addobject(
                rbaseType,
                px,
                py,
                rbaseType.standarddimx,
                rbaseType.standarddimy,
                0,
                false
                        
            );
            temp.ghost = true;

            if (isBuildPlacementValid(temp)) {
                const distToMine = game.getDistance(px, py, mine.x, mine.y);

                // Hitta n√§rmaste rworker
                let closestWorkerDist = Infinity;
                for (let w of rworkers) {
                    const d = game.getDistance(px, py, w.x, w.y);
                    if (d < closestWorkerDist) closestWorkerDist = d;
                }

                const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning h√§r

                if (score < bestScore) {
                    bestScore = score;
                    bestPos = { x: px, y: py };
                }
            }

            game.removeobject(rbaseType, temp);
        }
    }

    if (bestPos) {
        const ghost = game.addobject(
            rbaseType,
            bestPos.x,
            bestPos.y,
            rbaseType.standarddimx,
            rbaseType.standarddimy,
            0,
            false
        );
        ghost.ghost = false;
        ghost.canMove = false;
        ghost.selectable = false;
        ghost.enemyBuild = true;
        ghost.buildProgress = 0;
        ghost.health=1;
        ghost.selectable = true;

        for (let w of rworkers) {
            w.targetX = bestPos.x;
            w.targetY = bestPos.y;
            w.workobject = ghost;
            w.counter2 = 0;
            w.deliveryTarget=null;
            w.targetObject=null;
        }

        rwood -= 500;
        rgold -= 500;
    }
}
function updateRedWorkerAI() {
    const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
    const trees = game.getAllObjectsoftype(game.getobjecttype("tree")).filter(t => !t.occupied&&t.animation==0);
    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine")).filter(t => t.animation==0);

    let woodWorkers = 0;
    let goldWorkers = 0;

    // R√§kna redan tilldelade
    for (let w of rworkers) {
        if (w.workobject) {
            if (w.workobject.name === "tree") woodWorkers++;
            if (w.workobject.name === "goldmine") goldWorkers++;
        }
    }

    // Tilldela nya arbetare
    for (let w of rworkers) {
        if (w.workobject) continue; // hoppa om redan jobbar

        let targetList = null;
        let targetType = "";

        // F√∂rdela 3 av 5 till tr√§d
        if ((woodWorkers * 5) < (rworkers.length * 1.5) && trees.length > 0) {
            targetList = trees;
            targetType = "tree";
        } else if (mines.length > 0) {
            targetList = mines;
            targetType = "goldmine";
        }
        
           let nearbyTrees = trees.filter(t => 
            game.getDistance(w.x, w.y, t.x, t.y) < 1000 && t.animation==0
        );

      
        
        
        
        if (targetList) {
            let bestTarget = null;
            let bestDist = Infinity;

            for (let t of targetList) {
                const d = game.getDistance(w.x, w.y, t.x, t.y);
                if (d < bestDist && !t.occupied) {
                    bestDist = d;
                    bestTarget = t;
                }
            }

            if (bestTarget) {
                
                if(targetType=="tree"&&nearbyTrees.length > 0){
                    let tree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                    tree.occupied = true;
                    w.workobject = tree;
                    w.targetX = tree.x;
                    w.targetY = tree.y;
                    w.returning = false;
                    w.counter2 = 0;
                    
                }
                else{
                
                    w.targetX = bestTarget.x; //+ bestTarget.dimx / 2;
                    w.targetY = bestTarget.y; //+ bestTarget.dimy / 2;
                    w.workobject = bestTarget;
                    w.returning = false;
                    w.counter2 = 0;
                    if(bestTarget.name=="tree")bestTarget.occupied = true;
                }
                // Uppdatera r√§knare
                if (targetType === "tree") woodWorkers++;
                else if (targetType === "goldmine") goldWorkers++;
            }
        }
    }
}        
function updateRedTrainingAI() {
    
    
    if(game.getobjecttype("rworker").objects.length<=10){
    
        const rbases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
        for (let base of rbases) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen h√•ller p√• att bygga n√•got redan
            if (base.buildQueue.length > 0) break;

            // Exempel: tr√§na rguard om resurser finns
            const unitToTrain = "rworker"; // kan √§ven vara "rworker"
            const goldCost = 50;
            const woodCost = 0;

            if (rgold >= goldCost && rwood >= woodCost && canAddUnitToPopQueue("rworker")) {
                base.buildQueue.push(unitToTrain);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    }
    const rbar = game.getAllObjectsoftype(game.getobjecttype("rbar"));
    for (let base of rbar) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen h√•ller p√• att bygga n√•got redan
            if (base.buildQueue.length > 0) break;

            // Exempel: tr√§na rguard om resurser finns
             // Varva rguard/rarcher
            window._R_TRAIN_FLIP = !window._R_TRAIN_FLIP;
            var nextUnit = window._R_TRAIN_FLIP ? "rguard" : "rarcher";
            var goldCost = 75, woodCost = 0;
            if(nextUnit=="rarcher")woodCost=75;

            if (rgold >= goldCost && rwood >= woodCost && canAddUnitToPopQueue(nextUnit)) {
                base.buildQueue.push(nextUnit);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    
    
}
const BUILDING_NAMES = new Set(["base","bar","rbase","rbar","house","rhouse"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du anv√§nder f√∂r input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects();
  for (const o of objs) {
    if (!o.selectable) continue;
    if (o.name === "tree" || o.name === "goldmine") continue;

    // defaultv√§rden om h√§lsa saknas
    if (o.maxhealth == null){ o.maxhealth = BUILDING_NAMES.has(o.name) ? 800 : 100;o.health = o.maxhealth;}
    if (o.health == null) o.health = o.maxhealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxhealth));

    // V√§rld ‚Üí sk√§rm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // √∂ka svagt med zoom
    const offsetY = -10 * zoom; // ovanf√∂r objektet

    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // R√∂d full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Gr√∂n nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
    
    
    // --- Training queue icons (base/bar/rbase/rbar) ---
if ((o.name === "base" || o.name === "bar" || o.name === "rbase" || o.name === "rbar")
    && o.buildQueue && o.buildQueue.length > 0) {

  const pct   = Math.max(0, Math.min(1, (o.buildTimer || 0) / 1000)); // framsteg p√• f√∂rsta i k√∂n
  const ICON  = Math.max(40, Math.min(22, 18 * (zoom >= 1 ? zoom : 1))); // ikonstorlek
  const PAD   = Math.max(2, 2 * (zoom >= 1 ? zoom : 1));                 // mellanrum
  const q     = o.buildQueue;
  const total = q.length * ICON + (q.length - 1) * PAD;

  // placera ikonerna centrerat ovanf√∂r progress/HP-bar
  const y = sy + (offsetY - barH - 6) - ICON; // en rad ovanf√∂r progress/HP
  let   x = sx + (barW - total) / 2;

  // valfri: f√§rger per typ
  function colorFor(type) {
    if (type.includes("worker")) return "#efc84a";   // gul
    if (type.includes("archer")) return "#5ac8fa";   // bl√•
    if (type.includes("guard"))  return "#ef6c6c";   // r√∂d
    return "#9e9e9e";                                // default
  }


  for (let i = 0; i < q.length; i++) {
    const t = q[i];

    // bakgrund/ram
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(x, y, ICON, ICON);

    // fyllning (f√§rg) ‚Äì ers√§tt g√§rna med riktig ikonbild om du vill
    ctx.fillStyle = colorFor(t);
    ctx.fillRect(x + 1, y + 1, ICON - 2, ICON - 2);
    
    
    var typeObj = game.getobjecttype("worker");    // t.ex. "worker"
    if(o.name === "bar")typeObj = game.getobjecttype(t);  
    if(o.name === "rbase")typeObj = game.getobjecttype("rworker"); 
    if(o.name === "rbar")typeObj = game.getobjecttype(t); 
    
    const img = typeObj.images[0].getimage(); // vad du nu har
    if (img) {
        ctx.drawImage(img, x + 1, y + 1, ICON - 2, ICON - 2);
    }
    
    
    

    // progress-mask p√• F√ñRSTA ikonen
    if (i === 0) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(x + ICON * pct, y, ICON * (1 - pct), ICON);
    }
    else{
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(x, y, ICON, ICON);
        
    }


    // ram
    ctx.strokeStyle = "rgba(0,0,0,0.85)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 0.5, y + 0.5, ICON - 1, ICON - 1);
    ctx.restore();

    x += ICON + PAD;
  }
    
    
    
  }
  
        }
  
  
  
}
function handleCombat(attackerType, enemyTypes, damage) {
    const attackers = game.getobjecttype(attackerType).objects;
    for (const unit of attackers) {
        // Kolla alla fiendetyper
        for (const enemyType of enemyTypes) {
            const target = game.collideswith(unit, enemyType, "any");
            if (target) {
                // Om m√•let inte har health, s√§tt standardv√§rde
                target.health -= damage;
                spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" }); // r√∂d
                spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);
                
                if(unit.name=="worker"||unit.name=="rworker"){
                
                    if(unit.animation==0)unit.animation = 3;
                    if(unit.animation==1&&unit.fliped==false)unit.animation = 4;
                    if(unit.animation==2)unit.animation = 5;
                    if(unit.animation==1&&unit.fliped==true)unit.animation = 4;
                }

                if (target.health <= 0) {
                    // Ta bort objektet om health tar slut
                    game.removeobject(game.getobjecttype(enemyType), target);
                }
            }
        }
    }
}
// --- helpers f√∂r AI ---
// Vilka r√§knas som fasta hinder

function showEndScreen(result, statsText="") {
  const box = document.getElementById("end-screen");
  const title = document.getElementById("end-title");
  const sub = document.getElementById("end-sub");
  sub.style.whiteSpace = "pre-line";
  sub.textContent = statsText;

  if (result === "win") {
    title.textContent = "Du vann! üéâ";
    sub.textContent = statsText || "Fienden √§r besegrad.";
  } else {
    title.textContent = "Du f√∂rlorade üíÄ";
    sub.textContent = statsText || "B√§ttre lycka n√§sta g√•ng.";
  }
  box.style.display = "flex";
}


function checkWinLose() {
  if (gameOver) return;

  // H√§mta typer (s√§krar mot null)
  const _g  = game.getobjecttype("guard")    || {objects:[]};
  const _w  = game.getobjecttype("worker")   || {objects:[]};
  const _b  = game.getobjecttype("base")     || {objects:[]};
  const _ba = game.getobjecttype("bar")      || {objects:[]};

  const _rg = game.getobjecttype("rguard")   || {objects:[]};
  const _rw = game.getobjecttype("rworker")  || {objects:[]};
  const _rb = game.getobjecttype("rbase")    || {objects:[]};
  const _rba= game.getobjecttype("rbar")     || {objects:[]};

  // R√§kna endast ‚Äúf√§rdiga‚Äù byggnader (animation==1 i din kod betyder klar)
  const playerBasesAlive   = _b.objects.filter(o => !o.ghost && o.animation===1).length;
  const playerBarrsAlive   = _ba.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBasesAlive    = _rb.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBarrsAlive    = _rba.objects.filter(o => !o.ghost && o.animation===1).length;

  const playerUnitsAlive   = _g.objects.length + _w.objects.length;
  const enemyUnitsAlive    = _rg.objects.length + _rw.objects.length;

// VINST
if (enemyBasesAlive===0 && enemyBarrsAlive===0 && enemyUnitsAlive===0) {
  gameOver = true;
  
  let elapsedMs = Date.now() - gameStartTime;
  let seconds = Math.floor(elapsedMs / 1000);
  let minutes = Math.floor(seconds / 60);
  seconds = seconds % 60;
  
  
  
  //showEndScreen(
  //  "win",
  //  `Du vann p√• ${minutes} minuter och ${seconds} sekunder.`
  //);
  playerWon(Math.floor(elapsedMs / 1000));
  
  
  return;
}

// F√ñRLUST
if (playerBasesAlive===0 && playerBarrsAlive===0 && playerUnitsAlive===0) {
  gameOver = true;
  
  let elapsedMs = Date.now() - gameStartTime;
  let seconds = Math.floor(elapsedMs / 1000);
  let minutes = Math.floor(seconds / 60);
  seconds = seconds % 60;
  showEndScreen(
    "lose",
    `Fienden vann p√• ${minutes} minuter och ${seconds} sekunder.`
  );
  return;
}
}

function updateArcherShooting(archerTypeName, enemyTypeNames) {
    function segmentAABB(x0,y0,x1,y1, rx1,ry1,rx2,ry2){
        const dx=x1-x0, dy=y1-y0; let t0=0,t1=1;
        const p=[-dx,dx,-dy,dy], q=[x0-rx1,rx2-x0,y0-ry1,ry2-y0];
        for(let i=0;i<4;i++){
          if (p[i]===0){ if (q[i]<0) return false; }
          else{
            const r=q[i]/p[i];
            if (p[i]<0){ if (r>t1) return false; if (r>t0) t0=r; }
            else       { if (r<t0) return false; if (r<t1) t1=r; }
          }
        }
        return true;
    }    
    function losBlockedFast(A, B, exclude = null, inflate = 4){
      const STATIC_SOLIDS = ["tree","goldmine","base","bar","house","rbase","rbar","rhouse"];
      for (const tn of STATIC_SOLIDS) {
        const t = game.getobjecttype(tn); if (!t) continue;
        for (const o of t.objects) {
          if (o.ghost) continue;
          if (o === exclude) continue; // <-- ignorera m√•let
          const rx1 = o.x - inflate, ry1 = o.y - inflate;
          const rx2 = o.x + o.dimx + inflate, ry2 = o.y + o.dimy + inflate;
          if (segmentAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
        }
      }
      return false;
    }  
    
    
  const archers = game.getobjecttype(archerTypeName)?.objects || [];
  for (const a of archers) {
    a.attackRange    = a.attackRange ?? 450;  // px
    a.attackCooldown = a.attackCooldown ?? 900; // ms
    a.lastShotTime   = a.lastShotTime ?? 0;

    // Hitta n√§rmaste fiende inom range & line-of-sight
    let best=null, bd=Infinity;
    for (const et of enemyTypeNames) {
      const list = game.getobjecttype(et)?.objects || [];
      for (const e of list) {
        const dx=(a.x + a.dimx/2) - (e.x + e.dimx/2);
        const dy=(a.y + a.dimy/2) - (e.y + e.dimy/2);
        const d=Math.hypot(dx,dy);
        if (d < a.attackRange && d < bd) {
          // valfritt LOS: undvik att skjuta igenom v√§ggar/byggnader
          const A = {x:a.x+a.dimx/2, y:a.y+a.dimy/2}, B = {x:e.x+e.dimx/2, y:e.y+e.dimy/2};
          if (!losBlockedFast(A, B, e, 6)) { // du har redan losBlockedFast() definierad
            bd=d; best=e;
          }
        }
      }
    }

    if (!best) continue;

    // cooldown?
    const now = performance.now();
    if (now - a.lastShotTime < a.attackCooldown) continue;
    a.lastShotTime = now;

    // Skapa pil
    const arrowType = game.getobjecttype("arrow");
    const sx = a.x + a.dimx/2, sy = a.y + a.dimy/2;
    const obj = game.addobject(
      arrowType,
      sx, sy,
      arrowType.standarddimx, arrowType.standarddimy,
      0, false // rot s√§tts nedan
    );
    obj.speed  = 9;         // px/frame
    obj.damage = 5;         // skada vid tr√§ff
    obj.ttl    = 120;       // lever max ~2 sek @60fps
    obj.target = best;
    markArcherJustShot(a);

    // init riktning/rotation (bilden pekar √•t h√∂ger)
    const dx=(best.x+best.dimx/2)-sx, dy=(best.y+best.dimy/2)-sy;
    const ang = Math.atan2(dy, dx);      // radianer
    obj.vx = Math.cos(ang) * obj.speed;
    obj.vy = Math.sin(ang) * obj.speed;
    obj.rot = (ang * 180 / Math.PI);                        // m√•nga engines anv√§nder .rot            
  }
}

function updateArrows(){
  const arrowType = game.getobjecttype("arrow");
  if (!arrowType) return;
  const arr = [...arrowType.objects]; // kopia om vi tar bort under iteration

  function hitTest(a, t){
    // enkel AABB
    return a.x < t.x + t.dimx && a.x + a.dimx > t.x &&
           a.y < t.y + t.dimy && a.y + a.dimy > t.y;
  }

  for (const p of arr) {
    // livstid
    if ((p.ttl = (p.ttl ?? 120) - 1) <= 0) { game.removeobject(arrowType, p); continue; }
    // m√•l d√∂tt?
    if (!p.target || !game.getAllObjects().includes(p.target)) { game.removeobject(arrowType, p); continue; }

    // styr lite mot r√∂rligt m√•l (svag homing g√∂r det sn√§llare)
    const tx = p.target.x + p.target.dimx/2;
    const ty = p.target.y + p.target.dimy/2;
    const dx = tx - (p.x + p.dimx/2);
    const dy = ty - (p.y + p.dimy/2);
    const ang = Math.atan2(dy, dx);
    const spd = p.speed ?? 9;

    p.vx = Math.cos(ang) * spd;
    p.vy = Math.sin(ang) * spd;

    // flytta
    p.x += p.vx;
    p.y += p.vy;

    // rotera sprite till flygriktning (din pil pekar h√∂ger)
    p.rot =(ang * 180 / Math.PI);

    // tr√§ff?
    if (hitTest(p, p.target)) {
      const tgt = p.target;
      if (tgt.maxhealth == null){ // samma default som √∂vriga
        tgt.maxhealth = (new Set(["base","bar","rbase","rbar"]).has(tgt.name)) ? 800 : 100;
        tgt.health = tgt.maxhealth;
      }
      tgt.health -= (p.damage ?? 5);

      // effekter
      spawnDamageNumber(-(p.damage ?? 5), tgt.x, tgt.y, { color: "#ffd166" });
      spawnHitParticles(tx, ty, 6);

      // d√∂?
      if (tgt.health <= 0) {
        game.removeobject(game.getobjecttype(tgt.name), tgt);
      }
      // ta bort pilen
      game.removeobject(arrowType, p);
    }
  }
}
function enemyTryToBuildHouse() {
  const rWorkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
  const rbaseObj = game.getobjecttype("rbase");
  if (!rWorkers.length || !rbaseObj.objects.length || rbaseObj.objects[0].animation==0) return;


     for(let w of rWorkers){
                    if (w.buildobject&&game.collideswithanoterobject(w,w.workobject)) {
                        
                        w.workobject.buildProgress += 1;
                        w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                        if(w.animation==0)w.animation = 3;
                        if(w.animation==1&&w.fliped==false)w.animation = 4;
                        if(w.animation==2)w.animation = 5;
                        if(w.animation==1&&w.fliped==true)w.animation = 4;      
                        
                        if (w.workobject.buildProgress > 1000) {
                            w.workobject.ghost = false;
                            w.workobject.selectable = true;
                            w.workobject.animation=1;
                            w.workobject = null;
                            w.buildobject=null;
                        }
                        
                        
                    }
                    


                }






  // bygg bara ett (√§ndra om du vill fler)
  
  if(rpopUsed >= rpopCap && game.getobjecttype("rhouse").objects[game.getobjecttype("rhouse").objects.length-1]&&game.getobjecttype("rhouse").objects[game.getobjecttype("rhouse").objects.length-1].animation==1){}
  else if (game.getobjecttype("rhouse").objects.length > 0) return;

               





  const goldCost = 0, woodCost = 50;
  if (rgold < goldCost || rwood < woodCost) return;

  const tHouse = game.getobjecttype("rhouse");
  const anchor = rbaseObj.objects[0];
  const spacing = 120;
  let bestPos = null, bestScore = Infinity;

  for (let dx = -5; dx <= 5; dx++) {
    for (let dy = -5; dy <= 5; dy++) {
      const px = anchor.x + dx*spacing;
      const py = anchor.y + dy*spacing;

      const tmp = game.addobject(tHouse, px, py, tHouse.standarddimx||150, tHouse.standarddimy||150, 0, false);
      tmp.ghost = true;

      if (isBuildPlacementValid(tmp)) {
        // n√§rhet till rbase + n√§rhet till n√•n rworker
        let nearestW = Infinity;
        for (const w of rWorkers) {
          const d = game.getDistance(px, py, w.x, w.y);
          if (d < nearestW) nearestW = d;
        }
        const dBase = game.getDistance(px, py, anchor.x, anchor.y);
        const score = dBase*1 + nearestW*0.5;
        if (score < bestScore) { bestScore = score; bestPos = {x:px, y:py}; }
      }
      game.removeobject(tHouse, tmp);
    }
  }

  if (!bestPos) return;

  // Spawn ghost-bygget och l√•t en worker konstruera (som din rbar)
  const ghost = game.addobject(tHouse, bestPos.x, bestPos.y, tHouse.standarddimx||150, tHouse.standarddimy||150, 0, false);
  ghost.ghost = false; ghost.canMove = false; ghost.selectable = true; ghost.enemyBuild = true;
  ghost.buildProgress = 0; ghost.health = 1; ghost.animation = 0;

  // Skicka n√§rmaste rworker
  let chosen = rWorkers[0], bestD = Infinity;
  for (const w of rWorkers) {
    const d = game.getDistance(w.x, w.y, bestPos.x, bestPos.y);
    if (d < bestD) { bestD = d; chosen = w; }
  }
  chosen.targetX = bestPos.x+tHouse.standarddimx/2; chosen.targetY = bestPos.y+tHouse.standarddimy/2;
  chosen.workobject = ghost; chosen.buildobject = ghost; chosen.counter2 = 0;
  chosen.deliveryTarget=null;
  chosen.targetObject=null;

  rgold -= goldCost; rwood -= woodCost;
}
function recalcPopulation() {
  // byggnader f√§rdiga = animation==1
  const countFinished = (name) => {
    const t = game.getobjecttype(name);
    if (!t) return 0;
    let n = 0;
    for (const o of (t.objects || [])) if (o.animation === 1) n++;
    return n;
  };

  popCap  = countFinished("base")  * 10 + countFinished("house")  * 5;
  rpopCap = countFinished("rbase") * 10 + countFinished("rhouse") * 5;

  const cnt = (name) => (game.getobjecttype(name)?.objects?.length || 0);

  // r√§kna ENDAST trupper ‚Äì byggnader ger inte popUsed
  popUsed  = cnt("worker") + cnt("guard") + cnt("archer");
  rpopUsed = cnt("rworker") + cnt("rguard") + cnt("rarcher");
}

function canAddUnitToPopQueue(typeName) {
  const cost = POP_COST[typeName] || 0;
  const isRed = typeName.startsWith("r");
  return isRed ? (rpopUsed + cost <= rpopCap) : (popUsed + cost <= popCap);
}

// typkoll
function isArcherUnit(u){
  const n = u?.name || u?.type?.name || "";
  return n === "archer" || n === "rarcher";
}

// s√§nk HP s√§kert oavsett vilka f√§lt du anv√§nder
function clampArcherHP(u){
  u.health=50;
  u.maxhealth=50; 
}

// s√§tt basfart en g√•ng och applicera slow n√§r aktivt
function applyArcherSpeed(u){
  const slow = (u._slowUntilMs != null) && (nowMs() < u._slowUntilMs);
  u.speed =(slow ? ARCHER_SLOW_MULT : 1.25);
}

// kalla denna precis n√§r en pil skjuts
function markArcherJustShot(u){
  if (!isArcherUnit(u)) return;
  u._slowUntilMs = nowMs() + ARCHER_SLOW_MS;
}
// === Resource helpers ===
function markDepleted(node){
  if (!node) return;
  node.animation = 1;       // visa "utt√∂md" sprite
  node.occupied = false;    // sl√§pp platsen
  if (node.name === "tree"){node.selectable=false; node.ghost = true;} // tr√§d f√∂rsvinner som hinder
}

function isDepleted(node){
  return !node ? true :
    node.animation === 1 || (node.health != null && node.health <= 0);
}
// ================= OBB Pathfinder (A* p√• grid, 8-riktningar, no corner cutting) =================
// API:
//   const path = findPathOBB(start, goal, obbs, { cell:24, inflate:16, pad:240, maxGrid:512, smooth:true });
//
//  - start/goal: {x,y}
//  - obbs: array av { cx, cy, w, h, angleRad }  (roterad rektangel)
//  - options:
//      cell    : griduppl√∂sning (px per cell)
//      inflate : clearance i pixlar (hur mycket vi "tjockar p√•" hinder)
//      pad     : extra marginal runt start/m√•l och hinder vid rasterisering
//      maxGrid : max celler per led (skydd mot j√§ttestora raster)
//      smooth  : LOS-smoothing √∂ver OBBs
//
// Returnerar: array av {x,y} (v√§rldspunkter) eller null om ingen v√§g.
// === Hj√§lpare ===
function _list(type){ const t=game.getobjecttype(type); return t?.objects ? t.objects.filter(o=>!o.ghost) : []; }
function _dims(o){ return { w: (o.dimx ?? o.type?.standarddimx ?? 32), h: (o.dimy ?? o.type?.standarddimy ?? 32) }; }
function _C(o){ const {w,h}=_dims(o); return { x:(o.x??0)+w/2, y:(o.y??0)+h/2 }; }
function _D(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

// Bygg OBBs fr√•n dina ‚Äúsolida‚Äù objekt (tree, water, byggnader)
function collectOBBsFromGame(types, extraInflatePx = 0) {
  const out = [];
  for (const tn of types) {
    const t = game.getobjecttype(tn);
    if (!t || !t.objects) continue;
    for (const o of t.objects) {
      if (o.ghost) continue;
      const w = o.dimx ?? o.type?.standarddimx ?? 32;
      const h = o.dimy ?? o.type?.standarddimy ?? 32;
      const cx = (o.x ?? 0) + w/2;
      const cy = (o.y ?? 0) + h/2;
      // rotation: st√∂d "rot" i grader eller "rotation" i radianer
      let angleRad = 0;
      if (typeof o.rot === "number") angleRad = (Math.PI/180) * o.rot;
      else if (typeof o.rotation === "number") angleRad = o.rotation;
      out.push({ cx, cy, w: w + 2*extraInflatePx, h: h + 2*extraInflatePx, angleRad });
    }
  }
  return out;
}

/**
 * TEST: L√•t alla rguard/rarcher jaga n√§rmaste guard/archer/worker via OBB-pathfinding.
 * K√∂r denna i din main-loop varje frame (ist√§llet f√∂r din vanliga AI) f√∂r att testa.
 */
function updateOBBChaseTest(){
  // ====== Tunables ======
  const DEFEND_MS = 8000;             // hur l√§nge f√∂rsvarsl√§ge √§r aktivt efter skada
  const DEFENSE_MAX_THREATS = 6;      // hur m√•nga hot (gubbar) att fokusera p√•
  const RALLY_RECALC_CHANCE = 0.5;    // % per sekund att revalidera rally (ungef√§r)

  // Pathing
  const CELL=24, INFLATE=14, PAD=240, MAXGRID=512, NEAR_WP=12, REPLAN_FR=24;

  // ====== Hj√§lpare & setup ======
  function isAlive(o){ return !!o && !o.ghost && game.getAllObjects().includes(o); }
  function _center(o){ return _C ? _C(o) : { x:o.x + o.dimx/2, y:o.y + o.dimy/2 }; }
  function _dist(a,b){ return _D ? _D(a,b) : Math.hypot(a.x-b.x, a.y-b.y); }
  function getHP(o){ return (o.health ?? o.hp ?? o.HP ?? 0)|0; }

  const OBB_SOLID_TYPES = ["tree","water","base","bar","house","rbase","rbar","rhouse"];
  const obbs = collectOBBsFromGame(OBB_SOLID_TYPES, 0);

  // AI (r*) trupp & bygg
  const fighters = [..._list("rguard"), ..._list("rarcher")].filter(isAlive);
  const rWorkers  = (_list("rworker")||[]).filter(isAlive);
  const rBuilds   = [
    ...(game.getobjecttype("rbase")?.objects||[]),
    ...(game.getobjecttype("rbar")?.objects||[]),
    ...(game.getobjecttype("rhouse")?.objects||[])
  ].filter(isAlive);

  // Spelarens enheter/byggnader
  const pUnits = [..._list("guard"), ..._list("archer"), ..._list("worker")].filter(isAlive);
  const pBuilds = [
    ...(game.getobjecttype("base")?.objects||[]),
    ...(game.getobjecttype("bar")?.objects||[]),
    ...(game.getobjecttype("house")?.objects||[])
  ].filter(isAlive);

  const enemyBase = (game.getobjecttype("rbase")?.objects||[]).find(isAlive) || rBuilds.find(b => b.typeName==="rbase");

  // Squad-state
  if (!window._R_SQUAD) window._R_SQUAD = {
    state:"gather",            // "gather" | "attack"
    rally:null,
    originals:[],
    attackTarget:null,
    defendUntil:0,
    hpWatch:new Map()          // Map<object, lastHP>
  };
  const S = window._R_SQUAD;

  function groupCenter(arr){
    if (!arr.length) return null;
    let sx=0, sy=0; for (const o of arr){ const c=_center(o); sx+=c.x; sy+=c.y; }
    return { x:sx/arr.length, y:sy/arr.length };
  }

  function playerFocus(){
    if (pBuilds.length) return _center(pBuilds[0]);
    const pu = pUnits.length ? groupCenter(pUnits) : null;
    return pu || (enemyBase ? { x:_center(enemyBase).x+300, y:_center(enemyBase).y } : {x:0,y:0});
  }

  function computeRallyToward(baseObj){
    if (!baseObj) return null;
    const baseC = _center(baseObj);
    const pf = playerFocus(); if (!pf) return null;
    let dx = pf.x - baseC.x, dy = pf.y - baseC.y;
    const len = Math.hypot(dx,dy) || 1; dx/=len; dy/=len;

    const anyType = game.getobjecttype("rhouse") || game.getobjecttype("rbar") || game.getobjecttype("rbase");
    const W = (anyType?.standarddimx)||80, H=(anyType?.standarddimy)||80;

    for (let dist=70; dist<=900; dist+=40){
      const cx = baseC.x + dx*dist, cy = baseC.y + dy*dist;
      const tmp = game.addobject(anyType, cx - W/2, cy - H/2, W, H, 0, false);
      tmp.ghost = true; tmp.selectable=false;
      const ok = isBuildPlacementValid(tmp);
      game.removeobject(anyType, tmp);
      if (ok) return { x:cx, y:cy };
    }
    return { x:baseC.x + dx*140, y:baseC.y + dy*140 };
  }

// === Tunables f√∂r adaptiv backoff ===
const BLOCKED_BACKOFF_INC   = 110;   // √∂ka repath-intervall n√§r blockerat
const BLOCKED_BACKOFF_DEC   = 100;  // s√§nk tillbaka vid framsteg
const BLOCKED_BACKOFF_MAX   = 110;   // max x g√•nger l√•ngsammare repath
const COLLISION_BACKOFF_BONUS = 100;// mild backoff om bara kollision
const PROGRESS_CHECK_FR     = 100;    // hur ofta vi kollar framsteg (frames)
const PROGRESS_EPS          = 250;  // "moved" tr√∂skel i px mellan kontroller

function steerToGoal(u, goal){
  if (!u || !goal) return;
  if (!u._obbAI) u._obbAI = {
    path:null, pi:0, repath:0, lastKey:null,
    backoff:100, lastPX:0, lastPY:0, progT:PROGRESS_CHECK_FR
  };

  const U = _center(u);

  // Init "senast-pos" f√∂rsta g√•ngen
  if (u._obbAI.lastPX === 0 && u._obbAI.lastPY === 0) {
    u._obbAI.lastPX = U.x; u._obbAI.lastPY = U.y;
  }

  // M√•l-nyckel (√§ndrats?)
  const key = ((goal.x|0)<<16) ^ (goal.y|0);
  if (u._obbAI.lastKey !== key){
    u._obbAI.lastKey = key;
    u._obbAI.path    = null;
    u._obbAI.repath  = 0;
  }



 if(!u.blocked){

    // === (Re)planering med backoff ===
    if (!u._obbAI.path || u._obbAI.repath <= 0){
      const path = findPathOBB(U, goal, obbs, { cell:CELL, inflate:INFLATE, pad:PAD, maxGrid:MAXGRID, smooth:true });
      const jitter = (Math.random()*6)|0;
      if (path && path.length){
        u._obbAI.path   = path;
        u._obbAI.pi     = (path.length>1)?1:0;
        // l√§ngre intervall n√§r backoff √§r h√∂g ‚Üí l√•ngsammare re-path
        u._obbAI.repath = Math.round(REPLAN_FR * u._obbAI.backoff) + jitter;
      } else {
        u._obbAI.path   = null;
        u._obbAI.pi     = 0;
        // √§ven "fail"-v√§ntan respekterar backoff
        u._obbAI.repath = Math.round(8 * u._obbAI.backoff);
      }
    } else {
      u._obbAI.repath--; // vi fryser inte timern ‚Äì den r√§knar alltid ner
    }
 }
  // === F√∂lj path/goal (of√∂r√§ndrat) ===
  let g = goal;
  if (u._obbAI.path && u._obbAI.pi < u._obbAI.path.length){
    const wp = u._obbAI.path[u._obbAI.pi];
    if (_D(U, wp) < NEAR_WP) u._obbAI.pi++;
    g = (u._obbAI.pi < u._obbAI.path.length) ? u._obbAI.path[u._obbAI.pi] : goal;
  }

  const {w,h} = _dims(u);
  u.targetX = g.x - w/2;
  u.targetY = g.y - h/2;

  const dx = g.x - U.x, dy = g.y - U.y;
  u.direction = Math.abs(dx)>Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up");


}

  // ====== F√∂rsvar: bevaka skada p√• r-enheter/byggnader ======
  (function watchDamage(){
    const now = Date.now();
    const allies = [...fighters, ...rWorkers, ...rBuilds];
    for (const a of allies){
      const hp = getHP(a);
      const prev = S.hpWatch.get(a);
      if (prev === undefined){
        S.hpWatch.set(a, hp);
      } else {
        if (hp < prev){                    // skada uppt√§ckt
          S.defendUntil = Math.max(S.defendUntil, now + DEFEND_MS);
        }
        S.hpWatch.set(a, hp);
      }
    }
    // rensa bort d√∂da fr√•n watch
    for (const [obj] of S.hpWatch){
      if (!isAlive(obj)) S.hpWatch.delete(obj);
    }
  })();

  // ====== Auto-reset till gather om attackgruppen dog ======
  if (S.state === "attack"){
    S.originals = (S.originals||[]).filter(isAlive);
    if (S.originals.length === 0){
      S.state = "gather"; S.rally = null; S.attackTarget = null;
      S.defendUntil=Date.now();
    }
  }

  // ====== Uppdatera/validera rally under gather ======
  if (S.state === "gather"){
    const recalcChancePerTick = (RALLY_RECALC_CHANCE/60); // antag ~60fps
    if (!S.rally || !enemyBase || Math.random() < recalcChancePerTick){
      S.rally = computeRallyToward(enemyBase);
    }
  }

  // ====== Hj√§lpare f√∂r m√•lval (prioritera gubbar) ======
  function nearestPlayerUnitsFromBase(limit=1){
    if (!enemyBase || !pUnits.length) return [];
    const B = _center(enemyBase);
    const arr = [...pUnits].sort((a,b)=>_dist(B,_center(a)) - _dist(B,_center(b)));
    return arr.slice(0, Math.max(1, limit));
  }
  function chooseAttackTargetPreferUnits(){
    // 1) n√§rmsta spelargubbe fr√•n AI-basen
    const nu = nearestPlayerUnitsFromBase(1);
    if (nu.length) return nu[0];
    // 2) annars en spelbyggnad (t.ex. base)
    if (pBuilds.length) return pBuilds[0];
    // 3) fallback: centeroid av spelaren
    const pf = playerFocus(); return pf ? { x:pf.x, y:pf.y, _isPoint:true } : null;
  }

  // ====== F√∂rsvarsl√§ge (override) ======
  const now = Date.now();
  if (S.defendUntil > now){
    // Fokusera p√• n√§rmsta fiende-gubbar fr√•n rbasen
    const threats = nearestPlayerUnitsFromBase(DEFENSE_MAX_THREATS);
    let goals = [];
    if (threats.length){
      // sprid m√•len s√• inte alla klumpar p√• samma
      for (let i=0;i<fighters.length;i++){
        const t = threats[i % threats.length];
        goals.push(_center(t));
      }
    } else {
      // Inga gubbar ‚Üí h√•ll runt basen
      goals = fighters.map(()=> enemyBase ? _center(enemyBase) : (S.rally || playerFocus() || {x:0,y:0}));
    }
    for (let i=0;i<fighters.length;i++){
      steerToGoal(fighters[i], goals[i]);
    }
    return; // hoppa √∂ver normal gather/attack n√§r f√∂rsvar √§r aktivt
  }

  // ====== Normal state machine ======
  if (S.state === "gather"){
    for (const u of fighters) if (S.rally) steerToGoal(u, S.rally);
    const ready = S.rally ? fighters.filter(u => _dist(_center(u), S.rally) < 150) : [];
    if (ready.length >= 5){
      ready.sort((a,b)=>_dist(_center(a),S.rally)-_dist(_center(b),S.rally));
      S.originals = ready.slice(0,5);
      S.attackTarget = chooseAttackTargetPreferUnits();
      S.state = "attack";
    }
  } else if (S.state === "attack"){
    if (!isAlive(S.attackTarget) || S.attackTarget._isPoint){
      S.attackTarget = chooseAttackTargetPreferUnits();
    } else {
      // om attacktarget √§r byggnad och det finns gubbar ‚Üí byt
      if (pUnits.length){
        const bestUnit = chooseAttackTargetPreferUnits();
        if (bestUnit && bestUnit !== S.attackTarget) S.attackTarget = bestUnit;
      }
    }
    const goalC = S.attackTarget ? (_center(S.attackTarget) || S.attackTarget) : playerFocus();
    for (const u of fighters) steerToGoal(u, goalC);
  }

  // S√§kerhetsfallback: om inga motst√•ndare alls ‚Äì st√• still
  if (!pUnits.length && !pBuilds.length){
    for (const u of fighters){ u.targetX=u.x; u.targetY=u.y; }
  }
}
//slut AI-----------------------------------------------------------------------------------------
function findPathOBB(start, goal, obbs, opt = {}) {
  const cell    = opt.cell ?? 24;
  const inflate = opt.inflate ?? 16;
  const pad     = opt.pad ?? 240;
  const maxGrid = opt.maxGrid ?? 512;
  const smooth  = opt.smooth ?? true;

  // 1) Bounds f√∂r raster
  let minx = Math.min(start.x, goal.x) - pad;
  let miny = Math.min(start.y, goal.y) - pad;
  let maxx = Math.max(start.x, goal.x) + pad;
  let maxy = Math.max(start.y, goal.y) + pad;

  const prepped = obbs.map(prepOBB);
  for (const O of prepped) {
    const b = O.bounds;
    minx = Math.min(minx, b.x1 - pad);
    miny = Math.min(miny, b.y1 - pad);
    maxx = Math.max(maxx, b.x2 + pad);
    maxy = Math.max(maxy, b.y2 + pad);
  }

  // Klipp rasterstorlek
  ({minx, miny, maxx, maxy} = clampBoundsToGrid(minx, miny, maxx, maxy, cell, maxGrid));

  // 2) Bygg grid & rasterisera OBBs
  const grid = buildGridOBB(minx, miny, maxx, maxy, cell, prepped, inflate);

  // 3) Snap start/goal till g√•ngbar cell
  let Sg = worldToGrid(grid, start);
  let Gg = worldToGrid(grid, goal);
  Sg = snapToWalkable(grid, Sg, 12);
  Gg = snapToWalkable(grid, Gg, 12);

  // 4) A*
  const raw = astar(grid, Sg, Gg);
  if (!raw) return null;

  // 5) Smoothing via OBB-LOS
  const cells = smooth ? smoothPath(grid, raw, prepped) : raw;

  // 6) Till v√§rldspunkter
  return cells.map(c => gridToWorld(grid, c.gx, c.gy));
}

// ---------------- Grid & rasterisering ----------------

function buildGridOBB(minx, miny, maxx, maxy, cell, OBBs, inflatePx) {
  const w = Math.max(1, Math.ceil((maxx - minx) / cell));
  const h = Math.max(1, Math.ceil((maxy - miny) / cell));
  const walk = new Uint8Array(w*h); walk.fill(1);

  for (const O of OBBs) {
    const b = O.bounds;
    const gx1 = Math.max(0, Math.floor((b.x1 - minx) / cell));
    const gy1 = Math.max(0, Math.floor((b.y1 - miny) / cell));
    const gx2 = Math.min(w-1, Math.floor((b.x2 - minx) / cell));
    const gy2 = Math.min(h-1, Math.floor((b.y2 - miny) / cell));
    for (let gy=gy1; gy<=gy2; gy++) {
      const cy = miny + gy*cell + cell/2;
      for (let gx=gx1; gx<=gx2; gx++) {
        const cx = minx + gx*cell + cell/2;
        if (pointInOBB(cx, cy, O)) walk[gy*w + gx] = 0;
      }
    }
  }

  // Clearance (inflate ‚Üí celler)
  const padCells = Math.max(0, Math.ceil(inflatePx / cell));
  if (padCells > 0) dilate(walk, w, h, padCells);

  return { w, h, minx, miny, cell, walk };
}

function worldToGrid(grid, p) {
  let gx = Math.floor((p.x - grid.minx) / grid.cell);
  let gy = Math.floor((p.y - grid.miny) / grid.cell);
  gx = Math.max(0, Math.min(grid.w-1, gx));
  gy = Math.max(0, Math.min(grid.h-1, gy));
  return { gx, gy };
}
function gridToWorld(grid, gx, gy) {
  return {
    x: grid.minx + gx*grid.cell + grid.cell/2,
    y: grid.miny + gy*grid.cell + grid.cell/2
  };
}

function snapToWalkable(grid, cell, maxR) {
  const {w,h,walk} = grid;
  const start = cell.gy*w + cell.gx;
  if (walk[start]) return cell;
  const seen = new Uint8Array(w*h);
  const q = [{gx:cell.gx, gy:cell.gy, d:0}];
  seen[start]=1;
  const DIRS=[[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,-1],[-1,1],[1,1]];
  for (let i=0;i<q.length;i++){
    const c=q[i], idx=c.gy*w+c.gx;
    if (walk[idx]) return {gx:c.gx, gy:c.gy};
    if (c.d>=maxR) continue;
    for (const [ox,oy] of DIRS){
      const nx=c.gx+ox, ny=c.gy+oy;
      if(nx<0||ny<0||nx>=w||ny>=h) continue;
      const n=ny*w+nx; if(seen[n]) continue;
      seen[n]=1; q.push({gx:nx, gy:ny, d:c.d+1});
    }
  }
  return cell;
}

function dilate(walk, w, h, r) {
  const out = walk.slice();
  for (let gy=0; gy<h; gy++) {
    for (let gx=0; gx<w; gx++) {
      if (!walk[gy*w+gx]) {
        for (let oy=-r; oy<=r; oy++) {
          const yy=gy+oy; if (yy<0||yy>=h) continue;
          for (let ox=-r; ox<=r; ox++) {
            const xx=gx+ox; if (xx<0||xx>=w) continue;
            out[yy*w+xx]=0;
          }
        }
      }
    }
  }
  walk.set(out);
}

// Klipp rasterstorlek till maxCells√ómaxCells
function clampBoundsToGrid(minx, miny, maxx, maxy, cell, maxCells) {
  let w = Math.ceil((maxx - minx) / cell);
  let h = Math.ceil((maxy - miny) / cell);
  if (w <= maxCells && h <= maxCells) return {minx, miny, maxx, maxy};
  const cx=(minx+maxx)/2, cy=(miny+maxy)/2;
  const halfW=(maxCells*cell)/2, halfH=(maxCells*cell)/2;
  return { minx:cx-halfW, miny:cy-halfH, maxx:cx+halfW, maxy:cy+halfH };
}

// ---------------- A* (8-neighbors, corner-cut prevention) ----------------

function astar(grid, Sg, Gg) {
  const {w,h,walk} = grid;
  const N = w*h, sIdx=Sg.gy*w+Sg.gx, gIdx=Gg.gy*w+Gg.gx;
  if (!walk[sIdx] || !walk[gIdx]) return null;

  const gScore=new Float32Array(N); gScore.fill(Infinity); gScore[sIdx]=0;
  const fScore=new Float32Array(N); fScore.fill(Infinity);
  const came  =new Int32Array(N);   came.fill(-1);

  const heap=[], pos=new Int32Array(N); pos.fill(-1);
  const swap=(i,j)=>{ const a=heap[i],b=heap[j]; heap[i]=b; heap[j]=a; pos[a]=j; pos[b]=i; };
  const up=(i)=>{ while(i>0){ const p=(i-1)>>1; if(fScore[heap[p]]<=fScore[heap[i]]) break; swap(i,p); i=p; } };
  const down=(i)=>{ for(;;){ let l=i*2+1,r=l+1,m=i;
    if(l<heap.length&&fScore[heap[l]]<fScore[heap[m]]) m=l;
    if(r<heap.length&&fScore[heap[r]]<fScore[heap[m]]) m=r;
    if(m===i) break; swap(i,m); i=m; } };
  const push=(idx)=>{ heap.push(idx); pos[idx]=heap.length-1; up(heap.length-1); };
  const pop=()=>{ const t=heap[0], last=heap.pop(); if(heap.length){heap[0]=last; pos[last]=0; down(0);} pos[t]=-1; return t; };
  const dec=(idx)=> up(pos[idx]);

  function heur(idx){
    const gx=idx%w, gy=(idx-gx)/w;
    const dx=Math.abs(gx-Gg.gx), dy=Math.abs(gy-Gg.gy);
    const F=Math.SQRT2-1; return (dx<dy)? F*dx+dy : F*dy+dx; // Octile
  }

  fScore[sIdx]=heur(sIdx); push(sIdx);

  const walkAt=(x,y)=>walk[y*w+x];

  while (heap.length) {
    const cur=pop();
    if (cur===gIdx) {
      const out=[]; for(let u=cur; u!==-1; u=came[u]){ const gx=u%w, gy=(u-gx)/w; out.push({gx,gy}); }
      out.reverse(); return out;
    }
    const cgx=cur%w, cgy=(cur-cgx)/w, gc=gScore[cur];

    for (let oy=-1; oy<=1; oy++) for (let ox=-1; ox<=1; ox++){
      if (!ox && !oy) continue;
      const nx=cgx+ox, ny=cgy+oy;
      if (nx<0||ny<0||nx>=w||ny>=h) continue;
      if (!walkAt(nx,ny)) continue;
      if (ox&&oy){ if(!walkAt(cgx,ny) || !walkAt(nx,cgy)) continue; } // anti corner cut
      const nIdx=ny*w+nx, cost=(ox&&oy)?Math.SQRT2:1, tent=gc+cost;
      if (tent<gScore[nIdx]){
        came[nIdx]=cur; gScore[nIdx]=tent;
        const old=fScore[nIdx]; fScore[nIdx]=tent+heur(nIdx);
        if (pos[nIdx]===-1) push(nIdx); else if (fScore[nIdx]<old) dec(nIdx);
      }
    }
  }
  return null;
}

// ---------------- Smoothing & LOS mot OBB ----------------

function smoothPath(grid, pathCells, OBBs) {
  if (!pathCells || pathCells.length <= 2) return pathCells;
  const out=[pathCells[0]];
  let i=0;
  while (i < pathCells.length-1) {
    let j=pathCells.length-1;
    const Pi=gridToWorld(grid, pathCells[i].gx, pathCells[i].gy);
    for (; j>i+1; j--) {
      const Pj=gridToWorld(grid, pathCells[j].gx, pathCells[j].gy);
      if (!losBlockedOBB(Pi, Pj, OBBs)) break;
    }
    out.push(pathCells[j]); i=j;
  }
  return out;
}

function losBlockedOBB(A, B, OBBs) {
  // Enkel O(n) ‚Äì r√§cker fint f√∂r smoothing
  for (const O of OBBs) {
    if (segmentHitsOBB(A, B, O)) return true;
  }
  return false;
}

// ---------------- OBB-geo ----------------

function prepOBB(s) {
  const angle = s.angleRad || 0;
  const c = Math.cos(angle), t = Math.sin(angle);
  const hw = s.w/2, hh = s.h/2;
  // h√∂rn f√∂r AABB-bounds
  const corners = [
    {x: s.cx - hw*c + hh*t, y: s.cy - hw*t - hh*c},
    {x: s.cx + hw*c + hh*t, y: s.cy + hw*t - hh*c},
    {x: s.cx + hw*c - hh*t, y: s.cy + hw*t + hh*c},
    {x: s.cx - hw*c - hh*t, y: s.cy - hw*t + hh*c},
  ];
  let x1=Infinity,y1=Infinity,x2=-Infinity,y2=-Infinity;
  for (const p of corners){ x1=Math.min(x1,p.x); y1=Math.min(y1,p.y); x2=Math.max(x2,p.x); y2=Math.max(y2,p.y); }
  return { kind:'obb', cx:s.cx, cy:s.cy, hw, hh, cos:c, sin:t, bounds:{x1,y1,x2,y2} };
}

function pointInOBB(x,y,O){
  // rotera in i lokala box-koordinater (vinkel = -angle)
  const dx=x-O.cx, dy=y-O.cy;
  const lx =  O.cos*dx + O.sin*dy;
  const ly = -O.sin*dx + O.cos*dy;
  return Math.abs(lx) <= O.hw && Math.abs(ly) <= O.hh;
}

function segmentHitsOBB(A,B,O){
  // transformera segmentet till OBB:ens lokala coords
  const Ax =  O.cos*(A.x-O.cx) + O.sin*(A.y-O.cy);
  const Ay = -O.sin*(A.x-O.cx) + O.cos*(A.y-O.cy);
  const Bx =  O.cos*(B.x-O.cx) + O.sin*(B.y-O.cy);
  const By = -O.sin*(B.x-O.cx) + O.cos*(B.y-O.cy);
  return segmentAABB(Ax,Ay,Bx,By, -O.hw,-O.hh, O.hw,O.hh);
}

// Liang‚ÄìBarsky i lokala coords
function segmentAABB(x0,y0,x1,y1, rx1,ry1,rx2,ry2){
  const dx=x1-x0, dy=y1-y0;
  let t0=0,t1=1;
  const p=[-dx,dx,-dy,dy], q=[x0-rx1,rx2-x0,y0-ry1,ry2-y0];
  for(let i=0;i<4;i++){
    if (p[i]===0){ if (q[i]<0) return false; }
    else{
      const r=q[i]/p[i];
      if (p[i]<0){ if (r>t1) return false; if (r>t0) t0=r; }
      else       { if (r<t0) return false; if (r<t1) t1=r; }
    }
  }
  return true;
}





        </script>
        
        
        
        
        
        
        
        
        
    </body>
</html>
