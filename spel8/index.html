
<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/guarddown1.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game4.js"></script>
        
        
        
        
    </head>
    <body>
        
        
        <div id="build-ui" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">
  <button id="build-base-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkgreen;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Bygg bas</button>
  <button id="build-barracks-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: darkred;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* <-- GÖMD TILLS VIDARE */
">
  Bygg barack
</button>
  
  
</div>
        
<div id="build-ui2" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-worker-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna arbetare</button>
 
  
</div>        
<div id="build-ui3" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-warrior-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna krigare</button>
 
  
</div>            

<div id="end-screen" style="
  position:fixed; inset:0; display:none; 
  align-items:center; justify-content:center; 
  background:rgba(0,0,0,0.8); z-index:2000; color:#fff; font-family:sans-serif;">
  <div style="text-align:center;">
    <div id="end-title" style="font-size:64px; font-weight:800; margin-bottom:16px;"></div>
    <div id="end-sub" style="font-size:22px; opacity:0.85; margin-bottom:28px; white-space:pre-line;"></div>
    <button id="btn-restart" style="
      font-size:18px; padding:12px 20px; border:0; border-radius:10px; 
      background:linear-gradient(180deg,#48bb78,#2f855a); color:#fff; cursor:pointer;">
      Spela igen
    </button>
  </div>
</div>

<div id="place-hint" style="
  position:fixed; bottom:84px; left:0; right:0; text-align:center;
  color:#fff; font:600 36px/1.2 system-ui, sans-serif;
  text-shadow:0 1px 2px rgba(0,0,0,.6); display:none; z-index:1200;">
  Tryck på kartan för att placera
</div>

<div id="hint-pan" style="
  position:fixed; bottom:50%; left:50%; transform:translate(-50%, 50%);
  background:rgba(0,0,0,0.6);
  color:#fff; padding:6px 10px;
  border-radius:6px;
  font:600 50px system-ui, sans-serif;
  text-align:center;
  z-index:2000;
  display:none;">
</div>





        
<div id="resourceUI" style="position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; font-family: sans-serif; font-size: 50px; z-index: 100;">
    <img src="images/gold.png" style="width:50px; vertical-align: middle;">Guld: <span id="goldCount">0</span><br>
    <img src="images/wood.png" style="width:50px; vertical-align: middle;">Trä: <span id="woodCount">0</span>
</div>   
  
        
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
        
        <script>

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

            game = new Game4("Spelet");
            var audio = new Audio('sounds/wow.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
            window.allowSelection = function() {
                return !buildMode; // tillåt bara selektion när man inte bygger
            };
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                      if (buildMode && ghostBuilding) {
                        const t = e.touches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        const gx = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        const gy = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        ghostBuilding.x = gx;
                        ghostBuilding.y = gy;
                        lastTouchPos = {x: gx, y: gy};
                      }
                    if (buildMode && !fromUI(e.target)) {
                        buildArmed = true; // nu får man placera
                      }
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/wow.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
              }
          });

           
            
            
            let keysPressed = {};
                document.addEventListener('click', (event) => {
        
               
                try{if(audio.paused){ 
                        audio.play();
                    }
                }catch(error){};
             });

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            document.addEventListener("keydown", function(e) {
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
            });
            let buildMode = false;
            let buildType = null;
            let ghostBuilding = null;
            let pendingBuilds = [];
            let selectedWorkersBeforeBuild = [];
            let selectedWorkers = [];
            let lastTouchPos = null;
            let gold = 1400;
            let wood = 1200;
            let rgold = 1400;
            let rwood = 1200;
            let gameOver = false;
            let buildArmed = false;
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}
            const IS_TOUCH = mobileAndTabletCheck();

            function clearSelection() {
              const all = game.getAllObjects();
              for (const o of all) o.selected = false;
            }
            function fromUI(evtTarget){
                return !!(evtTarget && evtTarget.closest &&
                  evtTarget.closest('#build-ui, #build-ui2, #build-ui3, button'));
              }
            function setBuildUIActive(on) {
                
                const hint = document.getElementById("place-hint");
                if (hint) hint.style.display = on ? "block" : "none";
                
                const btn = document.getElementById(buildType === "base" ? "build-base-btn" : "build-barracks-btn");
                if (!btn) return;
                btn.style.outline = on ? "3px solid gold" : "none";
                btn.style.boxShadow = on ? "0 0 12px gold" : "none";
              }  
            function showPanHint(){
                const el = document.getElementById("hint-pan");
                if (el) {
                  el.innerText = IS_TOUCH
                    ? "Använd två fingrar för att flytta kartan"
                    : "Använd W A S D för att flytta kartan";
                  el.style.display = "block";
                  setTimeout(()=> el.style.display = "none", 3000);
                }
            } 
              
            document.getElementById("btn-restart").addEventListener("click", () => {
                // enklaste reset: ladda om
                location.reload();
              });
            
            
            document.getElementById("build-base-btn").innerHTML = "Bygg bas<br>1000 guld / 1000 trä";
            document.getElementById("build-barracks-btn").innerHTML = "Bygg barrack<br>500 guld / 500 trä";
            document.getElementById("train-worker-btn").innerHTML = "Träna arbetare<br>200 guld / 100 trä";
            document.getElementById("train-warrior-btn").innerHTML = "Träna warrior<br>300 guld / 100 trä";
            document.getElementById("build-base-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=1000&&wood>=1000){gold-=1000;wood-=1000;}    
                else return;    
                buildMode = true;
                buildType = "base";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("base"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("build-barracks-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=500&&wood>=500){gold-=500;wood-=500;}    
                else return;    
                buildMode = true;
                buildType = "bar";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("bar"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("train-worker-btn").addEventListener("click", () => {
                const base = game.getAllObjectsoftype(game.getobjecttype("base")).find(b => b.selected);
                if (!base) return;

                if (gold >= 200 && wood >= 100) {
                    gold -= 200;
                    wood -= 100;

                    base.buildQueue = base.buildQueue || [];
                    base.buildQueue.push("worker");
                } else {
                   
                }
            });    
            document.getElementById("train-warrior-btn").addEventListener("click", () => {
                const bar = game.getAllObjectsoftype(game.getobjecttype("bar")).find(b => b.selected);
                if (!bar) return;

                if (gold >= 300 && wood >= 100) {
                    gold -= 300;
                    wood -= 100;

                    bar.buildQueue = bar.buildQueue || [];
                    bar.buildQueue.push("guard");
                } else {
                   
                }
            }); 
            
            
            document.addEventListener("touchmove", function(e) {
                                if (e.target.closest("#build-ui")) {return;}
                                 if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;}
                if (e.touches.length >= 2 && buildMode) {
                    cancelBuildMode();
                    return;
                }
                
                
    
              if (buildMode && ghostBuilding) {
    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
    let touch = e.touches[0];
    lastTouchPos = {
        x: touch.clientX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2,
        y: touch.clientY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2
    };
    ghostBuilding.x = lastTouchPos.x;
    ghostBuilding.y = lastTouchPos.y;
    ghostBuilding.animation=0;
    isPlacingBuilding = true;
}
            
            
            });
            
            document.addEventListener("touchend", function(e) {
				selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
				
							if(w.counter2>10){
                            if(w.workobject)w.workobject.occupied=false;                                
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
							}
                        }
                
                
                 if(ghostBuilding!=null&&isBuildPlacementValid(ghostBuilding)==false){return;}
        
                if (buildMode && ghostBuilding) {
                    
                    if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;} // <-- inga “dubbeltryck på knappen”-placeringar
                    buildArmed = false; // kräver nytt tryck på kartan för nästa bygge
  
                    
                    
                    
                    if (lastTouchPos == null) {
                        const t = e.changedTouches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        ghostBuilding.x = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        ghostBuilding.y = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        
                    }

                      if (isBuildPlacementValid(ghostBuilding) === false) return;

                    
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    isPlacingBuilding = false;
                    ghostBuilding.iscontrollable=true;
                    ghostBuilding.animation=0;
                    setBuildUIActive(false);
                    
                    
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {
                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        clearSelection();
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
                
                
                
                
                
                
                
                
                
                
            });
            
            document.addEventListener("contextmenu", function(e) {
                e.preventDefault(); // förhindra browserns meny
                
                
                if (buildMode) {
            
                    cancelBuildMode();
                }
            });

            
            document.addEventListener("mousemove", function(e) {
                cursorX = e.clientX;
                cursorY = e.clientY;
                lastTouchPos = null; // ← detta säger "vi är i PC-läge"
                ghostBuilding.animation=0;
            });
            document.addEventListener("mousedown", function(e) {
                selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
                            if(w.workobject)w.workobject.occupied=false;
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
                            
                        }
                
                
                if(isBuildPlacementValid(ghostBuilding)==false)return;
                
                if (fromUI(e.target)) return;   // ignorera klick i UI
                if (buildMode) buildArmed = true;
                
                
                
                if (e.button === 2 && buildMode) {
                    e.preventDefault(); // hindra fokus/kontext
                    return; // inget mer körs
                }
                
                
                if (buildMode && ghostBuilding) {
                    const currentMap = game.maps[game.currentmap];
                    const x = ghostBuilding.x;
                    const y = ghostBuilding.y;

                    if (!buildArmed) return;      // inte armat → ingen placering
                    // commit bygget (din befintliga kod)
                    buildArmed = false;  
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    ghostBuilding.iscontrollable=true;
                    setBuildUIActive(false);
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {

                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
            });
            
            let inputClick = null;  // world-coords för senaste klick/tap

            function toWorldCoords(clientX, clientY){
              const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
              return {
                x: clientX/zoom - game.maps[game.currentmap].camerax,
                y: clientY/zoom - game.maps[game.currentmap].cameray
              };
            }

            document.addEventListener('mousedown', (e) => {
              inputClick = toWorldCoords(e.clientX, e.clientY);
            });

            document.addEventListener('touchend', (e) => {
              const t = e.changedTouches[0];
              inputClick = toWorldCoords(t.clientX, t.clientY);
            });
            function pointInObj(px, py, o){
                return px >= o.x && px <= o.x + o.dimx && py >= o.y && py <= o.y + o.dimy;
              }
            function pressedThisFrame(o){
              if (o.mousepressed) return true;                 // desktop
              if (inputClick && pointInObj(inputClick.x, inputClick.y, o)) return true; // mobil/desktop
              return false;
            }
            function consumeInputClick(){ inputClick = null; }
            
             showPanHint();
             var check = function(){
                 
                
                 
                canvas.width=document.body.clientWidth;
                canvas.height=document.body.clientHeight-8;
                 
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
                
                const camSpeed = 15;
                const currentMap = game.maps[game.currentmap];

                if (keyState.w) currentMap.cameray += camSpeed;
                if (keyState.s) currentMap.cameray -= camSpeed;
                if (keyState.a) currentMap.camerax += camSpeed;
                if (keyState.d) currentMap.camerax -= camSpeed;
                
                document.getElementById("goldCount").textContent = gold;
                document.getElementById("woodCount").textContent = wood;
                
                
                let anyWorkerSelected = false;
                if (game.maps.length > 0) {
                    const workers = game.getobjecttype("worker");
                    if (workers) {
                        anyWorkerSelected = workers.objects.some(o => o.selected);
                    }
                }
                document.getElementById("build-ui").style.display = anyWorkerSelected ? "flex" : "none";
                
                
                game.updateanimation(ctx);
                drawHealthBars();
		gras= game.getobjecttype("ground"); 				
                guard =game.getobjecttype("guard"); 
                worker =game.getobjecttype("worker"); 
                tree =game.getobjecttype("tree"); 
                goldmine =game.getobjecttype("goldmine"); 
                base=game.getobjecttype("base"); 
                archer=game.getobjecttype("archer"); 
                
                
                //ENEMYS
                rbar =game.getobjecttype("rbar"); 
                rbase =game.getobjecttype("rbase"); 
                rguard =game.getobjecttype("rguard"); 
                rworker =game.getobjecttype("rworker"); 
                rarcher=game.getobjecttype("rarcher"); 
                
                //projectiles
                arrow =game.getobjecttype("arrow"); 
                
                if (buildMode && ghostBuilding&& lastTouchPos === null) {
                    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                    ghostBuilding.x = cursorX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2;
                    ghostBuilding.y = cursorY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2;
                }
                
                
                
                
                
                
                
                
                if(guard!=null){
                    
                    // Vilka av dina enheter ska lyda ordern?
                    const selectedUnits = [
                      ...game.getAllObjectsoftype(game.getobjecttype("guard")).filter(u => u.selected),
                      ...game.getAllObjectsoftype(game.getobjecttype("worker")).filter(u => u.selected),
                    ];

                    function orderFollow(target) {
                      for (const u of selectedUnits) {
                        u.followTarget = true;         // flagga för “håll fast vid målet”
                        u.targetObject = target;       // <- viktigt
                        u.workobject = null;           // släpp ev. jobb
                        u.deliveryTarget = null;
                        u.returning = false;
                        u.lockDirection = false;       // vi vill kunna svänga efter målet

                        const cx = target.x + target.dimx/2;
                        const cy = target.y + target.dimy/2;
                        u.targetX = cx - u.dimx/2;     // initial chase så de börjar gå direkt
                        u.targetY = cy - u.dimy/2;
                      }
                    }

                    // Kolla klick på fiender (enheter + byggnader)
                    let enemyClicked = null;
                    for (const e of (game.getobjecttype("rguard")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rworker")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbase")?.objects  || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbar")?.objects   || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }

                    if (enemyClicked && selectedUnits.length) {
                      orderFollow(enemyClicked);
                      if (IS_TOUCH) clearSelection();
                    }
                    
                    
                    function isAlive(o){
                        return !!o && !o.ghost && game.getAllObjects().includes(o);
                      }

                      // Alla dina guards + workers ska “jaga” sitt target om followTarget=true
                      const myUnits = [
                        ...game.getobjecttype("guard")?.objects || [],
                        ...game.getobjecttype("worker")?.objects || [],
                      ];

                      for (const u of myUnits) {
                        if (u.followTarget && u.targetObject) {
                          if (!isAlive(u.targetObject)) {
                            // målet dog/försvann → släpp
                            u.followTarget = false;
                            u.targetObject = null;
                            continue;
                          }
                          const t = u.targetObject;
                          const cx = t.x + t.dimx/2;
                          const cy = t.y + t.dimy/2;
                          u.targetX = cx - u.dimx/2;   // uppdatera mot målets nuvarande position
                          u.targetY = cy - u.dimy/2;
                        }
                      }
                    
                    
                    
                    enemyTryToBuildBase();
                    enemyTryToBuildBar();
                    updateRedWorkerAI();
                    updateRedTrainingAI();
                    updateRedGuardAI();
                    
                    
                    
                    
                    const anyBaseSelected = game.getAllObjectsoftype(game.getobjecttype("base")).some(o => o.selected);
                    document.getElementById("build-ui2").style.display = anyBaseSelected ? "flex" : "none";
                    
                    const anyBarSelected = game.getAllObjectsoftype(game.getobjecttype("bar")).some(o => o.selected);
                    document.getElementById("build-ui3").style.display = anyBarSelected ? "flex" : "none";
                    
                    
                    const canAffordBase = gold >= 1000 && wood >= 1000;
                    const canAffordWorker = gold >= 200 && wood >= 100;
                    const canAffordWarrior = gold >= 300 && wood >= 100;
                    const canAffordBar = gold >= 500 && wood >= 500;

                    document.getElementById("build-base-btn").style.opacity = canAffordBase ? "1" : "0.5";
                    document.getElementById("train-worker-btn").style.opacity = canAffordWorker ? "1" : "0.5";
                    document.getElementById("train-warrior-btn").style.opacity = canAffordWarrior ? "1" : "0.5";
                    document.getElementById("build-barracks-btn").style.opacity = canAffordBar ? "1" : "0.5";
                    
                    if (base.objects.length>0&&base.objects[0].animation==1) {
                        document.getElementById("build-barracks-btn").style.display = "inline-block";
                    }
                    
                    
                  
                    selectedWorkers = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                    
                    const basesAndBars = [
                        ...game.getAllObjectsoftype(game.getobjecttype("base")),
                        ...game.getAllObjectsoftype(game.getobjecttype("bar")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbase")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbar")),
                    ];

                    for (let base of basesAndBars) {
                        if(base.animation==0)break;
                        
                        base.buildQueue = base.buildQueue || [];
                        base.buildTimer = base.buildTimer || 0;

                        if (base.buildQueue.length > 0) {
                            base.buildTimer++;

                            // så länge vi hinner producera
                            while (base.buildQueue.length > 0 && base.buildTimer >= 1000) {
                                const unitType = game.getobjecttype(base.buildQueue[0]);

                                const spacing = 100;
                                const directions = [
                                    [spacing, 0], [-spacing, 0], [0, spacing], [0, -spacing],
                                    [spacing, spacing], [-spacing, -spacing], [spacing, -spacing], [-spacing, spacing]
                                ];

                                let placed = false;

                                for (let [dx, dy] of directions) {
                                    const px = base.x + base.dimx / 2 + dx;
                                    const py = base.y + base.dimy / 2 + dy;

                                    const newUnit = game.addobject(
                                        unitType,
                                        px,
                                        py,
                                        unitType.standarddimx,
                                        unitType.standarddimy,
                                        0,
                                        false
                                    );

                                    const overlaps = newUnit.collideslist(game.maps, game.currentmap, "any");

                                    if (!overlaps) {
                                        placed = true;
                                        break;
                                    } else {
                                        game.removeobject(unitType, newUnit);
                                    }
                                }

                                if (placed) {
                                    base.buildQueue.shift();
                                    base.buildTimer -= 1000; // 💡 fortsätt direkt om nästa också är klar
                                } else {
                                    // avbryt loopen, försök igen nästa frame
                                    break;
                                }
                            }
                        }
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    for(let i=0;i<goldmine.objects.length;i++){
                    
                        goldmine.objects[i].selectable=true;
                        goldmine.objects[i].canMove=false;
                    
                        if(goldmine.objects[i].mousepressed==true&&anyWorkerSelected){

                            for (let w of selectedWorkers) {

                                w.workobject=goldmine.objects[i];
				w.counter2=0;
                                if (IS_TOUCH) w.selected=false;
                            }
                        }


                    }
                    for(let i=0;i<tree.objects.length;i++){
                    
                        tree.objects[i].selectable=true;
                        tree.objects[i].canMove=false;
                    
                        if(tree.objects[i].mousepressed==true&&anyWorkerSelected){
                             
                             assignWorkersToNearestTreesSmart();
                             if (IS_TOUCH) clearSelection();
                        }


                    }
                    
                    
                    
                    
                    for(let i=0;i<guard.objects.length;i++){

                        guard.objects[i].selectable=true;
                        guard.objects[i].iscontrollable=true;
                        if ( guard.objects[i].direction === "up")  guard.objects[i].animation = 0;
                        else if ( guard.objects[i].direction === "right")  guard.objects[i].animation = 1;
                        else if ( guard.objects[i].direction === "down")  guard.objects[i].animation = 2;
                        else if ( guard.objects[i].direction === "left")  guard.objects[i].animation = 3;
                        
                        

                    }
                     for(let i=0;i<archer.objects.length;i++){

                        archer.objects[i].selectable=true;
                        archer.objects[i].iscontrollable=true;
                        if ( archer.objects[i].direction === "up")  archer.objects[i].animation = 0;
                        else if ( archer.objects[i].direction === "right")  {archer.objects[i].animation = 1;archer.objects[i].fliped=false;}
                        else if ( archer.objects[i].direction === "down")  archer.objects[i].animation = 2;
                        else if ( archer.objects[i].direction === "left") { archer.objects[i].animation = 1;archer.objects[i].fliped=true;}

                    }
                    for(let i=0;i<rarcher.objects.length;i++){

                        rarcher.objects[i].selectable=true;
                        rarcher.objects[i].iscontrollable=true;
                        if ( rarcher.objects[i].direction === "up")  rarcher.objects[i].animation = 0;
                        else if ( rarcher.objects[i].direction === "right")  {rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=false;}
                        else if ( rarcher.objects[i].direction === "down")  rarcher.objects[i].animation = 2;
                        else if ( rarcher.objects[i].direction === "left") { rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=true;}
                        
                        

                    }
                    
                    for(let i=0;i<rguard.objects.length;i++){

                        rguard.objects[i].selectable=true;
                        rguard.aiNoLocalAvoid = true; // movement använder mikro-styrning (ovan)
                        rguard.lockDirection  = true; // AI sätter facing för kollisions-attack
                        rguard.aiHoldTarget   = true; // AI släpper själv målet först när det vill

                        if ( rguard.objects[i].direction === "up")  rguard.objects[i].animation = 0;
                        else if ( rguard.objects[i].direction === "right")  rguard.objects[i].animation = 1;
                        else if ( rguard.objects[i].direction === "down")  rguard.objects[i].animation = 2;
                        else if ( rguard.objects[i].direction === "left")  rguard.objects[i].animation = 3;
                        
                        

                    }
             
                    for(let i=0;i<worker.objects.length;i++){

                        worker.objects[i].selectable=true;
			worker.objects[i].counter2++;
                        worker.objects[i].iscontrollable=true;
                        
                        
                        
                        
                        if ( worker.objects[i].direction === "up")  worker.objects[i].animation = 0;
                        else if ( worker.objects[i].direction === "right")  {worker.objects[i].animation = 1;worker.objects[i].fliped=false;}
                        else if ( worker.objects[i].direction === "down")  worker.objects[i].animation = 2;
                        else if ( worker.objects[i].direction === "left") { worker.objects[i].animation = 1;worker.objects[i].fliped=true;}
                        
                        
                         for (let j = 0; j < pendingBuilds.length; j++) {
                            let building = pendingBuilds[j];

                            if (game.collideswithanoterobject(worker.objects[i],building)) {
                                building.buildProgress = (building.buildProgress || 0) + 1;
                                
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                
                                 // bygg-animation

                                if (building.buildProgress > 1000) {
                                    // Klar – ta bort från pendingBuilds
                                    pendingBuilds.splice(j, 1);
                                    building.buildProgress = null;
                                    worker.objects[i].buildingTarget = null;
                                    worker.objects[i].animation = 0; // idle
                                    building.animation=1;
                                }
                                
                            }
                        }
                        if(worker.objects[i].workobject!=null&&worker.objects[i].returning==false){
                            
                            if(worker.objects[i].workobject.name=="goldmine"){
                                
                                worker.objects[i].targetX = worker.objects[i].workobject.x+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                                
                            }
                            else{
                                worker.objects[i].targetX = worker.objects[i].workobject.x;//+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y;//+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                            }
                            
                        
                            
                            if(worker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(worker.objects[i],"tree");
                                if(oo&&worker.objects[i].workobject!=oo){worker.objects[i].workobject.occupied=false;worker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<1002) {
                                    if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                    if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                    worker.objects[i].counter++;

                                }
                                if (worker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = worker.objects[i].x - b.x;
                                        let dy = worker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        worker.objects[i].targetX = closest.x+closest.dimx/2;
                                        worker.objects[i].targetY = closest.y+closest.dimy/2;
                                        worker.objects[i].targetObject=closest;
                                        worker.objects[i].returning = true; // ny flagga
                                        worker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<202) {
                                    worker.objects[i].animation=100;
                                    worker.objects[i].counter++;

                                }
                                
                            if (worker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = worker.objects[i].x - b.x;
                                    let dy = worker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    worker.objects[i].targetX = closest.x+closest.dimx/2;
                                    worker.objects[i].targetY = closest.y+closest.dimy/2;
                                    worker.objects[i].targetObject=closest;
                                    worker.objects[i].returning = true; // ny flagga
                                    worker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (worker.objects[i].returning && worker.objects[i].deliveryTarget) {
                            
                            
                            if(worker.objects[i].workobject.name!="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 6;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 7;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =8;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 7;
                            }
                            if(worker.objects[i].workobject.name=="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 9;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 10;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =11;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                worker.objects[i].returning = false;
                                worker.objects[i].deliveryTarget = null;
                                worker.objects[i].counter = 0;
                                worker.objects[i].animation = 0; // idle
                                
                                if(worker.objects[i].workobject.name!="tree")gold += 10;
                                if(worker.objects[i].workobject.name=="tree"){wood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
                    
                    for(let i=0;i<rworker.objects.length;i++){

                        rworker.objects[i].selectable=true;
			rworker.objects[i].counter2++;
                        
                        
                        if(rworker.objects[i].workobject!=null && rworker.objects[i].workobject.name=="rbase")continue;
                        if(rworker.objects[i].buildobject!=null)continue;
                        
                        if ( rworker.objects[i].direction === "up")  rworker.objects[i].animation = 0;
                        else if ( rworker.objects[i].direction === "right")  {rworker.objects[i].animation = 1;rworker.objects[i].fliped=false;}
                        else if ( rworker.objects[i].direction === "down")  rworker.objects[i].animation = 2;
                        else if ( rworker.objects[i].direction === "left") { rworker.objects[i].animation = 1;rworker.objects[i].fliped=true;}
                        
                        
                       
                                

                        if(rworker.objects[i].workobject!=null&&rworker.objects[i].returning==false){
                            
                            if(rworker.objects[i].workobject.name=="goldmine"){
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y;+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                                
                                
                            }
                            else{
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;//+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y;//+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                            }
                            
                        
                            
                            if(rworker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(rworker.objects[i],"tree");
                                
                                if(oo&&rworker.objects[i].workobject!=oo){rworker.objects[i].workobject.occupied=false;rworker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<1002) {
                                    if(rworker.objects[i].animation==0)rworker.objects[i].animation = 3;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 4;
                                    if(rworker.objects[i].animation==2)rworker.objects[i].animation = 5;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 4;
                                    rworker.objects[i].counter++;

                                }
                                if (rworker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = rworker.objects[i].x - b.x;
                                        let dy = rworker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                        rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                        rworker.objects[i].targetObject=closest;
                                        rworker.objects[i].returning = true; // ny flagga
                                        rworker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<202) {
                                    rworker.objects[i].animation=100;
                                    rworker.objects[i].counter++;

                                }
                                
                            if (rworker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = rworker.objects[i].x - b.x;
                                    let dy = rworker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                    rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                    rworker.objects[i].targetObject=closest;
                                    rworker.objects[i].returning = true; // ny flagga
                                    rworker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (rworker.objects[i].returning && rworker.objects[i].deliveryTarget) {
                            
                            
                            if(rworker.objects[i].workobject.name!="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 6;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 7;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =8;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 7;
                            }
                            if(rworker.objects[i].workobject.name=="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 9;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 10;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =11;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                rworker.objects[i].returning = false;
                                //rworker.objects[i].deliveryTarget = null;
                                rworker.objects[i].counter = 0;
                                rworker.objects[i].animation = 0; // idle
                                
                                if(rworker.objects[i].workobject.name!="tree")rgold += 10;
                                if(rworker.objects[i].workobject.name=="tree"){rwood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
 
                    
                    
                    
                    
                    
                    handleCombat("guard", ["rguard", "rworker", "rbase", "rbar"], 0.2);
                    handleCombat("worker", ["rguard", "rworker", "rbase", "rbar"], 0.1);
                    handleCombat("rguard", ["guard", "worker", "base", "bar"], 0.2);
                    handleCombat("rworker", ["guard", "worker", "base", "bar"], 0.1);
                    updateArcherShooting("archer", ["rguard","rworker","rarcher","rbase","rbar"]);
                    updateArcherShooting("rarcher", ["guard","worker","archer","base","bar"]);
                    updateArrows();
                    
                    checkWinLose(); 
                }

                 
                
                window.requestAnimationFrame(check);   
            };check();
            
            function isBuildPlacementValid(o) {
                if (!o || !o.collideslistan) return false;
                
                            // Avståndsgräns från resurser (t.ex. 100 pixlar)
                const minDistanceToResources = 300;
                var resourceTypes = ["tree", "goldmine"]; // eller hur du identifierar resurser
                if(o.name=="rbar")resourceTypes = ["tree", "goldmine","rbase"];
                for (let type of resourceTypes) {
                    const resources = game.getAllObjectsoftype(game.getobjecttype(type));
                    for (let res of resources) {
                        const dist = game.getDistance(o.x, o.y, res.x, res.y);
                        if (dist < minDistanceToResources) {
                            return false; // För nära en resurs
                        }
                    }
                }
                
                
                
                return o.collideslistan.length === 0;
            }
            function cancelBuildMode() {
   
                
                if (ghostBuilding&&ghostBuilding.name=="base") {
                    gold+=1000;wood+=1000;
                    game.removeobject(game.getobjecttype("base"),ghostBuilding); // ⬅️ Viktigt!
                    ghostBuilding = null;
                }
                else if (ghostBuilding&&ghostBuilding.name=="bar") {
                    gold+=500;wood+=500;
                    game.removeobject(game.getobjecttype("bar"),ghostBuilding); // ⬅️ Viktigt!
                    ghostBuilding = null;
                }
                setBuildUIActive(false);
                buildMode = false;
                buildType = null;
                selectedWorkersBeforeBuild = [];
                isPlacingBuilding = false;
                console.log("Byggläge avbrutet");
            }
            function assignWorkersToNearestTreesSmart() {
                    const allTrees = game.getAllObjectsoftype(game.getobjecttype("tree"))
                        .filter(t => !t.occupied); // inga distansfilter här

                    const assignedTrees = new Set();

                    for (let w of selectedWorkers) {
                        if(w.workobject!=null)return;
                        
                        let bestTree = null;
                        let bestScore = Infinity;

                        for (let t of allTrees) {
                            if (assignedTrees.has(t)) continue;
                            const distToWorker = getManualDistance(t.x, t.y, w.x, w.y);
                      

                            if (distToWorker < bestScore) {
                                //alert(t.x+" "+ t.y+" "+ w.x+" "+ w.y);
                                
                                bestScore = distToWorker;
                                bestTree = t;
                            }
                        }
                        //alert("NY");
                        if (bestTree) {
                            
                            
                            
                            w.targetX = bestTree.x;// + bestTree.dimx / 2;
                            w.targetY = bestTree.y;// + bestTree.dimy / 2;
                            w.workobject = bestTree;
                            w.returning = false;
                            w.counter2 = 0;
                            bestTree.occupied = true;
                            assignedTrees.add(bestTree);
                        }
                    }
                }
            function getManualDistance(x1, y1, x2, y2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function enemyTryToBuildBar() {
                if(!game.getobjecttype("rworker").objects[0]||!game.getobjecttype("rbase").objects[0]||game.getobjecttype("rbase").objects[0].animation==0)return;
                
                const w = game.getobjecttype("rworker").objects[0];
                const rbaseType = game.getobjecttype("rbar");
                
                
                
                if (w.workobject && w.workobject.name=="rbar") {
                    
                    if (game.collideswithanoterobject(w,w.workobject)) {
                        
                        w.workobject.buildProgress += 1;
                        if(w.animation==0)w.animation = 3;
                        if(w.animation==1&&w.fliped==false)w.animation = 4;
                        if(w.animation==2)w.animation = 5;
                        if(w.animation==1&&w.fliped==true)w.animation = 4;      
                        
                        if (w.workobject.buildProgress > 1000) {
                            w.workobject.ghost = false;
                            w.workobject.selectable = true;
                            w.workobject.animation=1;
                            w.workobject = null;
                            w.buildobject=null;
                        }
                        
                        
                    }
                    
                }
                if (rwood < 500 || rgold < 500 ||(game.getobjecttype("rbar").objects[0])) return;
                
                const mines = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                if (mines.length === 0) return;
                const mine = mines[0]; // använd första gruvan
                const spacing = 100;
                let bestPos = null;
                let bestScore = Infinity;

                for (let dx = -5; dx <= 5; dx++) {
                    for (let dy = -5; dy <= 5; dy++) {
                        const px = mine.x + dx * spacing;
                        const py = mine.y + dy * spacing;

                        const temp = game.addobject(
                            rbaseType,
                            px,
                            py,
                            rbaseType.standarddimx,
                            rbaseType.standarddimy,
                            0,
                            false

                        );
                        temp.ghost = true;

                        if (isBuildPlacementValid(temp)) {
                            const distToMine = game.getDistance(px, py, mine.x, mine.y);

                            // Hitta närmaste rworker
                            let closestWorkerDist = Infinity;
                         
                                const d = game.getDistance(px, py, w.x, w.y);
                                if (d < closestWorkerDist) closestWorkerDist = d;
                            

                            const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning här

                            if (score < bestScore) {
                                bestScore = score;
                                bestPos = { x: px, y: py };
                            }
                        }

                        game.removeobject(rbaseType, temp);
                    }
                }

                if (bestPos) {
                    const ghost = game.addobject(
                        rbaseType,
                        bestPos.x,
                        bestPos.y,
                        rbaseType.standarddimx,
                        rbaseType.standarddimy,
                        0,
                        false
                    );
                    ghost.ghost = false;
                    ghost.canMove = false;
                    ghost.selectable = false;
                    ghost.enemyBuild = true;
                    ghost.buildProgress = 0;

                    w.targetX = bestPos.x;
                    w.targetY = bestPos.y;
                    w.workobject = ghost;
                    w.buildobject=ghost;
                    w.counter2 = 0;
                    

                    rwood -= 500;
                    rgold -= 500;
                }
                
                
                
                
            }
            
            
            function enemyTryToBuildBase() {
                
                  const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
                for (let w of rworkers) {
            
                    if (w.workobject && w.workobject.name=="rbase") {
                        // Börja bygga
                
                        if (game.collideswithanoterobject(w,w.workobject)) {
                            w.workobject.buildProgress += 1;
                            if(w.animation==0)w.animation = 3;
                                if(w.animation==1&&w.fliped==false)w.animation = 4;
                                if(w.animation==2)w.animation = 5;
                                if(w.animation==1&&w.fliped==true)w.animation = 4;
                            
                            if (w.workobject.buildProgress > 1000) {
                                  w.workobject.ghost = false;
                                  w.workobject.selectable = true;
                                  w.workobject.animation=1;
                                  w.workobject = null;

                            }  
                            
                        }
                        
                        
                        
                        
                        
                        
                        
                    }
                }
                
       if(game.getobjecttype("rbase").objects.length==1)return;         
       if (rwood < 1000 || rgold < 1000 ) return;
       
    const rbaseType = game.getobjecttype("rbase");

    // Finns redan en bas eller ghost-bygge?
    const baseExists = game.getAllObjects().some(o =>
        o.type === rbaseType && (!o.ghost || o.ghost === true)
    );
    if (baseExists) return;

    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));
    if (mines.length === 0) return;

    if (rworkers.length === 0) return;

    const mine = mines[1]; // använd första gruvan
    const spacing = 100;
    let bestPos = null;
    let bestScore = Infinity;

    for (let dx = -5; dx <= 5; dx++) {
        for (let dy = -5; dy <= 5; dy++) {
            const px = mine.x + dx * spacing;
            const py = mine.y + dy * spacing;

            const temp = game.addobject(
                rbaseType,
                px,
                py,
                rbaseType.standarddimx,
                rbaseType.standarddimy,
                0,
                false
                        
            );
            temp.ghost = true;

            if (isBuildPlacementValid(temp)) {
                const distToMine = game.getDistance(px, py, mine.x, mine.y);

                // Hitta närmaste rworker
                let closestWorkerDist = Infinity;
                for (let w of rworkers) {
                    const d = game.getDistance(px, py, w.x, w.y);
                    if (d < closestWorkerDist) closestWorkerDist = d;
                }

                const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning här

                if (score < bestScore) {
                    bestScore = score;
                    bestPos = { x: px, y: py };
                }
            }

            game.removeobject(rbaseType, temp);
        }
    }

    if (bestPos) {
        const ghost = game.addobject(
            rbaseType,
            bestPos.x,
            bestPos.y,
            rbaseType.standarddimx,
            rbaseType.standarddimy,
            0,
            false
        );
        ghost.ghost = false;
        ghost.canMove = false;
        ghost.selectable = false;
        ghost.enemyBuild = true;
        ghost.buildProgress = 0;

        for (let w of rworkers) {
            w.targetX = bestPos.x;
            w.targetY = bestPos.y;
            w.workobject = ghost;
            w.counter2 = 0;
        }

        rwood -= 1000;
        rgold -= 1000;
    }
}
function updateRedWorkerAI() {
    const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
    const trees = game.getAllObjectsoftype(game.getobjecttype("tree")).filter(t => !t.occupied);
    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));

    let woodWorkers = 0;
    let goldWorkers = 0;

    // Räkna redan tilldelade
    for (let w of rworkers) {
        if (w.workobject) {
            if (w.workobject.name === "tree") woodWorkers++;
            if (w.workobject.name === "goldmine") goldWorkers++;
        }
    }

    // Tilldela nya arbetare
    for (let w of rworkers) {
        if (w.workobject) continue; // hoppa om redan jobbar

        let targetList = null;
        let targetType = "";

        // Fördela 3 av 5 till träd
        if ((woodWorkers * 5) < (rworkers.length * 3) && trees.length > 0) {
            targetList = trees;
            targetType = "tree";
        } else if (mines.length > 0) {
            targetList = mines;
            targetType = "goldmine";
        }
        
           let nearbyTrees = trees.filter(t => 
            game.getDistance(w.x, w.y, t.x, t.y) < 1000
        );

      
        
        
        
        if (targetList) {
            let bestTarget = null;
            let bestDist = Infinity;

            for (let t of targetList) {
                const d = game.getDistance(w.x, w.y, t.x, t.y);
                if (d < bestDist && !t.occupied) {
                    bestDist = d;
                    bestTarget = t;
                }
            }

            if (bestTarget) {
                
                if(targetType=="tree"&&nearbyTrees.length > 0){
                    let tree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                    tree.occupied = true;
                    w.workobject = tree;
                    w.targetX = tree.x;
                    w.targetY = tree.y;
                    w.returning = false;
                    w.counter2 = 0;
                    
                }
                else{
                
                    w.targetX = bestTarget.x; //+ bestTarget.dimx / 2;
                    w.targetY = bestTarget.y; //+ bestTarget.dimy / 2;
                    w.workobject = bestTarget;
                    w.returning = false;
                    w.counter2 = 0;
                    if(bestTarget.name=="tree")bestTarget.occupied = true;
                }
                // Uppdatera räknare
                if (targetType === "tree") woodWorkers++;
                else if (targetType === "goldmine") goldWorkers++;
            }
        }
    }
}        
function updateRedTrainingAI() {
    
    
    if(game.getobjecttype("rworker").objects.length<=10){
    
        const rbases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
        for (let base of rbases) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen håller på att bygga något redan
            if (base.buildQueue.length > 0) break;

            // Exempel: träna rguard om resurser finns
            const unitToTrain = "rworker"; // kan även vara "rworker"
            const goldCost = 200;
            const woodCost = 100;

            if (rgold >= goldCost && rwood >= woodCost) {
                base.buildQueue.push(unitToTrain);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    }
    const rbar = game.getAllObjectsoftype(game.getobjecttype("rbar"));
    for (let base of rbar) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen håller på att bygga något redan
            if (base.buildQueue.length > 0) break;

            // Exempel: träna rguard om resurser finns
            const unitToTrain = "rguard"; // kan även vara "rworker"
            const goldCost = 300;
            const woodCost = 100;

            if (rgold >= goldCost && rwood >= woodCost) {
                base.buildQueue.push(unitToTrain);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    
    
}
const BUILDING_NAMES = new Set(["base","bar","rbase","rbar"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du använder för input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects();
  for (const o of objs) {
    if (!o.selectable) continue;
    if (o.name === "tree" || o.name === "goldmine") continue;

    // defaultvärden om hälsa saknas
    if (o.maxHealth == null){ o.maxHealth = BUILDING_NAMES.has(o.name) ? 800 : 100;o.health = o.maxHealth;}
    if (o.health == null) o.health = o.maxHealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxHealth));

    // Värld → skärm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // öka svagt med zoom
    const offsetY = -10 * zoom; // ovanför objektet

    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Röd full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Grön nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
  }
}
function handleCombat(attackerType, enemyTypes, damage) {
    const attackers = game.getobjecttype(attackerType).objects;
    for (const unit of attackers) {
        // Kolla alla fiendetyper
        for (const enemyType of enemyTypes) {
            const target = game.collideswith(unit, enemyType, unit.direction);
            if (target) {
                // Om målet inte har health, sätt standardvärde
                target.health -= damage;
                spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" }); // röd
                spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);
                
                if(unit.name=="worker"||unit.name=="rworker"){
                
                    if(unit.animation==0)unit.animation = 3;
                    if(unit.animation==1&&unit.fliped==false)unit.animation = 4;
                    if(unit.animation==2)unit.animation = 5;
                    if(unit.animation==1&&unit.fliped==true)unit.animation = 4;
                }

                if (target.health <= 0) {
                    // Ta bort objektet om health tar slut
                    game.removeobject(game.getobjecttype(enemyType), target);
                }
            }
        }
    }
}
// --- helpers för AI ---
// Vilka räknas som fasta hinder
const SOLID_TYPES = ["tree","goldmine","base","bar","rbase","rbar"];

// Axis-aligned bbox-overlap
function aabbOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
}

// Linje-segment mot AABB (snabb och robust: Liang–Barsky)
function segmentAABB(x0, y0, x1, y1, rx1, ry1, rx2, ry2) {
  const dx = x1 - x0, dy = y1 - y0;
  let t0 = 0, t1 = 1;

  const p = [-dx, dx, -dy, dy];
  const q = [x0 - rx1, rx2 - x0, y0 - ry1, ry2 - y0];

  for (let i = 0; i < 4; i++) {
    if (p[i] === 0) {
      if (q[i] < 0) return false; // parallell & utanför
    } else {
      const r = q[i] / p[i];
      if (p[i] < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else          { if (r < t0) return false; if (r < t1) t1 = r; }
    }
  }
  return true;
}

// Kolla om en rektangel (x,y,w,h) är fri från SOLID_TYPES (med liten marginal)
function freeAtFast(x, y, w, h, inflate = 6) {
  const ax1 = x - inflate/2, ay1 = y - inflate/2;
  const ax2 = ax1 + w + inflate, ay2 = ay1 + h + inflate;

  for (const tn of SOLID_TYPES) {
    const t = game.getobjecttype(tn); if (!t) continue;
    for (const o of t.objects) {
      if (o.ghost) continue;
      const bx1 = o.x, by1 = o.y, bx2 = o.x + o.dimx, by2 = o.y + o.dimy;
      if (aabbOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)) return false;
    }
  }
  return true;
}

// LOS-block? (linje mitt→mitt mot SOLID AABB)
function losBlockedFast(A, B, unit, inflate = 4) {
  for (const tn of SOLID_TYPES) {
    const t = game.getobjecttype(tn); if (!t) continue;
    for (const o of t.objects) {
      if (o.ghost) continue;
      const rx1 = o.x - inflate, ry1 = o.y - inflate;
      const rx2 = o.x + o.dimx + inflate, ry2 = o.y + o.dimy + inflate;
      if (segmentAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
    }
  }
  return false;
}

function C(o){ return {x:o.x + o.dimx/2, y:o.y + o.dimy/2}; }
function alive(o){ return !!o && game.getAllObjects().includes(o); }


function updateRedGuardAI() {
  // ---------- Tunables ----------
  const CLEARANCE = 10;      // hinder känns tjockare (LOS + grid-block)
  const CELL      = 24;      // rutnätsstorlek (px)
  const PAD       = 240;     // hur mycket område runt G↔T vi rasteriserar
  const REPATH_MS = 18;      // frames mellan ev. auto-repath
  const NEAR_WP   = 12;      // när waypoint räknas nådd
  const STUCK_FR  = 30;      // frames stilla ⇒ repath

  const SOLIDS = ["tree","goldmine","base","bar","rbase","rbar","rworker"];

  // ---------- Helpers ----------
  const C = (o) => ({ x: o.x + o.dimx/2, y: o.y + o.dimy/2 });
  const alive = (o) => !!o && game.getAllObjects().includes(o);

  // samla solider en gång per uppdatering
  const solids = [];
  for (const n of SOLIDS) {
    const t = game.getobjecttype(n);
    if (!t) continue;
    for (const o of t.objects) if (!o.ghost) solids.push(o);
  }

  function aabbOverlap(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2){
    return ax1<bx2 && ax2>bx1 && ay1<by2 && ay2>by1;
  }
function freeAtRect(x,y,w,h,inflate=0, excludeObject=null){ // excludeObject parameter is crucial
  const ax1=x-inflate, ay1=y-inflate, ax2=x+w+inflate, ay2=y+h+inflate;
  for(const o of solids){
    if(o === excludeObject) continue; // Skip the object that is the target
    const bx1=o.x, by1=o.y, bx2=o.x+o.dimx, by2=o.y+o.dimy;
    if(aabbOverlap(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2)) return false;
  }
  return true;
}
  function segAABB(x0,y0,x1,y1, rx1,ry1,rx2,ry2){
    const dx=x1-x0, dy=y1-y0;
    let t0=0,t1=1; const p=[-dx,dx,-dy,dy], q=[x0-rx1,rx2-x0,y0-ry1,ry2-y0];
    for(let i=0;i<4;i++){
      if(p[i]===0){ if(q[i]<0) return false; }
      else{ const r=q[i]/p[i];
        if(p[i]<0){ if(r>t1) return false; if(r>t0) t0=r; }
        else      { if(r<t0) return false; if(r<t1) t1=r; }
      }
    }
    return true;
  }
  function losBlocked(A, B, inflate = CLEARANCE) {
  for (const o of solids) {
    const rx1 = o.x - inflate, ry1 = o.y - inflate;
    const rx2 = o.x + o.dimx + inflate, ry2 = o.y + o.dimy + inflate;
    if (segAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
  }
  return false;
}

  // dynamiskt grid (runt G↔T)
function buildGrid(minx, miny, maxx, maxy, targetObject = null) { // Removed inflate parameter
  const w = Math.max(1, Math.ceil((maxx-minx)/CELL));
  const h = Math.max(1, Math.ceil((maxy-miny)/CELL));
  const walk = new Array(w*h).fill(true);

  for (let gy=0; gy<h; gy++) {
    for (let gx=0; gx<w; gx++) {
      const cx = minx + gx*CELL + CELL/2;
      const cy = miny + gy*CELL + CELL/2;
      const x = cx - CELL/2, y = cy - CELL/2;
      // Pass 0 for inflate here, to keep the old grid blocking behavior
      if (!freeAtRect(x, y, CELL, CELL, 0, targetObject)) { // <-- Changed inflate to 0
        walk[gy*w+gx] = false;
      }
    }
  }
  return { w, h, minx, miny, walk };
}
  const toIdx = (gx,gy,w)=>gy*w+gx;

  function worldToGrid(grid, p){
    let gx = Math.floor((p.x - grid.minx)/CELL);
    let gy = Math.floor((p.y - grid.miny)/CELL);
    gx=Math.max(0,Math.min(grid.w-1,gx));
    gy=Math.max(0,Math.min(grid.h-1,gy));
    return {gx,gy};
  }
  function gridToWorld(grid,gx,gy){
    return { x: grid.minx + gx*CELL + CELL/2, y: grid.miny + gy*CELL + CELL/2 };
  }

  // A* (8-neighbors)
  function astar(grid, start, goal){
    const w=grid.w,h=grid.h, walk=grid.walk;
    const sIdx=toIdx(start.gx,start.gy,w), gIdx=toIdx(goal.gx,goal.gy,w);
    const open=[sIdx], came=new Map(), gScore=new Map([[sIdx,0]]);
    const fScore=new Map([[sIdx,heur(start,goal)]]);

    function heur(a,b){ const dx=Math.abs(a.gx-b.gx), dy=Math.abs(a.gy-b.gy);
      return (dx+dy) + (Math.SQRT2-2)*Math.min(dx,dy);
    }
    function lowestF(){
      let best=-1,bv=Infinity;
      for(let i=0;i<open.length;i++){ const idx=open[i]; const v=fScore.get(idx)??Infinity; if(v<bv){bv=v;best=i;} }
      return open.splice(best,1)[0];
    }
    function neighbors(gx,gy){
      const out=[];
      for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){
        if(!ox&&!oy) continue;
        const nx=gx+ox, ny=gy+oy;
        if(nx<0||ny<0||nx>=w||ny>=h) continue;
        if(!walk[toIdx(nx,ny,w)]) continue;
        // valfri: förhindra att skära hörn igenom två block
        if(ox&&oy){
          if(!walk[toIdx(gx,ny,w)] || !walk[toIdx(nx,gy,w)]) continue;
        }
        out.push({gx:nx,gy:ny,cost: (ox&&oy)?Math.SQRT2:1});
      }
      return out;
    }

    while(open.length){
      const curIdx=lowestF();
      if(curIdx===gIdx){
        // rekonstruktion
        const path=[];
        let u=curIdx;
        while(u!==sIdx){ const v=came.get(u); const gx=u%w, gy=(u-gx)/w; path.push({gx,gy}); u=v; }
        path.push({gx:start.gx,gy:start.gy}); path.reverse();
        return path;
      }
      const cgx=curIdx%w, cgy=(curIdx-cgx)/w;
      for(const nb of neighbors(cgx,cgy)){
        const nIdx=toIdx(nb.gx,nb.gy,w);
        const tentative = (gScore.get(curIdx)??Infinity) + nb.cost;
        if(tentative < (gScore.get(nIdx)??Infinity)){
          came.set(nIdx, curIdx);
          gScore.set(nIdx, tentative);
          fScore.set(nIdx, tentative + heur(nb,goal));
          if(!open.includes(nIdx)) open.push(nIdx);
        }
      }
    }
    return null;
  }

  // Path smoothing: ta bort överflödiga punkter med LOS
  function smoothPath(grid, path, inflate) {
  if (!path || path.length <= 2) return path;
  const out = [path[0]];
  let i = 0;
  while (i < path.length - 1) {
    let j = path.length - 1;
    const Pi = gridToWorld(grid, path[i].gx, path[i].gy);
    for (; j > i + 1; j--) {
      const Pj = gridToWorld(grid, path[j].gx, path[j].gy);
      if (!losBlocked(Pi, Pj, inflate)) break; // <-- använda inflate
    }
    out.push(path[j]);
    i = j;
  }
  return out;
}

  // ---------- AI loop ----------
  const rguards = game.getobjecttype("rguard")?.objects || [];
  const enemyUnits = [
    ...(game.getobjecttype("guard")?.objects || []),
    ...(game.getobjecttype("worker")?.objects || [])
  ];
  const enemyBuilds = [
    ...(game.getobjecttype("base")?.objects || []),
    ...(game.getobjecttype("bar")?.objects || [])
  ];

  for(const g of rguards){
    if(!g.ai) g.ai = { path:null, pi:0, repath:0, stuck:0, _lx:g.x, _ly:g.y };
    g.lockDirection = true;
    g.aiHoldTarget  = true;

    // mål: enheter först
    if(!g.targetObject || !alive(g.targetObject)){
      const pool = enemyUnits.length ? enemyUnits : enemyBuilds;
      if(!pool.length){ g.targetObject=null; continue; }
      const G=C(g); let best=null,bd=Infinity;
      for(const e of pool){ const E=C(e); const d=Math.hypot(E.x-G.x,E.y-G.y); if(d<bd){bd=d;best=e;} }
      g.targetObject=best; g.ai.path=null; g.ai.pi=0; g.ai.repath=0;
    }
    const t=g.targetObject; if(!t) continue;

    const Gc=C(g), Tc=C(t);
    const dx=Tc.x-Gc.x, dy=Tc.y-Gc.y;
    g.direction = Math.abs(dx)>Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up");

    // slå om vi når fram
    if (game.collideswith(g, t.name, g.direction)) {
      const L=Math.hypot(dx,dy)||1, push=(g.speed||1)*0.25;
      g.targetX = g.x + (dx/L)*push;
      g.targetY = g.y + (dy/L)*push;
      g.ai.stuck=0; g.ai._lx=g.x; g.ai._ly=g.y;
      continue;
    }

    // genväg: fri LOS ⇒ skrota path och gå direkt
    if(!losBlocked(Gc,Tc)){
      g.ai.path=null; g.ai.pi=0; g.ai.repath=0;
      g.targetX = Tc.x - g.dimx/2;
      g.targetY = Tc.y - g.dimy/2;
    }else{
      // behöver path?
      if(!g.ai.path || g.ai.repath<=0){
        // skapa litet grid runt G↔T
        // skapa litet grid runt G↔T
        const minx=Math.min(Gc.x,Tc.x)-PAD, miny=Math.min(Gc.y,Tc.y)-PAD;
        const maxx=Math.max(Gc.x,Tc.x)+PAD, maxy=Math.max(Gc.y,Tc.y)+PAD;
        // Pass only the target object 't', no inflate parameter
        const grid=buildGrid(minx,miny,maxx,maxy, t); // <-- Removed CLEARANCE here
        const s=worldToGrid(grid,Gc), goal=worldToGrid(grid,Tc);

        const raw = astar(grid,s,goal);
        if(raw){
          const sm = smoothPath(grid, raw);
          // konvertera till världspunkter
          g.ai.path = sm.map(p => gridToWorld(grid,p.gx,p.gy));
          // första punkten är nära G själv → börja på nästa
          if(g.ai.path.length>1) g.ai.pi=1; else g.ai.pi=0;
        }else{
          g.ai.path=null; g.ai.pi=0; // inget hittades: försök igen snart
        }
        g.ai.repath = REPATH_MS;
      }else{
        g.ai.repath--;
      }

      // följ path
      if(g.ai.path && g.ai.pi < g.ai.path.length){
        const wp = g.ai.path[g.ai.pi];
        // waypoint nådd?
        if(Math.hypot(Gc.x-wp.x,Gc.y-wp.y) < NEAR_WP){
          g.ai.pi++;
        }
      }

      const goal = (g.ai.path && g.ai.pi < g.ai.path.length) ? g.ai.path[g.ai.pi] : Tc;
      g.targetX = goal.x - g.dimx/2;
      g.targetY = goal.y - g.dimy/2;
    }

    // enkel stuck-detektion ⇒ repath
    const moved = Math.hypot(g.x - g.ai._lx, g.y - g.ai._ly);
    if(moved < 0.3) g.ai.stuck++; else g.ai.stuck=0;
    g.ai._lx=g.x; g.ai._ly=g.y;
    if(g.ai.stuck > STUCK_FR){ g.ai.repath = 0; g.ai.stuck = 0; } // tvinga snabb repath
  }
}
function showEndScreen(result, statsText="") {
  const box = document.getElementById("end-screen");
  const title = document.getElementById("end-title");
  const sub = document.getElementById("end-sub");
  sub.style.whiteSpace = "pre-line";
  sub.textContent = statsText;

  if (result === "win") {
    title.textContent = "Du vann! 🎉";
    sub.textContent = statsText || "Fienden är besegrad.";
  } else {
    title.textContent = "Du förlorade 💀";
    sub.textContent = statsText || "Bättre lycka nästa gång.";
  }
  box.style.display = "flex";
}


function checkWinLose() {
  if (gameOver) return;

  // Hämta typer (säkrar mot null)
  const _g  = game.getobjecttype("guard")    || {objects:[]};
  const _w  = game.getobjecttype("worker")   || {objects:[]};
  const _b  = game.getobjecttype("base")     || {objects:[]};
  const _ba = game.getobjecttype("bar")      || {objects:[]};

  const _rg = game.getobjecttype("rguard")   || {objects:[]};
  const _rw = game.getobjecttype("rworker")  || {objects:[]};
  const _rb = game.getobjecttype("rbase")    || {objects:[]};
  const _rba= game.getobjecttype("rbar")     || {objects:[]};

  // Räkna endast “färdiga” byggnader (animation==1 i din kod betyder klar)
  const playerBasesAlive   = _b.objects.filter(o => !o.ghost && o.animation===1).length;
  const playerBarrsAlive   = _ba.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBasesAlive    = _rb.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBarrsAlive    = _rba.objects.filter(o => !o.ghost && o.animation===1).length;

  const playerUnitsAlive   = _g.objects.length + _w.objects.length;
  const enemyUnitsAlive    = _rg.objects.length + _rw.objects.length;

// VINST
if (enemyBasesAlive===0 && enemyBarrsAlive===0 && enemyUnitsAlive===0) {
  gameOver = true;
  showEndScreen(
    "win",
    `Dina resurser – Guld: ${gold} · Trä: ${wood}\nFiendens resurser – Guld: ${rgold} · Trä: ${rwood}`
  );
  return;
}

// FÖRLUST
if (playerBasesAlive===0 && playerBarrsAlive===0 && playerUnitsAlive===0) {
  gameOver = true;
  showEndScreen(
    "lose",
    `Fiendens resurser – Guld: ${rgold} · Trä: ${rwood}\nDina resurser – Guld: ${gold} · Trä: ${wood}`
  );
  return;
}
}

function updateArcherShooting(archerTypeName, enemyTypeNames) {
  const archers = game.getobjecttype(archerTypeName)?.objects || [];
  for (const a of archers) {
    a.attackRange    = a.attackRange ?? 450;  // px
    a.attackCooldown = a.attackCooldown ?? 900; // ms
    a.lastShotTime   = a.lastShotTime ?? 0;

    // Hitta närmaste fiende inom range & line-of-sight
    let best=null, bd=Infinity;
    for (const et of enemyTypeNames) {
      const list = game.getobjecttype(et)?.objects || [];
      for (const e of list) {
        const dx=(a.x + a.dimx/2) - (e.x + e.dimx/2);
        const dy=(a.y + a.dimy/2) - (e.y + e.dimy/2);
        const d=Math.hypot(dx,dy);
        if (d < a.attackRange && d < bd) {
          // valfritt LOS: undvik att skjuta igenom väggar/byggnader
          const A = {x:a.x+a.dimx/2, y:a.y+a.dimy/2}, B = {x:e.x+e.dimx/2, y:e.y+e.dimy/2};
          if (!losBlockedFast(A, B, a, 6)) { // du har redan losBlockedFast() definierad
            bd=d; best=e;
          }
        }
      }
    }

    if (!best) continue;

    // cooldown?
    const now = performance.now();
    if (now - a.lastShotTime < a.attackCooldown) continue;
    a.lastShotTime = now;

    // Skapa pil
    const arrowType = game.getobjecttype("arrow");
    const sx = a.x + a.dimx/2, sy = a.y + a.dimy/2;
    const obj = game.addobject(
      arrowType,
      sx, sy,
      arrowType.standarddimx, arrowType.standarddimy,
      0, false // rot sätts nedan
    );
    obj.speed  = 9;         // px/frame
    obj.damage = 5;         // skada vid träff
    obj.ttl    = 120;       // lever max ~2 sek @60fps
    obj.target = best;

    // init riktning/rotation (bilden pekar åt höger)
    const dx=(best.x+best.dimx/2)-sx, dy=(best.y+best.dimy/2)-sy;
    const ang = Math.atan2(dy, dx);      // radianer
    obj.vx = Math.cos(ang) * obj.speed;
    obj.vy = Math.sin(ang) * obj.speed;
    obj.rot = (ang * 180 / Math.PI);                        // många engines använder .rot            
  }
}

function updateArrows(){
  const arrowType = game.getobjecttype("arrow");
  if (!arrowType) return;
  const arr = [...arrowType.objects]; // kopia om vi tar bort under iteration

  function hitTest(a, t){
    // enkel AABB
    return a.x < t.x + t.dimx && a.x + a.dimx > t.x &&
           a.y < t.y + t.dimy && a.y + a.dimy > t.y;
  }

  for (const p of arr) {
    // livstid
    if ((p.ttl = (p.ttl ?? 120) - 1) <= 0) { game.removeobject(arrowType, p); continue; }
    // mål dött?
    if (!p.target || !game.getAllObjects().includes(p.target)) { game.removeobject(arrowType, p); continue; }

    // styr lite mot rörligt mål (svag homing gör det snällare)
    const tx = p.target.x + p.target.dimx/2;
    const ty = p.target.y + p.target.dimy/2;
    const dx = tx - (p.x + p.dimx/2);
    const dy = ty - (p.y + p.dimy/2);
    const ang = Math.atan2(dy, dx);
    const spd = p.speed ?? 9;

    p.vx = Math.cos(ang) * spd;
    p.vy = Math.sin(ang) * spd;

    // flytta
    p.x += p.vx;
    p.y += p.vy;

    // rotera sprite till flygriktning (din pil pekar höger)
    p.rot =(ang * 180 / Math.PI);

    // träff?
    if (hitTest(p, p.target)) {
      const tgt = p.target;
      if (tgt.maxHealth == null){ // samma default som övriga
        tgt.maxHealth = (new Set(["base","bar","rbase","rbar"]).has(tgt.name)) ? 800 : 100;
        tgt.health = tgt.maxHealth;
      }
      tgt.health -= (p.damage ?? 5);

      // effekter
      spawnDamageNumber(-(p.damage ?? 5), tgt.x, tgt.y, { color: "#ffd166" });
      spawnHitParticles(tx, ty, 6);

      // dö?
      if (tgt.health <= 0) {
        game.removeobject(game.getobjecttype(tgt.name), tgt);
      }
      // ta bort pilen
      game.removeobject(arrowType, p);
    }
  }
}
function toG4Deg(rad){
  const deg = rad * 180 / Math.PI;   // 0° = höger, +90° = ner (canvas)
  // Gör om till Game4: 0° = upp, 90° = vänster, 180° = ner, 270° = höger
  return (450 - deg) % 360;           // samma som ((-deg) - 90 + 360) % 360
}
        </script>
    </body>
</html>
