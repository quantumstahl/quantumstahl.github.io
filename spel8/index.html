
<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/guarddown1.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game4.js"></script>
        
        
        
        
    </head>
    <body>
        
        
        <div id="build-ui" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">
  <button id="build-base-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkgreen;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Bygg bas</button>
  <button id="build-barracks-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: darkred;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* <-- GÖMD TILLS VIDARE */
">
  Bygg barack
  <button id="build-house-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: saddlebrown;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* visas när bas är klar */
">
  Bygg hus

  
  
  
</button>
  
  
</div>
        
<div id="build-ui2" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-worker-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna arbetare</button>
 
  
</div>        
<div id="build-ui3" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-warrior-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna krigare</button>
 
  
</div>            

<div id="end-screen" style="
  position:fixed; inset:0; display:none; 
  align-items:center; justify-content:center; 
  background:rgba(0,0,0,0.8); z-index:2000; color:#fff; font-family:sans-serif;">
  <div style="text-align:center;">
    <div id="end-title" style="font-size:64px; font-weight:800; margin-bottom:16px;"></div>
    <div id="end-sub" style="font-size:22px; opacity:0.85; margin-bottom:28px; white-space:pre-line;"></div>
    <button id="btn-restart" style="
      font-size:18px; padding:12px 20px; border:0; border-radius:10px; 
      background:linear-gradient(180deg,#48bb78,#2f855a); color:#fff; cursor:pointer;">
      Spela igen
    </button>
  </div>
</div>

<div id="place-hint" style="
  position:fixed; bottom:84px; left:0; right:0; text-align:center;
  color:#fff; font:600 36px/1.2 system-ui, sans-serif;
  text-shadow:0 1px 2px rgba(0,0,0,.6); display:none; z-index:1200;">
  Tryck på kartan för att placera
</div>

<div id="hint-pan" style="
  position:fixed; bottom:50%; left:50%; transform:translate(-50%, 50%);
  background:rgba(0,0,0,0.6);
  color:#fff; padding:6px 10px;
  border-radius:6px;
  font:600 50px system-ui, sans-serif;
  text-align:center;
  z-index:2000;
  display:none;">
</div>





        
<div id="resourceUI" style="position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; font-family: sans-serif; font-size: 50px; z-index: 100;">
    <img src="images/gold.png" style="width:50px; vertical-align: middle;">Guld: <span id="goldCount">0</span><br>
    <img src="images/wood.png" style="width:50px; vertical-align: middle;">Trä: <span id="woodCount">0</span><br>
    <img src="images/husikon.png" style="width:50px; vertical-align: middle;">Pop: <span id="popCount">0/0</span>
</div>   
  
        
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
        
        <script>

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

            game = new Game4("Spelet");
            var audio = new Audio('sounds/war3.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
            window.allowSelection = function() {
                return !buildMode; // tillåt bara selektion när man inte bygger
            };
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
                    
                      if (buildMode && ghostBuilding) {
                        const t = e.touches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        const gx = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        const gy = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        ghostBuilding.x = gx;
                        ghostBuilding.y = gy;
                        lastTouchPos = {x: gx, y: gy};
                      }
                    if (buildMode && !fromUI(e.target)) {
                        buildArmed = true; // nu får man placera
                      }
                    
                    
                    
            });
            
            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/war3.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
              }
          });

           
            
            
            let keysPressed = {};
                document.addEventListener('click', (event) => {
        
               
                try{if(audio.paused){ 
                        audio.play();
                    }
                }catch(error){};
             });

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            document.addEventListener("keydown", function(e) {
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
            });
            let buildMode = false;
            let buildType = null;
            let ghostBuilding = null;
            let pendingBuilds = [];
            let selectedWorkersBeforeBuild = [];
            let selectedWorkers = [];
            let lastTouchPos = null;
            let gold = 600;
            let wood = 500;
            let rgold = 600;
            let rwood = 500;
            let gameOver = false;
            let buildArmed = false;
            let popUsed = 0, popCap = 0;
            let rpopUsed = 0, rpopCap = 0;
            let RED_ATTACK_ACTIVE = false;
            let RED_PHASE = "gather";      // "gather" | "exit" | "attack"
            let RED_GROUP = null; 
            let CELL=24;
            const solids = ["tree","goldmine","base","bar","rbase","rbar","rworker"];

            const POP_COST = {
              worker: 1, guard: 1, archer: 1,
              rworker: 1, rguard: 1, rarcher: 1
            };
            
            
            function mobileAndTabletCheck() {const isMobile = {Android: function() {return navigator.userAgent.match(/Android/i);},BlackBerry: function() {return navigator.userAgent.match(/BlackBerry/i);},iOS: function() {return navigator.userAgent.match(/iPhone|iPod/i);},Opera: function() {return navigator.userAgent.match(/Opera Mini/i);},Windows: function() {return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);},any: function() {return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));}};return isMobile.any();}
            const IS_TOUCH = mobileAndTabletCheck();

            function clearSelection() {
              const all = game.getAllObjects();
              for (const o of all) o.selected = false;
            }
            function fromUI(evtTarget){
                return !!(evtTarget && evtTarget.closest &&
                  evtTarget.closest('#build-ui, #build-ui2, #build-ui3, button'));
              }
            function setBuildUIActive(on) {
                
                const hint = document.getElementById("place-hint");
                if (hint) hint.style.display = on ? "block" : "none";
                
                const btn = document.getElementById(buildType === "base" ? "build-base-btn" : "build-barracks-btn");
                if (!btn) return;
                btn.style.outline = on ? "3px solid gold" : "none";
                btn.style.boxShadow = on ? "0 0 12px gold" : "none";
              }  
            function showPanHint(){
                const el = document.getElementById("hint-pan");
                if (el) {
                  el.innerText = IS_TOUCH
                    ? "Använd två fingrar för att flytta kartan"
                    : "Använd W A S D för att flytta kartan";
                  el.style.display = "block";
                  setTimeout(()=> el.style.display = "none", 3000);
                }
            } 
              
            document.getElementById("btn-restart").addEventListener("click", () => {
                // enklaste reset: ladda om
                location.reload();
              });
            
            
            document.getElementById("build-base-btn").innerHTML = "Bygg bas<br>500 guld / 500 trä";
            document.getElementById("build-barracks-btn").innerHTML = "Bygg barrack<br>250 guld / 250 trä";
            document.getElementById("build-house-btn").innerHTML = "Bygg hus<br>100 trä";
            document.getElementById("train-worker-btn").innerHTML = "Träna arbetare<br>50 guld";
            document.getElementById("train-warrior-btn").innerHTML = "Träna warrior<br>150 guld";
            document.getElementById("build-base-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=500&&wood>=500){gold-=500;wood-=500;}    
                else return;    
                buildMode = true;
                buildType = "base";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("base"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("build-barracks-btn").addEventListener("click", function() {
                if(ghostBuilding)ghostBuilding.animation=2;
                if(gold>=250&&wood>=250){gold-=250;wood-=250;}    
                else return;    
                buildMode = true;
                buildType = "bar";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("bar"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
                ghostBuilding.animation=2;
                setBuildUIActive(true);
                
            });
            document.getElementById("build-house-btn").addEventListener("click", function() {
                    if (ghostBuilding) ghostBuilding.animation = 2;

                    // Kräver färdig base
                    const haveReadyBase = game.getAllObjectsoftype(game.getobjecttype("base"))
                                             .some(b => b.animation === 1 && !b.ghost);
                    if (!haveReadyBase) return;

                    // Kostnad
                    if (wood >= 100) {wood -= 100; }
                    else return;

                    buildMode = true;
                    buildType = "house";

                    selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected);
                    game.getAllObjects().forEach(o => { if (!selectedWorkersBeforeBuild.includes(o)) o.selected = false; });

                    // Ghost
                    const t = game.getobjecttype("house");
                    ghostBuilding = game.addobject(t, 0, 0, t.standarddimx || 100, t.standarddimy || 100, 0, false);
                    ghostBuilding.ghost = true;
                    ghostBuilding.selectable = false;
                    ghostBuilding.animation = 2; // bygg-ghost
                    setBuildUIActive(true);
                  });
            
            
            document.getElementById("train-worker-btn").addEventListener("click", () => {
                const base = game.getAllObjectsoftype(game.getobjecttype("base")).find(b => b.selected);
                if (!base) return;
                if (!canAddUnitToPopQueue("worker")) return;
                if (gold >= 50) {
                    gold -= 50;

                    base.buildQueue = base.buildQueue || [];
                    base.buildQueue.push("worker");
                } else {
                   
                }
            });    
            document.getElementById("train-warrior-btn").addEventListener("click", () => {
                const bar = game.getAllObjectsoftype(game.getobjecttype("bar")).find(b => b.selected);
                if (!bar) return;
                if (!canAddUnitToPopQueue("guard")) return;
                if (gold >= 150) {
                    gold -= 150;

                    bar.buildQueue = bar.buildQueue || [];
                    bar.buildQueue.push("guard");
                } else {
                   
                }
            }); 
            
            
            document.addEventListener("touchmove", function(e) {
                                if (e.target.closest("#build-ui")) {return;}
                                 if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;}
                if (e.touches.length >= 2 && buildMode) {
                    cancelBuildMode();
                    return;
                }
                
                
    
              if (buildMode && ghostBuilding) {
    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
    let touch = e.touches[0];
    lastTouchPos = {
        x: touch.clientX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2,
        y: touch.clientY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2
    };
    ghostBuilding.x = lastTouchPos.x;
    ghostBuilding.y = lastTouchPos.y;
    ghostBuilding.animation=0;
    isPlacingBuilding = true;
}
            
            
            });
            
            document.addEventListener("touchend", function(e) {
				selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
				
							if(w.counter2>10){
                            if(w.workobject)w.workobject.occupied=false;                                
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
							}
                        }
                
                
                 if(ghostBuilding!=null&&isBuildPlacementValid(ghostBuilding)==false){return;}
        
                if (buildMode && ghostBuilding) {
                    
                    if (fromUI(e.target) || !buildArmed){ghostBuilding.animation=2; return;} // <-- inga “dubbeltryck på knappen”-placeringar
                    buildArmed = false; // kräver nytt tryck på kartan för nästa bygge
  
                    
                    
                    
                    if (lastTouchPos == null) {
                        const t = e.changedTouches[0];
                        const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                        ghostBuilding.x = t.clientX / zoom - game.maps[game.currentmap].camerax - ghostBuilding.dimx/2;
                        ghostBuilding.y = t.clientY / zoom - game.maps[game.currentmap].cameray - ghostBuilding.dimy/2;
                        
                    }

                      if (isBuildPlacementValid(ghostBuilding) === false) return;

                    
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    isPlacingBuilding = false;
                    ghostBuilding.iscontrollable=true;
                    ghostBuilding.animation=0;
                    ghostBuilding.health=1;
                    setBuildUIActive(false);
                    
                    
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {
                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        clearSelection();
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
                
                
                
                
                
                
                
                
                
                
            });
            
            document.addEventListener("contextmenu", function(e) {
                e.preventDefault(); // förhindra browserns meny
                
                
                if (buildMode) {
            
                    cancelBuildMode();
                }
            });

            
            document.addEventListener("mousemove", function(e) {
                cursorX = e.clientX;
                cursorY = e.clientY;
                lastTouchPos = null; // ← detta säger "vi är i PC-läge"
                ghostBuilding.animation=0;
            });
            document.addEventListener("mousedown", function(e) {
                selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
                            if(w.workobject)w.workobject.occupied=false;
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
                            
                        }
                
                
                if(isBuildPlacementValid(ghostBuilding)==false)return;
                
                if (fromUI(e.target)) return;   // ignorera klick i UI
                if (buildMode) buildArmed = true;
                
                
                
                if (e.button === 2 && buildMode) {
                    e.preventDefault(); // hindra fokus/kontext
                    return; // inget mer körs
                }
                
                
                if (buildMode && ghostBuilding) {
                    const currentMap = game.maps[game.currentmap];
                    const x = ghostBuilding.x;
                    const y = ghostBuilding.y;

                    if (!buildArmed) return;      // inte armat → ingen placering
                    // commit bygget (din befintliga kod)
                    buildArmed = false;  
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    ghostBuilding.iscontrollable=true;
                    setBuildUIActive(false);
                    ghostBuilding.health=1;
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {

                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
            });
            
            let inputClick = null;  // world-coords för senaste klick/tap

            function toWorldCoords(clientX, clientY){
              const zoom = 1 + (1 * game.maps[game.currentmap].zoom / 100);
              return {
                x: clientX/zoom - game.maps[game.currentmap].camerax,
                y: clientY/zoom - game.maps[game.currentmap].cameray
              };
            }

            document.addEventListener('mousedown', (e) => {
              inputClick = toWorldCoords(e.clientX, e.clientY);
            });

            document.addEventListener('touchend', (e) => {
              const t = e.changedTouches[0];
              inputClick = toWorldCoords(t.clientX, t.clientY);
            });
            function pointInObj(px, py, o){
                return px >= o.x && px <= o.x + o.dimx && py >= o.y && py <= o.y + o.dimy;
              }
            function pressedThisFrame(o){
              if (o.mousepressed) return true;                 // desktop
              if (inputClick && pointInObj(inputClick.x, inputClick.y, o)) return true; // mobil/desktop
              return false;
            }
            function consumeInputClick(){ inputClick = null; }
            
             showPanHint();
             var check = function(){
                 
                
                 
                canvas.width=document.body.clientWidth;
                canvas.height=document.body.clientHeight-8;
                 
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
                
                const camSpeed = 15;
                const currentMap = game.maps[game.currentmap];

                if (keyState.w) currentMap.cameray += camSpeed;
                if (keyState.s) currentMap.cameray -= camSpeed;
                if (keyState.a) currentMap.camerax += camSpeed;
                if (keyState.d) currentMap.camerax -= camSpeed;
                
                recalcPopulation();
                document.getElementById("goldCount").textContent = gold;
                document.getElementById("woodCount").textContent = wood;
                document.getElementById("popCount").textContent  = `${popUsed}/${popCap}`;
                
                
                let anyWorkerSelected = false;
                if (game.maps.length > 0) {
                    const workers = game.getobjecttype("worker");
                    if (workers) {
                        anyWorkerSelected = workers.objects.some(o => o.selected);
                    }
                }
                document.getElementById("build-ui").style.display = anyWorkerSelected ? "flex" : "none";
                
                
                game.updateanimation(ctx);
                drawHealthBars();
		gras= game.getobjecttype("ground"); 				
                guard =game.getobjecttype("guard"); 
                worker =game.getobjecttype("worker"); 
                tree =game.getobjecttype("tree"); 
                goldmine =game.getobjecttype("goldmine"); 
                base=game.getobjecttype("base"); 
                archer=game.getobjecttype("archer"); 
                house=game.getobjecttype("house");
                
                //ENEMYS
                rbar =game.getobjecttype("rbar"); 
                rbase =game.getobjecttype("rbase"); 
                rguard =game.getobjecttype("rguard"); 
                rworker =game.getobjecttype("rworker"); 
                rarcher=game.getobjecttype("rarcher"); 
                rhouse=game.getobjecttype("rhouse");
                
                //projectiles
                arrow =game.getobjecttype("arrow"); 
                
                if (buildMode && ghostBuilding&& lastTouchPos === null) {
                    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                    ghostBuilding.x = cursorX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2;
                    ghostBuilding.y = cursorY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2;
                }
                
                
                
                
                
                
                
                
                if(guard!=null){
                    
                    // Vilka av dina enheter ska lyda ordern?
                    const selectedUnits = [
                      ...game.getAllObjectsoftype(game.getobjecttype("guard")).filter(u => u.selected),
                      ...game.getAllObjectsoftype(game.getobjecttype("worker")).filter(u => u.selected),
                    ];

                    function orderFollow(target) {
                      for (const u of selectedUnits) {
                        u.followTarget = true;         // flagga för “håll fast vid målet”
                        u.targetObject = target;       // <- viktigt
                        u.workobject = null;           // släpp ev. jobb
                        u.deliveryTarget = null;
                        u.returning = false;
                        u.lockDirection = false;       // vi vill kunna svänga efter målet

                        const cx = target.x + target.dimx/2;
                        const cy = target.y + target.dimy/2;
                        u.targetX = cx - u.dimx/2;     // initial chase så de börjar gå direkt
                        u.targetY = cy - u.dimy/2;
                      }
                    }

                    // Kolla klick på fiender (enheter + byggnader)
                    let enemyClicked = null;
                    for (const e of (game.getobjecttype("rguard")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rworker")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbase")?.objects  || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rbar")?.objects   || [])) if (pressedThisFrame(e))  { enemyClicked = e; break; }
                    if (!enemyClicked) for (const e of (game.getobjecttype("rhouse")?.objects || [])) if (pressedThisFrame(e)) { enemyClicked = e; break; }
                    if (enemyClicked && selectedUnits.length) {
                      orderFollow(enemyClicked);
                      if (IS_TOUCH) clearSelection();
                    }
                    
                    
                    function isAlive(o){
                        return !!o && !o.ghost && game.getAllObjects().includes(o);
                      }

                      // Alla dina guards + workers ska “jaga” sitt target om followTarget=true
                      const myUnits = [
                        ...game.getobjecttype("guard")?.objects || [],
                        ...game.getobjecttype("worker")?.objects || [],
                      ];

                      for (const u of myUnits) {
                        if (u.followTarget && u.targetObject) {
                          if (!isAlive(u.targetObject)) {
                            // målet dog/försvann → släpp
                            u.followTarget = false;
                            u.targetObject = null;
                            continue;
                          }
                          const t = u.targetObject;
                          const cx = t.x + t.dimx/2;
                          const cy = t.y + t.dimy/2;
                          u.targetX = cx - u.dimx/2;   // uppdatera mot målets nuvarande position
                          u.targetY = cy - u.dimy/2;
                        }
                      }
                    
                    
                    
                    
                    
                    
                    
                    
                    const anyBaseSelected = game.getAllObjectsoftype(game.getobjecttype("base")).some(o => o.selected);
                    document.getElementById("build-ui2").style.display = anyBaseSelected ? "flex" : "none";
                    
                    const anyBarSelected = game.getAllObjectsoftype(game.getobjecttype("bar")).some(o => o.selected);
                    document.getElementById("build-ui3").style.display = anyBarSelected ? "flex" : "none";
                    
                    
                    const canAffordBase = gold >= 500 && wood >= 500;
                    const canAffordWorker = gold >= 50 && wood >= 0;
                    const canAffordWarrior = gold >= 150 && wood >= 0;
                    
                    const hasPopForWorker  = canAddUnitToPopQueue("worker");
                    const hasPopForWarrior = canAddUnitToPopQueue("guard");
                    
                    const canAffordBar = gold >= 250 && wood >= 250;
                    const canAffordHouse = wood >= 100;
                    document.getElementById("build-house-btn").style.opacity = canAffordHouse ? "1" : "0.5";
                    document.getElementById("build-base-btn").style.opacity = canAffordBase ? "1" : "0.5";
                    document.getElementById("train-worker-btn").style.opacity = (canAffordWorker  && hasPopForWorker) ? "1" : "0.5";
                    document.getElementById("train-warrior-btn").style.opacity = (canAffordWarrior && hasPopForWarrior) ? "1" : "0.5";
                    document.getElementById("build-barracks-btn").style.opacity = canAffordBar ? "1" : "0.5";
                    
                    if (base.objects.length>0&&base.objects[0].animation==1) {
                        document.getElementById("build-barracks-btn").style.display = "inline-block";
                        document.getElementById("build-house-btn").style.display = "inline-block";
                    }

                    
                  
                    selectedWorkers = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                    
                    const basesAndBars = [
                        ...game.getAllObjectsoftype(game.getobjecttype("base")),
                        ...game.getAllObjectsoftype(game.getobjecttype("bar")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbase")),
                        ...game.getAllObjectsoftype(game.getobjecttype("rbar")),
                    ];

                    for (let base of basesAndBars) {
                        if(base.animation==0)break;
                        
                        base.buildQueue = base.buildQueue || [];
                        base.buildTimer = base.buildTimer || 0;

                        if (base.buildQueue.length > 0) {
                            if (!canAddUnitToPopQueue(base.buildQueue[0])) {continue ;}   
                            
                            base.buildTimer++;

                            // så länge vi hinner producera
                            while (base.buildQueue.length > 0 && base.buildTimer >= 1000) {
                                const unitType = game.getobjecttype(base.buildQueue[0]);
                                  
                                const spacing = 100;
                                const directions = [
                                    [spacing, 0], [-spacing, 0], [0, spacing], [0, -spacing],
                                    [spacing, spacing], [-spacing, -spacing], [spacing, -spacing], [-spacing, spacing]
                                ];

                                let placed = false;

                                for (let [dx, dy] of directions) {
                                    const px = base.x + base.dimx / 2 + dx;
                                    const py = base.y + base.dimy / 2 + dy;

                                    const newUnit = game.addobject(
                                        unitType,
                                        px,
                                        py,
                                        unitType.standarddimx,
                                        unitType.standarddimy,
                                        0,
                                        false
                                    );

                                    const overlaps = newUnit.collideslist(game.maps, game.currentmap, "any");

                                    if (!overlaps) {
                                        placed = true;
                                        break;
                                    } else {
                                        game.removeobject(unitType, newUnit);
                                    }
                                }

                                if (placed) {
                                    base.buildQueue.shift();
                                    base.buildTimer -= 1000; // 💡 fortsätt direkt om nästa också är klar
                                } else {
                                    // avbryt loopen, försök igen nästa frame
                                    break;
                                }
                            }
                        }
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    for(let i=0;i<goldmine.objects.length;i++){
                    
                        goldmine.objects[i].selectable=true;
                        goldmine.objects[i].canMove=false;
                    
                        if(goldmine.objects[i].mousepressed==true&&anyWorkerSelected){

                            for (let w of selectedWorkers) {

                                w.workobject=goldmine.objects[i];
				w.counter2=0;
                                if (IS_TOUCH) w.selected=false;
                            }
                        }


                    }
                    for(let i=0;i<tree.objects.length;i++){
                    
                        tree.objects[i].selectable=true;
                        tree.objects[i].canMove=false;
                    
                        if(tree.objects[i].mousepressed==true&&anyWorkerSelected){
                             
                             assignWorkersToNearestTreesSmart();
                             if (IS_TOUCH) clearSelection();
                        }


                    }
                    
                    
                    
                    
                    for(let i=0;i<guard.objects.length;i++){

                        guard.objects[i].selectable=true;
                        guard.objects[i].iscontrollable=true;
                        if ( guard.objects[i].direction === "up")  guard.objects[i].animation = 0;
                        else if ( guard.objects[i].direction === "right")  guard.objects[i].animation = 1;
                        else if ( guard.objects[i].direction === "down")  guard.objects[i].animation = 2;
                        else if ( guard.objects[i].direction === "left")  guard.objects[i].animation = 3;
                        
                        

                    }
                     for(let i=0;i<archer.objects.length;i++){

                        archer.objects[i].selectable=true;
                        archer.objects[i].iscontrollable=true;
                        if ( archer.objects[i].direction === "up")  archer.objects[i].animation = 0;
                        else if ( archer.objects[i].direction === "right")  {archer.objects[i].animation = 1;archer.objects[i].fliped=false;}
                        else if ( archer.objects[i].direction === "down")  archer.objects[i].animation = 2;
                        else if ( archer.objects[i].direction === "left") { archer.objects[i].animation = 1;archer.objects[i].fliped=true;}

                    }
                    for(let i=0;i<rarcher.objects.length;i++){

                        rarcher.objects[i].selectable=true;
                        if ( rarcher.objects[i].direction === "up")  rarcher.objects[i].animation = 0;
                        else if ( rarcher.objects[i].direction === "right")  {rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=false;}
                        else if ( rarcher.objects[i].direction === "down")  rarcher.objects[i].animation = 2;
                        else if ( rarcher.objects[i].direction === "left") { rarcher.objects[i].animation = 1;rarcher.objects[i].fliped=true;}
                        
                        

                    }
                    
                    for(let i=0;i<rguard.objects.length;i++){

                        rguard.objects[i].selectable=true;
                        rguard.aiNoLocalAvoid = true; // movement använder mikro-styrning (ovan)
                        rguard.lockDirection  = true; // AI sätter facing för kollisions-attack
                        rguard.aiHoldTarget   = true; // AI släpper själv målet först när det vill

                        if ( rguard.objects[i].direction === "up")  rguard.objects[i].animation = 0;
                        else if ( rguard.objects[i].direction === "right")  rguard.objects[i].animation = 1;
                        else if ( rguard.objects[i].direction === "down")  rguard.objects[i].animation = 2;
                        else if ( rguard.objects[i].direction === "left")  rguard.objects[i].animation = 3;
                        
                        

                    }
             
                    for(let i=0;i<worker.objects.length;i++){

                        worker.objects[i].selectable=true;
			worker.objects[i].counter2++;
                        worker.objects[i].iscontrollable=true;
                        
                        
                        
                        
                        if ( worker.objects[i].direction === "up")  worker.objects[i].animation = 0;
                        else if ( worker.objects[i].direction === "right")  {worker.objects[i].animation = 1;worker.objects[i].fliped=false;}
                        else if ( worker.objects[i].direction === "down")  worker.objects[i].animation = 2;
                        else if ( worker.objects[i].direction === "left") { worker.objects[i].animation = 1;worker.objects[i].fliped=true;}
                        
                        
                         for (let j = 0; j < pendingBuilds.length; j++) {
                            let building = pendingBuilds[j];

                            if (game.collideswithanoterobject(worker.objects[i],building)) {
                                building.buildProgress = (building.buildProgress || 0) + 1;
                                 building.health = Math.max(1, Math.floor((building.buildProgress / 1000) * 800));
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                
                                 // bygg-animation

                                if (building.buildProgress > 1000) {
                                    // Klar – ta bort från pendingBuilds
                                    pendingBuilds.splice(j, 1);
                                    building.buildProgress = null;
                                    worker.objects[i].buildingTarget = null;
                                    worker.objects[i].animation = 0; // idle
                                    building.animation=1;
                                }
                                
                            }
                        }
                        if(worker.objects[i].workobject!=null&&worker.objects[i].returning==false){
                            
                            if(worker.objects[i].workobject.name=="goldmine"){
                                
                                worker.objects[i].targetX = worker.objects[i].workobject.x+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                                
                            }
                            else{
                                worker.objects[i].targetX = worker.objects[i].workobject.x;//+worker.objects[i].workobject.dimx/2;
                                worker.objects[i].targetY = worker.objects[i].workobject.y;//+worker.objects[i].workobject.dimy/2;
                                worker.objects[i].targetObject=worker.objects[i].workobject;
                            }
                            
                        
                            
                            if(worker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(worker.objects[i],"tree");
                                if(oo&&worker.objects[i].workobject!=oo){worker.objects[i].workobject.occupied=false;worker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<1002) {
                                    if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                    if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                    worker.objects[i].counter++;

                                }
                                if (worker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = worker.objects[i].x - b.x;
                                        let dy = worker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        worker.objects[i].targetX = closest.x+closest.dimx/2;
                                        worker.objects[i].targetY = closest.y+closest.dimy/2;
                                        worker.objects[i].targetObject=closest;
                                        worker.objects[i].returning = true; // ny flagga
                                        worker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<202) {
                                    worker.objects[i].animation=100;
                                    worker.objects[i].counter++;

                                }
                                
                            if (worker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = worker.objects[i].x - b.x;
                                    let dy = worker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    worker.objects[i].targetX = closest.x+closest.dimx/2;
                                    worker.objects[i].targetY = closest.y+closest.dimy/2;
                                    worker.objects[i].targetObject=closest;
                                    worker.objects[i].returning = true; // ny flagga
                                    worker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (worker.objects[i].returning && worker.objects[i].deliveryTarget) {
                            
                            
                            if(worker.objects[i].workobject.name!="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 6;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 7;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =8;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 7;
                            }
                            if(worker.objects[i].workobject.name=="tree"){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 9;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 10;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =11;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                worker.objects[i].returning = false;
                                worker.objects[i].deliveryTarget = null;
                                worker.objects[i].counter = 0;
                                worker.objects[i].animation = 0; // idle
                                
                                if(worker.objects[i].workobject.name!="tree")gold += 10;
                                if(worker.objects[i].workobject.name=="tree"){wood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
                    
                    for(let i=0;i<rworker.objects.length;i++){

                        rworker.objects[i].selectable=true;
			rworker.objects[i].counter2++;
                        
                        if ( rworker.objects[i].direction === "up")  rworker.objects[i].animation = 0;
                        else if ( rworker.objects[i].direction === "right")  {rworker.objects[i].animation = 1;rworker.objects[i].fliped=false;}
                        else if ( rworker.objects[i].direction === "down")  rworker.objects[i].animation = 2;
                        else if ( rworker.objects[i].direction === "left") { rworker.objects[i].animation = 1;rworker.objects[i].fliped=true;}
                        
                        
                        
                        if(rworker.objects[i].workobject!=null && rworker.objects[i].workobject.name=="rbase")continue;
                        if(rworker.objects[i].buildobject!=null)continue;
                        
                        
                        
                        
                       
                                

                        if(rworker.objects[i].workobject!=null&&rworker.objects[i].returning==false){
                            
                            if(rworker.objects[i].workobject.name=="goldmine"){
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y;+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                                
                                
                            }
                            else{
                                rworker.objects[i].targetX = rworker.objects[i].workobject.x;//+rworker.objects[i].workobject.dimx/2;
                                rworker.objects[i].targetY = rworker.objects[i].workobject.y;//+rworker.objects[i].workobject.dimy/2;
                                rworker.objects[i].targetObject=rworker.objects[i].workobject;
                            }
                            
                        
                            
                            if(rworker.objects[i].workobject.name=="tree"){
                                
                                
                                let oo=game.collideswiths(rworker.objects[i],"tree");
                                
                                if(oo&&rworker.objects[i].workobject!=oo){rworker.objects[i].workobject.occupied=false;rworker.objects[i].workobject=oo;oo.occupied=true;}
                                
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<1002) {
                                    if(rworker.objects[i].animation==0)rworker.objects[i].animation = 3;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 4;
                                    if(rworker.objects[i].animation==2)rworker.objects[i].animation = 5;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 4;
                                    rworker.objects[i].counter++;

                                }
                                if (rworker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = rworker.objects[i].x - b.x;
                                        let dy = rworker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                        rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                        rworker.objects[i].targetObject=closest;
                                        rworker.objects[i].returning = true; // ny flagga
                                        rworker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<202) {
                                    rworker.objects[i].animation=100;
                                    rworker.objects[i].counter++;

                                }
                                
                            if (rworker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = rworker.objects[i].x - b.x;
                                    let dy = rworker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                    rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                    rworker.objects[i].targetObject=closest;
                                    rworker.objects[i].returning = true; // ny flagga
                                    rworker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (rworker.objects[i].returning && rworker.objects[i].deliveryTarget) {
                            
                            
                            if(rworker.objects[i].workobject.name!="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 6;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 7;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =8;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 7;
                            }
                            if(rworker.objects[i].workobject.name=="tree"){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 9;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 10;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =11;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                rworker.objects[i].returning = false;
                                //rworker.objects[i].deliveryTarget = null;
                                rworker.objects[i].counter = 0;
                                rworker.objects[i].animation = 0; // idle
                                
                                if(rworker.objects[i].workobject.name!="tree")rgold += 10;
                                if(rworker.objects[i].workobject.name=="tree"){rwood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
 
                    
                    enemyTryToBuildBase();
                    enemyTryToBuildBar();
                    enemyTryToBuildHouse();
                    updateRedWorkerAI();
                    updateRedTrainingAI();
                    updateRedGuardAI();
                    
                    
                    
                    handleCombat("guard", ["rguard", "rworker", "rbase", "rbar","rarcher","rhouse"], 0.4);
                    handleCombat("worker", ["rguard", "rworker", "rbase", "rbar","rarcher","rhouse"], 0.1);
                    handleCombat("rguard", ["guard", "worker", "base", "bar","archer","house"], 0.4);
                    handleCombat("rworker", ["guard", "worker", "base", "bar","archer","house"], 0.1);
                    updateArcherShooting("archer", ["rguard","rworker","rarcher","rbase","rbar","rhouse"]);
                    updateArcherShooting("rarcher", ["guard","worker","archer","base","bar","house"]);
                    updateArrows();
                    
                    checkWinLose(); 
                }

                 
                
                window.requestAnimationFrame(check);   
            };check();
            
            function isBuildPlacementValid(o) {
                if(!o)return true;
                if (o.collidestest()) return false;
                
                            // Avståndsgräns från resurser (t.ex. 100 pixlar)
                const minDistanceToResources = 300;
               // var resourceTypes = ["tree", "goldmine","rbase","base","bar","rbar","house","rhouse"]; // eller hur du identifierar resurser
               // if(o.name=="rbar")resourceTypes = ["tree", "goldmine","rbase"];
               var resourceTypes = ["tree", "goldmine","rbase","rbar","rhouse"];
                for (let type of resourceTypes) {
                    const resources = game.getAllObjectsoftype(game.getobjecttype(type));
                    for (let res of resources) {
                        if(o==res)continue;
                        
                        const dist = game.getDistance(o.x, o.y, res.x, res.y);
                        if (dist < minDistanceToResources) {
                            return false; // För nära en resurs
                        }
                    }
                }
                
                
                
                return o.collideslistan.length === 0;
            }
            function cancelBuildMode() {
   
                
                if (ghostBuilding&&ghostBuilding.name=="base") {
                    gold+=1000;wood+=1000;
                    game.removeobject(game.getobjecttype("base"),ghostBuilding); // ⬅️ Viktigt!
                    ghostBuilding = null;
                }
                else if (ghostBuilding&&ghostBuilding.name=="bar") {
                    gold+=500;wood+=500;
                    game.removeobject(game.getobjecttype("bar"),ghostBuilding); // ⬅️ Viktigt!
                    ghostBuilding = null;
                }
                else if (ghostBuilding && ghostBuilding.name == "house") {
                    wood += 100;
                    game.removeobject(game.getobjecttype("house"), ghostBuilding);
                    ghostBuilding = null;
                }
                
                
                setBuildUIActive(false);
                buildMode = false;
                buildType = null;
                selectedWorkersBeforeBuild = [];
                isPlacingBuilding = false;
                console.log("Byggläge avbrutet");
            }
            function assignWorkersToNearestTreesSmart() {
                    const allTrees = game.getAllObjectsoftype(game.getobjecttype("tree"))
                        .filter(t => !t.occupied); // inga distansfilter här

                    const assignedTrees = new Set();

                    for (let w of selectedWorkers) {
                        if(w.workobject!=null)return;
                        
                        let bestTree = null;
                        let bestScore = Infinity;

                        for (let t of allTrees) {
                            if (assignedTrees.has(t)) continue;
                            const distToWorker = getManualDistance(t.x, t.y, w.x, w.y);
                      

                            if (distToWorker < bestScore) {
                                //alert(t.x+" "+ t.y+" "+ w.x+" "+ w.y);
                                
                                bestScore = distToWorker;
                                bestTree = t;
                            }
                        }
                        //alert("NY");
                        if (bestTree) {
                            
                            
                            
                            w.targetX = bestTree.x;// + bestTree.dimx / 2;
                            w.targetY = bestTree.y;// + bestTree.dimy / 2;
                            w.workobject = bestTree;
                            w.returning = false;
                            w.counter2 = 0;
                            bestTree.occupied = true;
                            assignedTrees.add(bestTree);
                        }
                    }
                }
            function getManualDistance(x1, y1, x2, y2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function enemyTryToBuildBar() {
                if(!game.getobjecttype("rworker").objects[0]||!game.getobjecttype("rbase").objects[0]||game.getobjecttype("rbase").objects[0].animation==0)return;
                
                const w = game.getobjecttype("rworker").objects[0];
                const rbaseType = game.getobjecttype("rbar");
                
                
                
                if (w.workobject && w.workobject.name=="rbar") {
                    
                    if (game.collideswithanoterobject(w,w.workobject)) {
                        
                        w.workobject.buildProgress += 1;
                        w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                        if(w.animation==0)w.animation = 3;
                        if(w.animation==1&&w.fliped==false)w.animation = 4;
                        if(w.animation==2)w.animation = 5;
                        if(w.animation==1&&w.fliped==true)w.animation = 4;      
                        
                        if (w.workobject.buildProgress > 1000) {
                            w.workobject.ghost = false;
                            w.workobject.selectable = true;
                            w.workobject.animation=1;
                            w.workobject = null;
                            w.buildobject=null;
                        }
                        
                        
                    }
                    
                }
                if (rwood < 250 || rgold < 250 ||(game.getobjecttype("rbar").objects[0])) return;
                
                const mines = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                if (mines.length === 0) return;
                const mine = mines[0]; // använd första gruvan
                const spacing = 100;
                let bestPos = null;
                let bestScore = Infinity;

                for (let dx = -5; dx <= 5; dx++) {
                    for (let dy = -5; dy <= 5; dy++) {
                        const px = mine.x + dx * spacing;
                        const py = mine.y + dy * spacing;

                        const temp = game.addobject(
                            rbaseType,
                            px,
                            py,
                            rbaseType.standarddimx,
                            rbaseType.standarddimy,
                            0,
                            false

                        );
                        temp.ghost = true;

                        if (isBuildPlacementValid(temp)) {
                            const distToMine = game.getDistance(px, py, mine.x, mine.y);

                            // Hitta närmaste rworker
                            let closestWorkerDist = Infinity;
                         
                                const d = game.getDistance(px, py, w.x, w.y);
                                if (d < closestWorkerDist) closestWorkerDist = d;
                            

                            const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning här

                            if (score < bestScore) {
                                bestScore = score;
                                bestPos = { x: px, y: py };
                            }
                        }

                        game.removeobject(rbaseType, temp);
                    }
                }

                if (bestPos) {
                    const ghost = game.addobject(
                        rbaseType,
                        bestPos.x,
                        bestPos.y,
                        rbaseType.standarddimx,
                        rbaseType.standarddimy,
                        0,
                        false
                    );
                    ghost.ghost = false;
                    ghost.canMove = false;
                    ghost.selectable = false;
                    ghost.enemyBuild = true;
                    ghost.buildProgress = 0;
                    ghost.health=1;
                    w.deliveryTarget=null;
                    w.targetObject=null;
                    w.targetX = bestPos.x;
                    w.targetY = bestPos.y;
                    w.workobject = ghost;
                    w.buildobject=ghost;
                    w.workobject.selectable = true;
                    w.counter2 = 0;
                    

                    rwood -= 250;
                    rgold -= 250;
                }
                
                
                
                
            }
            
            
            function enemyTryToBuildBase() {
                
                  const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
                for (let w of rworkers) {
            
                    if (w.workobject && w.workobject.name=="rbase") {
                        // Börja bygga
                
                        if (game.collideswithanoterobject(w,w.workobject)) {
                            w.workobject.buildProgress += 1;
                            w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                            
                            
                            if(w.animation==0)w.animation = 3;
                                if(w.animation==1&&w.fliped==false)w.animation = 4;
                                if(w.animation==2)w.animation = 5;
                                if(w.animation==1&&w.fliped==true)w.animation = 4;
                            
                            if (w.workobject.buildProgress > 1000) {
                                  w.workobject.ghost = false;
                                  w.workobject.selectable = true;
                                  w.workobject.animation=1;
                                  w.workobject = null;

                            }  
                            
                        }
                        
                        
                        
                        
                        
                        
                        
                    }
                }
                
       if(game.getobjecttype("rbase").objects.length==1)return;         
       if (rwood < 500 || rgold < 500 ) return;
       
    const rbaseType = game.getobjecttype("rbase");

    // Finns redan en bas eller ghost-bygge?
    const baseExists = game.getAllObjects().some(o =>
        o.type === rbaseType && (!o.ghost || o.ghost === true)
    );
    if (baseExists) return;

    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));
    if (mines.length === 0) return;

    if (rworkers.length === 0) return;

    const mine = mines[1]; // använd första gruvan
    const spacing = 100;
    let bestPos = null;
    let bestScore = Infinity;

    for (let dx = -5; dx <= 5; dx++) {
        for (let dy = -5; dy <= 5; dy++) {
            const px = mine.x + dx * spacing;
            const py = mine.y + dy * spacing;

            const temp = game.addobject(
                rbaseType,
                px,
                py,
                rbaseType.standarddimx,
                rbaseType.standarddimy,
                0,
                false
                        
            );
            temp.ghost = true;

            if (isBuildPlacementValid(temp)) {
                const distToMine = game.getDistance(px, py, mine.x, mine.y);

                // Hitta närmaste rworker
                let closestWorkerDist = Infinity;
                for (let w of rworkers) {
                    const d = game.getDistance(px, py, w.x, w.y);
                    if (d < closestWorkerDist) closestWorkerDist = d;
                }

                const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning här

                if (score < bestScore) {
                    bestScore = score;
                    bestPos = { x: px, y: py };
                }
            }

            game.removeobject(rbaseType, temp);
        }
    }

    if (bestPos) {
        const ghost = game.addobject(
            rbaseType,
            bestPos.x,
            bestPos.y,
            rbaseType.standarddimx,
            rbaseType.standarddimy,
            0,
            false
        );
        ghost.ghost = false;
        ghost.canMove = false;
        ghost.selectable = false;
        ghost.enemyBuild = true;
        ghost.buildProgress = 0;
        ghost.health=1;
        ghost.selectable = true;

        for (let w of rworkers) {
            w.targetX = bestPos.x;
            w.targetY = bestPos.y;
            w.workobject = ghost;
            w.counter2 = 0;
            w.deliveryTarget=null;
            w.targetObject=null;
        }

        rwood -= 500;
        rgold -= 500;
    }
}
function updateRedWorkerAI() {
    const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
    const trees = game.getAllObjectsoftype(game.getobjecttype("tree")).filter(t => !t.occupied);
    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));

    let woodWorkers = 0;
    let goldWorkers = 0;

    // Räkna redan tilldelade
    for (let w of rworkers) {
        if (w.workobject) {
            if (w.workobject.name === "tree") woodWorkers++;
            if (w.workobject.name === "goldmine") goldWorkers++;
        }
    }

    // Tilldela nya arbetare
    for (let w of rworkers) {
        if (w.workobject) continue; // hoppa om redan jobbar

        let targetList = null;
        let targetType = "";

        // Fördela 3 av 5 till träd
        if ((woodWorkers * 5) < (rworkers.length * 3) && trees.length > 0) {
            targetList = trees;
            targetType = "tree";
        } else if (mines.length > 0) {
            targetList = mines;
            targetType = "goldmine";
        }
        
           let nearbyTrees = trees.filter(t => 
            game.getDistance(w.x, w.y, t.x, t.y) < 1000
        );

      
        
        
        
        if (targetList) {
            let bestTarget = null;
            let bestDist = Infinity;

            for (let t of targetList) {
                const d = game.getDistance(w.x, w.y, t.x, t.y);
                if (d < bestDist && !t.occupied) {
                    bestDist = d;
                    bestTarget = t;
                }
            }

            if (bestTarget) {
                
                if(targetType=="tree"&&nearbyTrees.length > 0){
                    let tree = nearbyTrees[Math.floor(Math.random() * nearbyTrees.length)];
                    tree.occupied = true;
                    w.workobject = tree;
                    w.targetX = tree.x;
                    w.targetY = tree.y;
                    w.returning = false;
                    w.counter2 = 0;
                    
                }
                else{
                
                    w.targetX = bestTarget.x; //+ bestTarget.dimx / 2;
                    w.targetY = bestTarget.y; //+ bestTarget.dimy / 2;
                    w.workobject = bestTarget;
                    w.returning = false;
                    w.counter2 = 0;
                    if(bestTarget.name=="tree")bestTarget.occupied = true;
                }
                // Uppdatera räknare
                if (targetType === "tree") woodWorkers++;
                else if (targetType === "goldmine") goldWorkers++;
            }
        }
    }
}        
function updateRedTrainingAI() {
    
    
    if(game.getobjecttype("rworker").objects.length<=10){
    
        const rbases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
        for (let base of rbases) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen håller på att bygga något redan
            if (base.buildQueue.length > 0) break;

            // Exempel: träna rguard om resurser finns
            const unitToTrain = "rworker"; // kan även vara "rworker"
            const goldCost = 50;
            const woodCost = 0;

            if (rgold >= goldCost && rwood >= woodCost && canAddUnitToPopQueue("rworker")) {
                base.buildQueue.push(unitToTrain);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    }
    const rbar = game.getAllObjectsoftype(game.getobjecttype("rbar"));
    for (let base of rbar) {
            base.buildQueue = base.buildQueue || [];
            base.buildTimer = base.buildTimer || 0;

            // Skippa om basen håller på att bygga något redan
            if (base.buildQueue.length > 0) break;

            // Exempel: träna rguard om resurser finns
            const unitToTrain = "rguard"; // kan även vara "rworker"
            const goldCost = 150;
            const woodCost = 0;

            if (rgold >= goldCost && rwood >= woodCost && canAddUnitToPopQueue("rguard")) {
                base.buildQueue.push(unitToTrain);
                rgold -= goldCost;
                rwood -= woodCost;
            }
        }
    
    
}
const BUILDING_NAMES = new Set(["base","bar","rbase","rbar","house","rhouse"]); // byggnader
function drawHealthBars() {
    if(!game.maps[game.currentmap])return;
    
  const map = game.maps[game.currentmap];
  const zoom = 1 + (map.zoom / 100); // samma zoom som du använder för input
  const camX = map.camerax;
  const camY = map.cameray;

  const objs = game.getAllObjects();
  for (const o of objs) {
    if (!o.selectable) continue;
    if (o.name === "tree" || o.name === "goldmine") continue;

    // defaultvärden om hälsa saknas
    if (o.maxHealth == null){ o.maxHealth = BUILDING_NAMES.has(o.name) ? 800 : 100;o.health = o.maxHealth;}
    if (o.health == null) o.health = o.maxHealth;

    const hpPct = Math.max(0, Math.min(1, o.health / o.maxHealth));

    // Värld → skärm
    const sx = (o.x + camX) * zoom;
    const sy = (o.y + camY) * zoom;

    const barW = Math.max(20, o.dimx * zoom);  // skala med zoom, ha en min.bredd
    const barH = Math.max(3, 5 * (zoom >= 1 ? zoom : 1)); // öka svagt med zoom
    const offsetY = -10 * zoom; // ovanför objektet

    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Röd full bar
    ctx.fillStyle = "red";
    ctx.fillRect(sx, sy + offsetY, barW, barH);

    // Grön nuvarande HP
    ctx.fillStyle = "lime";
    ctx.fillRect(sx, sy + offsetY, barW * hpPct, barH);

    // Kant
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy + offsetY, barW, barH);
    
    
    // --- Training queue icons (base/bar/rbase/rbar) ---
if ((o.name === "base" || o.name === "bar" || o.name === "rbase" || o.name === "rbar")
    && o.buildQueue && o.buildQueue.length > 0) {

  const pct   = Math.max(0, Math.min(1, (o.buildTimer || 0) / 1000)); // framsteg på första i kön
  const ICON  = Math.max(40, Math.min(22, 18 * (zoom >= 1 ? zoom : 1))); // ikonstorlek
  const PAD   = Math.max(2, 2 * (zoom >= 1 ? zoom : 1));                 // mellanrum
  const q     = o.buildQueue;
  const total = q.length * ICON + (q.length - 1) * PAD;

  // placera ikonerna centrerat ovanför progress/HP-bar
  const y = sy + (offsetY - barH - 6) - ICON; // en rad ovanför progress/HP
  let   x = sx + (barW - total) / 2;

  // valfri: färger per typ
  function colorFor(type) {
    if (type.includes("worker")) return "#efc84a";   // gul
    if (type.includes("archer")) return "#5ac8fa";   // blå
    if (type.includes("guard"))  return "#ef6c6c";   // röd
    return "#9e9e9e";                                // default
  }


  for (let i = 0; i < q.length; i++) {
    const t = q[i];

    // bakgrund/ram
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(x, y, ICON, ICON);

    // fyllning (färg) – ersätt gärna med riktig ikonbild om du vill
    ctx.fillStyle = colorFor(t);
    ctx.fillRect(x + 1, y + 1, ICON - 2, ICON - 2);
    
    
    var typeObj = game.getobjecttype("worker");    // t.ex. "worker"
    if(o.name === "bar")typeObj = game.getobjecttype("guard");  
    if(o.name === "rbase")typeObj = game.getobjecttype("rworker"); 
    if(o.name === "rbar")typeObj = game.getobjecttype("rguard"); 
    
    const img = typeObj.images[0].getimage(); // vad du nu har
    if (img) {
        ctx.drawImage(img, x + 1, y + 1, ICON - 2, ICON - 2);
    }
    
    
    

    // progress-mask på FÖRSTA ikonen
    if (i === 0) {
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(x + ICON * pct, y, ICON * (1 - pct), ICON);
    }
    else{
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(x, y, ICON, ICON);
        
    }


    // ram
    ctx.strokeStyle = "rgba(0,0,0,0.85)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 0.5, y + 0.5, ICON - 1, ICON - 1);
    ctx.restore();

    x += ICON + PAD;
  }
    
    
    
  }
  
        }
  
  
  
}
function handleCombat(attackerType, enemyTypes, damage) {
    const attackers = game.getobjecttype(attackerType).objects;
    for (const unit of attackers) {
        // Kolla alla fiendetyper
        for (const enemyType of enemyTypes) {
            const target = game.collideswith(unit, enemyType, "any");
            if (target) {
                // Om målet inte har health, sätt standardvärde
                target.health -= damage;
                spawnDamageNumber(-damage, unit.x, unit.y, { color: "#ff4d4d" }); // röd
                spawnHitParticles(target.x+target.dimx/2, target.y+target.dimy/2, 6);
                
                if(unit.name=="worker"||unit.name=="rworker"){
                
                    if(unit.animation==0)unit.animation = 3;
                    if(unit.animation==1&&unit.fliped==false)unit.animation = 4;
                    if(unit.animation==2)unit.animation = 5;
                    if(unit.animation==1&&unit.fliped==true)unit.animation = 4;
                }

                if (target.health <= 0) {
                    // Ta bort objektet om health tar slut
                    game.removeobject(game.getobjecttype(enemyType), target);
                }
            }
        }
    }
}
// --- helpers för AI ---
// Vilka räknas som fasta hinder
const SOLID_TYPES = ["tree","goldmine","base","bar","rbase","rbar","house","rhouse"];

// Axis-aligned bbox-overlap
function aabbOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
}

// Linje-segment mot AABB (snabb och robust: Liang–Barsky)
function segmentAABB(x0, y0, x1, y1, rx1, ry1, rx2, ry2) {
  const dx = x1 - x0, dy = y1 - y0;
  let t0 = 0, t1 = 1;

  const p = [-dx, dx, -dy, dy];
  const q = [x0 - rx1, rx2 - x0, y0 - ry1, ry2 - y0];

  for (let i = 0; i < 4; i++) {
    if (p[i] === 0) {
      if (q[i] < 0) return false; // parallell & utanför
    } else {
      const r = q[i] / p[i];
      if (p[i] < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
      else          { if (r < t0) return false; if (r < t1) t1 = r; }
    }
  }
  return true;
}

// Kolla om en rektangel (x,y,w,h) är fri från SOLID_TYPES (med liten marginal)
function freeAtFast(x, y, w, h, inflate = 6) {
  const ax1 = x - inflate/2, ay1 = y - inflate/2;
  const ax2 = ax1 + w + inflate, ay2 = ay1 + h + inflate;

  for (const tn of SOLID_TYPES) {
    const t = game.getobjecttype(tn); if (!t) continue;
    for (const o of t.objects) {
      if (o.ghost) continue;
      const bx1 = o.x, by1 = o.y, bx2 = o.x + o.dimx, by2 = o.y + o.dimy;
      if (aabbOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)) return false;
    }
  }
  return true;
}

// LOS-block? (linje mitt→mitt mot SOLID AABB)
function losBlockedFast(A, B, exclude = null, inflate = 4){
  for (const tn of SOLID_TYPES) {
    const t = game.getobjecttype(tn); if (!t) continue;
    for (const o of t.objects) {
      if (o.ghost) continue;
      if (o === exclude) continue; // <-- ignorera målet
      const rx1 = o.x - inflate, ry1 = o.y - inflate;
      const rx2 = o.x + o.dimx + inflate, ry2 = o.y + o.dimy + inflate;
      if (segmentAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
    }
  }
  return false;
}

function C(o){ return {x:o.x + o.dimx/2, y:o.y + o.dimy/2}; }
function alive(o){ return !!o && game.getAllObjects().includes(o); }



function showEndScreen(result, statsText="") {
  const box = document.getElementById("end-screen");
  const title = document.getElementById("end-title");
  const sub = document.getElementById("end-sub");
  sub.style.whiteSpace = "pre-line";
  sub.textContent = statsText;

  if (result === "win") {
    title.textContent = "Du vann! 🎉";
    sub.textContent = statsText || "Fienden är besegrad.";
  } else {
    title.textContent = "Du förlorade 💀";
    sub.textContent = statsText || "Bättre lycka nästa gång.";
  }
  box.style.display = "flex";
}


function checkWinLose() {
  if (gameOver) return;

  // Hämta typer (säkrar mot null)
  const _g  = game.getobjecttype("guard")    || {objects:[]};
  const _w  = game.getobjecttype("worker")   || {objects:[]};
  const _b  = game.getobjecttype("base")     || {objects:[]};
  const _ba = game.getobjecttype("bar")      || {objects:[]};

  const _rg = game.getobjecttype("rguard")   || {objects:[]};
  const _rw = game.getobjecttype("rworker")  || {objects:[]};
  const _rb = game.getobjecttype("rbase")    || {objects:[]};
  const _rba= game.getobjecttype("rbar")     || {objects:[]};

  // Räkna endast “färdiga” byggnader (animation==1 i din kod betyder klar)
  const playerBasesAlive   = _b.objects.filter(o => !o.ghost && o.animation===1).length;
  const playerBarrsAlive   = _ba.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBasesAlive    = _rb.objects.filter(o => !o.ghost && o.animation===1).length;
  const enemyBarrsAlive    = _rba.objects.filter(o => !o.ghost && o.animation===1).length;

  const playerUnitsAlive   = _g.objects.length + _w.objects.length;
  const enemyUnitsAlive    = _rg.objects.length + _rw.objects.length;

// VINST
if (enemyBasesAlive===0 && enemyBarrsAlive===0 && enemyUnitsAlive===0) {
  gameOver = true;
  showEndScreen(
    "win",
    `Dina resurser – Guld: ${gold} · Trä: ${wood}\nFiendens resurser – Guld: ${rgold} · Trä: ${rwood}`
  );
  return;
}

// FÖRLUST
if (playerBasesAlive===0 && playerBarrsAlive===0 && playerUnitsAlive===0) {
  gameOver = true;
  showEndScreen(
    "lose",
    `Fiendens resurser – Guld: ${rgold} · Trä: ${rwood}\nDina resurser – Guld: ${gold} · Trä: ${wood}`
  );
  return;
}
}

function updateArcherShooting(archerTypeName, enemyTypeNames) {
  const archers = game.getobjecttype(archerTypeName)?.objects || [];
  for (const a of archers) {
    a.attackRange    = a.attackRange ?? 450;  // px
    a.attackCooldown = a.attackCooldown ?? 900; // ms
    a.lastShotTime   = a.lastShotTime ?? 0;

    // Hitta närmaste fiende inom range & line-of-sight
    let best=null, bd=Infinity;
    for (const et of enemyTypeNames) {
      const list = game.getobjecttype(et)?.objects || [];
      for (const e of list) {
        const dx=(a.x + a.dimx/2) - (e.x + e.dimx/2);
        const dy=(a.y + a.dimy/2) - (e.y + e.dimy/2);
        const d=Math.hypot(dx,dy);
        if (d < a.attackRange && d < bd) {
          // valfritt LOS: undvik att skjuta igenom väggar/byggnader
          const A = {x:a.x+a.dimx/2, y:a.y+a.dimy/2}, B = {x:e.x+e.dimx/2, y:e.y+e.dimy/2};
          if (!losBlockedFast(A, B, e, 6)) { // du har redan losBlockedFast() definierad
            bd=d; best=e;
          }
        }
      }
    }

    if (!best) continue;

    // cooldown?
    const now = performance.now();
    if (now - a.lastShotTime < a.attackCooldown) continue;
    a.lastShotTime = now;

    // Skapa pil
    const arrowType = game.getobjecttype("arrow");
    const sx = a.x + a.dimx/2, sy = a.y + a.dimy/2;
    const obj = game.addobject(
      arrowType,
      sx, sy,
      arrowType.standarddimx, arrowType.standarddimy,
      0, false // rot sätts nedan
    );
    obj.speed  = 9;         // px/frame
    obj.damage = 5;         // skada vid träff
    obj.ttl    = 120;       // lever max ~2 sek @60fps
    obj.target = best;

    // init riktning/rotation (bilden pekar åt höger)
    const dx=(best.x+best.dimx/2)-sx, dy=(best.y+best.dimy/2)-sy;
    const ang = Math.atan2(dy, dx);      // radianer
    obj.vx = Math.cos(ang) * obj.speed;
    obj.vy = Math.sin(ang) * obj.speed;
    obj.rot = (ang * 180 / Math.PI);                        // många engines använder .rot            
  }
}

function updateArrows(){
  const arrowType = game.getobjecttype("arrow");
  if (!arrowType) return;
  const arr = [...arrowType.objects]; // kopia om vi tar bort under iteration

  function hitTest(a, t){
    // enkel AABB
    return a.x < t.x + t.dimx && a.x + a.dimx > t.x &&
           a.y < t.y + t.dimy && a.y + a.dimy > t.y;
  }

  for (const p of arr) {
    // livstid
    if ((p.ttl = (p.ttl ?? 120) - 1) <= 0) { game.removeobject(arrowType, p); continue; }
    // mål dött?
    if (!p.target || !game.getAllObjects().includes(p.target)) { game.removeobject(arrowType, p); continue; }

    // styr lite mot rörligt mål (svag homing gör det snällare)
    const tx = p.target.x + p.target.dimx/2;
    const ty = p.target.y + p.target.dimy/2;
    const dx = tx - (p.x + p.dimx/2);
    const dy = ty - (p.y + p.dimy/2);
    const ang = Math.atan2(dy, dx);
    const spd = p.speed ?? 9;

    p.vx = Math.cos(ang) * spd;
    p.vy = Math.sin(ang) * spd;

    // flytta
    p.x += p.vx;
    p.y += p.vy;

    // rotera sprite till flygriktning (din pil pekar höger)
    p.rot =(ang * 180 / Math.PI);

    // träff?
    if (hitTest(p, p.target)) {
      const tgt = p.target;
      if (tgt.maxHealth == null){ // samma default som övriga
        tgt.maxHealth = (new Set(["base","bar","rbase","rbar"]).has(tgt.name)) ? 800 : 100;
        tgt.health = tgt.maxHealth;
      }
      tgt.health -= (p.damage ?? 5);

      // effekter
      spawnDamageNumber(-(p.damage ?? 5), tgt.x, tgt.y, { color: "#ffd166" });
      spawnHitParticles(tx, ty, 6);

      // dö?
      if (tgt.health <= 0) {
        game.removeobject(game.getobjecttype(tgt.name), tgt);
      }
      // ta bort pilen
      game.removeobject(arrowType, p);
    }
  }
}
function enemyTryToBuildHouse() {
  const rWorkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
  const rbaseObj = game.getobjecttype("rbase");
  if (!rWorkers.length || !rbaseObj.objects.length || rbaseObj.objects[0].animation==0) return;


     for(let w of rWorkers){
                    if (w.buildobject&&game.collideswithanoterobject(w,w.workobject)) {
                        
                        w.workobject.buildProgress += 1;
                        w.workobject.health = Math.max(1, Math.floor((w.workobject.buildProgress / 1000) * 800));
                        if(w.animation==0)w.animation = 3;
                        if(w.animation==1&&w.fliped==false)w.animation = 4;
                        if(w.animation==2)w.animation = 5;
                        if(w.animation==1&&w.fliped==true)w.animation = 4;      
                        
                        if (w.workobject.buildProgress > 1000) {
                            w.workobject.ghost = false;
                            w.workobject.selectable = true;
                            w.workobject.animation=1;
                            w.workobject = null;
                            w.buildobject=null;
                        }
                        
                        
                    }
                    


                }






  // bygg bara ett (ändra om du vill fler)
  
  if(rpopUsed >= rpopCap && game.getobjecttype("rhouse").objects[game.getobjecttype("rhouse").objects.length-1]&&game.getobjecttype("rhouse").objects[game.getobjecttype("rhouse").objects.length-1].animation==1){}
  else if (game.getobjecttype("rhouse").objects.length > 0) return;

               





  const goldCost = 0, woodCost = 100;
  if (rgold < goldCost || rwood < woodCost) return;

  const tHouse = game.getobjecttype("rhouse");
  const anchor = rbaseObj.objects[0];
  const spacing = 120;
  let bestPos = null, bestScore = Infinity;

  for (let dx = -5; dx <= 5; dx++) {
    for (let dy = -5; dy <= 5; dy++) {
      const px = anchor.x + dx*spacing;
      const py = anchor.y + dy*spacing;

      const tmp = game.addobject(tHouse, px, py, tHouse.standarddimx||150, tHouse.standarddimy||150, 0, false);
      tmp.ghost = true;

      if (isBuildPlacementValid(tmp)) {
        // närhet till rbase + närhet till nån rworker
        let nearestW = Infinity;
        for (const w of rWorkers) {
          const d = game.getDistance(px, py, w.x, w.y);
          if (d < nearestW) nearestW = d;
        }
        const dBase = game.getDistance(px, py, anchor.x, anchor.y);
        const score = dBase*1 + nearestW*0.5;
        if (score < bestScore) { bestScore = score; bestPos = {x:px, y:py}; }
      }
      game.removeobject(tHouse, tmp);
    }
  }

  if (!bestPos) return;

  // Spawn ghost-bygget och låt en worker konstruera (som din rbar)
  const ghost = game.addobject(tHouse, bestPos.x, bestPos.y, tHouse.standarddimx||150, tHouse.standarddimy||150, 0, false);
  ghost.ghost = false; ghost.canMove = false; ghost.selectable = true; ghost.enemyBuild = true;
  ghost.buildProgress = 0; ghost.health = 1; ghost.animation = 0;

  // Skicka närmaste rworker
  let chosen = rWorkers[0], bestD = Infinity;
  for (const w of rWorkers) {
    const d = game.getDistance(w.x, w.y, bestPos.x, bestPos.y);
    if (d < bestD) { bestD = d; chosen = w; }
  }
  chosen.targetX = bestPos.x+tHouse.standarddimx/2; chosen.targetY = bestPos.y+tHouse.standarddimy/2;
  chosen.workobject = ghost; chosen.buildobject = ghost; chosen.counter2 = 0;
  chosen.deliveryTarget=null;
  chosen.targetObject=null;

  rgold -= goldCost; rwood -= woodCost;
}
function recalcPopulation() {
  // byggnader färdiga = animation==1
  const countFinished = (name) => {
    const t = game.getobjecttype(name);
    if (!t) return 0;
    let n = 0;
    for (const o of (t.objects || [])) if (o.animation === 1) n++;
    return n;
  };

  popCap  = countFinished("base")  * 10 + countFinished("house")  * 5;
  rpopCap = countFinished("rbase") * 10 + countFinished("rhouse") * 5;

  const cnt = (name) => (game.getobjecttype(name)?.objects?.length || 0);

  // räkna ENDAST trupper – byggnader ger inte popUsed
  popUsed  = cnt("worker") + cnt("guard") + cnt("archer");
  rpopUsed = cnt("rworker") + cnt("rguard") + cnt("rarcher");
}

function canAddUnitToPopQueue(typeName) {
  const cost = POP_COST[typeName] || 0;
  const isRed = typeName.startsWith("r");
  return isRed ? (rpopUsed + cost <= rpopCap) : (popUsed + cost <= popCap);
}

 function aabbOverlap(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2){
    return ax1<bx2 && ax2>bx1 && ay1<by2 && ay2>by1;
  }
function freeAtRect(x,y,w,h,inflate=0, excludeObject=null){ // excludeObject parameter is crucial
  const ax1=x-inflate, ay1=y-inflate, ax2=x+w+inflate, ay2=y+h+inflate;
  for(const o of solids){
    if(o === excludeObject) continue; // Skip the object that is the target
    const bx1=o.x, by1=o.y, bx2=o.x+o.dimx, by2=o.y+o.dimy;
    if(aabbOverlap(ax1,ay1,ax2,ay2,bx1,by1,bx2,by2)) return false;
  }
  return true;
}
  function segAABB(x0,y0,x1,y1, rx1,ry1,rx2,ry2){
    const dx=x1-x0, dy=y1-y0;
    let t0=0,t1=1; const p=[-dx,dx,-dy,dy], q=[x0-rx1,rx2-x0,y0-ry1,ry2-y0];
    for(let i=0;i<4;i++){
      if(p[i]===0){ if(q[i]<0) return false; }
      else{ const r=q[i]/p[i];
        if(p[i]<0){ if(r>t1) return false; if(r>t0) t0=r; }
        else      { if(r<t0) return false; if(r<t1) t1=r; }
      }
    }
    return true;
  }
  function losBlocked(A, B, inflate = CLEARANCE) {
  for (const o of solids) {
    const rx1 = o.x - inflate, ry1 = o.y - inflate;
    const rx2 = o.x + o.dimx + inflate, ry2 = o.y + o.dimy + inflate;
    if (segAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
  }
  return false;
}

  // dynamiskt grid (runt G↔T)
function buildGrid(minx, miny, maxx, maxy, targetObject = null) { // Removed inflate parameter
  const w = Math.max(1, Math.ceil((maxx-minx)/CELL));
  const h = Math.max(1, Math.ceil((maxy-miny)/CELL));
  const walk = new Array(w*h).fill(true);

  for (let gy=0; gy<h; gy++) {
    for (let gx=0; gx<w; gx++) {
      const cx = minx + gx*CELL + CELL/2;
      const cy = miny + gy*CELL + CELL/2;
      const x = cx - CELL/2, y = cy - CELL/2;
      // Pass 0 for inflate here, to keep the old grid blocking behavior
      if (!freeAtRect(x, y, CELL, CELL, 0, targetObject)) { // <-- Changed inflate to 0
        walk[gy*w+gx] = false;
      }
    }
  }
  return { w, h, minx, miny, walk };
}
  const toIdx = (gx,gy,w)=>gy*w+gx;

  function worldToGrid(grid, p){
    let gx = Math.floor((p.x - grid.minx)/CELL);
    let gy = Math.floor((p.y - grid.miny)/CELL);
    gx=Math.max(0,Math.min(grid.w-1,gx));
    gy=Math.max(0,Math.min(grid.h-1,gy));
    return {gx,gy};
  }
  function gridToWorld(grid,gx,gy){
    return { x: grid.minx + gx*CELL + CELL/2, y: grid.miny + gy*CELL + CELL/2 };
  }

  // A* (8-neighbors)
  function astar(grid, start, goal){
    const w=grid.w,h=grid.h, walk=grid.walk;
    const sIdx=toIdx(start.gx,start.gy,w), gIdx=toIdx(goal.gx,goal.gy,w);
    const open=[sIdx], came=new Map(), gScore=new Map([[sIdx,0]]);
    const fScore=new Map([[sIdx,heur(start,goal)]]);

    function heur(a,b){ const dx=Math.abs(a.gx-b.gx), dy=Math.abs(a.gy-b.gy);
      return (dx+dy) + (Math.SQRT2-2)*Math.min(dx,dy);
    }
    function lowestF(){
      let best=-1,bv=Infinity;
      for(let i=0;i<open.length;i++){ const idx=open[i]; const v=fScore.get(idx)??Infinity; if(v<bv){bv=v;best=i;} }
      return open.splice(best,1)[0];
    }
    function neighbors(gx,gy){
      const out=[];
      for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){
        if(!ox&&!oy) continue;
        const nx=gx+ox, ny=gy+oy;
        if(nx<0||ny<0||nx>=w||ny>=h) continue;
        if(!walk[toIdx(nx,ny,w)]) continue;
        // valfri: förhindra att skära hörn igenom två block
        if(ox&&oy){
          if(!walk[toIdx(gx,ny,w)] || !walk[toIdx(nx,gy,w)]) continue;
        }
        out.push({gx:nx,gy:ny,cost: (ox&&oy)?Math.SQRT2:1});
      }
      return out;
    }

    while(open.length){
      const curIdx=lowestF();
      if(curIdx===gIdx){
        // rekonstruktion
        const path=[];
        let u=curIdx;
        while(u!==sIdx){ const v=came.get(u); const gx=u%w, gy=(u-gx)/w; path.push({gx,gy}); u=v; }
        path.push({gx:start.gx,gy:start.gy}); path.reverse();
        return path;
      }
      const cgx=curIdx%w, cgy=(curIdx-cgx)/w;
      for(const nb of neighbors(cgx,cgy)){
        const nIdx=toIdx(nb.gx,nb.gy,w);
        const tentative = (gScore.get(curIdx)??Infinity) + nb.cost;
        if(tentative < (gScore.get(nIdx)??Infinity)){
          came.set(nIdx, curIdx);
          gScore.set(nIdx, tentative);
          fScore.set(nIdx, tentative + heur(nb,goal));
          if(!open.includes(nIdx)) open.push(nIdx);
        }
      }
    }
    return null;
  }

  // Path smoothing: ta bort överflödiga punkter med LOS
  function smoothPath(grid, path, inflate) {
  if (!path || path.length <= 2) return path;
  const out = [path[0]];
  let i = 0;
  while (i < path.length - 1) {
    let j = path.length - 1;
    const Pi = gridToWorld(grid, path[i].gx, path[i].gy);
    for (; j > i + 1; j--) {
      const Pj = gridToWorld(grid, path[j].gx, path[j].gy);
      if (!losBlocked(Pi, Pj, inflate)) break; // <-- använda inflate
    }
    out.push(path[j]);
    i = j;
  }
  return out;
}

function updateRedGuardAI() {
  // ===== Tunables =====
  const PAD  = 260;
  const PAD_SCALES = [1.25, 2.25];      // färre stora grids → snabbare
  const NEAR_RALLY = 150;
  const NEAR_WP    = 12;                // tajtare WP → håller bättre runt hörn
  const REPATH_FR  = 24;                // färre omplaneringar
  const STUCK_FR   = 24;
  const STUCK_COOLDOWN = 24;
  const EXTRA_CLEAR = 28;               // marginal mot träd
  const RALLY_RECALC_MS = 2500;

  // Grupp/klunga
  const MAX_OFF        = 22;
  const LATERAL_SPACING= 22;
  const TARGET_DECAY_R = 260;
  const REP_W = 0.95, LAT_W = 0.65, COH_W = 0.45;
  const COH_DIST = 12;

  // Throttling
  const PF_BUCKETS = 6;                 // ~1/6 av enheterna planerar per frame
  const OFF_UPDATE_FR = 3;              // räkna om steering-offset var 3:e frame
  if (typeof window._RED_TICK === "undefined") window._RED_TICK = 0;
  window._RED_TICK++;

  // ===== Helpers =====
  const ok = (v)=> v!==null && v!==undefined;
  const alive = (o)=> !!o && game.getAllObjects().includes(o);
  const dims = (o)=> {
    const w = ok(o.dimx) ? o.dimx : (o.type?.standarddimx ?? 32);
    const h = ok(o.dimy) ? o.dimy : (o.type?.standarddimy ?? 32);
    return {w,h};
  };
  const C  = (o)=> { const {w,h}=dims(o); return { x:(o.x??0)+w/2, y:(o.y??0)+h/2 }; };
  const D  = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
  const now = ()=> (typeof performance!=="undefined" ? performance.now() : Date.now());

  function list(type){
    const t = game.getobjecttype(type);
    return t ? (t.objects||[]).filter(o => !o.ghost) : [];
  }
  function listReady(type){
    return list(type);
  }
  function firstReady(type){ return listReady(type)[0] || null; }

  // ===== Litet globalt state för vågen =====
  const S = (window._RWAVE ||= {
    rally: null,
    rallyNext: 0,
    orig: new Set(),      // de ursprungliga 5
    attacking: false
  });

  // ===== Träd (cache per frame + precomputade cirklar) =====
  const TREES = (game.getobjecttype("tree")?.objects || []).filter(t => !t.ghost);
  const T_CIRC = TREES.map(t=>{
    const cx = t.x + t.dimx/2, cy = t.y + t.dimy/2, r = Math.max(t.dimx, t.dimy)/2;
    return {t, cx, cy, r, r2:r*r, minx:t.x, miny:t.y, maxx:t.x+t.dimx, maxy:t.y+t.dimy};
  });

  function segAABB(x0,y0,x1,y1, rx1,ry1,rx2,ry2){
    const dx=x1-x0, dy=y1-y0; let t0=0,t1=1;
    const p=[-dx,dx,-dy,dy], q=[x0-rx1,rx2-x0,y0-ry1,ry2-y0];
    for(let i=0;i<4;i++){
      if(p[i]===0){ if(q[i]<0) return false; }
      else{
        const r=q[i]/p[i];
        if(p[i]<0){ if(r>t1) return false; if(r>t0) t0=r; }
        else      { if(r<t0) return false; if(r<t1) t1=r; }
      }
    }
    return true;
  }

  function treesBlock(A, B, inflate=16){
    const minx = Math.min(A.x, B.x) - (inflate+32);
    const maxx = Math.max(A.x, B.x) + (inflate+32);
    const miny = Math.min(A.y, B.y) - (inflate+32);
    const maxy = Math.max(A.y, B.y) + (inflate+32);
    for (const c of T_CIRC){
      if (c.maxx < minx || c.minx > maxx || c.maxy < miny || c.miny > maxy) continue;
      const rx1 = c.minx - inflate, ry1 = c.miny - inflate;
      const rx2 = c.maxx + inflate, ry2 = c.maxy + inflate;
      if (segAABB(A.x, A.y, B.x, B.y, rx1, ry1, rx2, ry2)) return true;
    }
    return false;
  }

  function bakeTreesIntoGrid(grid, inflate=16){
    const w = grid.w, h = grid.h, walk = grid.walk;
    const idx = (gx,gy)=> gy*w + gx;
    const gxMin = 0, gyMin = 0, gxMax = w-1, gyMax = h-1;
    const worldMinX = grid.minx, worldMinY = grid.miny;
    const worldMaxX = grid.minx + w*24;
    const worldMaxY = grid.miny + h*24;

    for (const c of T_CIRC){
      if (c.minx > worldMaxX + inflate || c.maxx < worldMinX - inflate ||
          c.miny > worldMaxY + inflate || c.maxy < worldMinY - inflate) continue;

      const rx1 = c.minx - inflate, ry1 = c.miny - inflate;
      const rx2 = c.maxx + inflate, ry2 = c.maxy + inflate;
      const g1 = worldToGrid(grid, {x:rx1, y:ry1});
      const g2 = worldToGrid(grid, {x:rx2, y:ry2});
      const gx1 = Math.max(gxMin, Math.min(g1.gx, g2.gx));
      const gx2 = Math.min(gxMax, Math.max(g1.gx, g2.gx));
      const gy1 = Math.max(gyMin, Math.min(g1.gy, g2.gy));
      const gy2 = Math.min(gyMax, Math.max(g1.gy, g2.gy));
      for (let gy=gy1; gy<=gy2; gy++){
        for (let gx=gx1; gx<=gx2; gx++){
          walk[idx(gx,gy)] = false;
        }
      }
    }
  }

  // ===== RALLY via isBuildPlacementValid + RIKTIGT objekt =====
  function pickRally() {
    const rbase = firstReady("rbase") || firstReady("rbar");
    if (!rbase) return null;

    const enemyUnits  = [...listReady("guard"), ...listReady("archer"), ...listReady("worker")];
    const enemyBuilds = [...listReady("base"), ...listReady("bar"), ...listReady("house")];
    let target = firstReady("base") || firstReady("bar") || enemyUnits[0] || enemyBuilds[0];
    if (!target) return C(rbase);

    const R = C(rbase), T = C(target);
    let vx = T.x - R.x, vy = T.y - R.y;
    const L = Math.hypot(vx,vy) || 1; vx/=L; vy/=L;
    const perp = { x:-vy, y:vx };

    let tProbe = game.getobjecttype("house") || game.getobjecttype("bar") || game.getobjecttype("base");
    if (!tProbe) return C(rbase);
    const PROBE_W = tProbe.standarddimx || 112;
    const PROBE_H = tProbe.standarddimy || 112;

    function testSpot(cx, cy){
      const left = Math.round(cx - PROBE_W/2);
      const top  = Math.round(cy - PROBE_H/2);
      const tmp = game.addobject(tProbe, left, top, PROBE_W, PROBE_H, 0, false);
      let okPlace = false;
      try { okPlace = !!isBuildPlacementValid(tmp); } catch(e){ okPlace = false; }
      game.removeobject(tProbe, tmp);
      return okPlace;
    }

    for (let d=160; d<=900; d+=24) {
      const cx = R.x + vx*d, cy = R.y + vy*d;
      if (testSpot(cx, cy)) return { x: cx, y: cy };
    }
    for (const side of [-1,1]) {
      for (let d=200; d<=900; d+=32) {
        const cx = R.x + vx*d + perp.x*side*160;
        const cy = R.y + vy*d + perp.y*side*160;
        if (testSpot(cx, cy)) return { x: cx, y: cy };
      }
    }
    return { x:R.x + vx*220, y:R.y + vy*220 };
  }

  // ===== Robust path (expanderar sökyta vid behov) =====
  function tryPath(fromPt, toPt, targetObj=null){
    for (const s of PAD_SCALES){
      const minx=Math.min(fromPt.x,toPt.x)-PAD*s, miny=Math.min(fromPt.y,toPt.y)-PAD*s;
      const maxx=Math.max(fromPt.x,toPt.x)+PAD*s, maxy=Math.max(fromPt.y,toPt.y)+PAD*s;
      const grid = buildGrid(minx,miny,maxx,maxy,targetObj);
      bakeTreesIntoGrid(grid, EXTRA_CLEAR+6);
      const Sg = worldToGrid(grid, fromPt), Gg = worldToGrid(grid, toPt);
      const raw = astar(grid, Sg, Gg);
      if (raw) {
        const sm = smoothPath(grid, raw, EXTRA_CLEAR+6);
        return sm.map(p => gridToWorld(grid, p.gx, p.gy));
      }
    }
    return null;
  }

  // ===== formation/klunga-hjälpare =====
  function vAdd(a,b){ return {x:a.x+b.x, y:a.y+b.y}; }
  function vMul(a,s){ return {x:a.x*s,   y:a.y*s  }; }
  function vClamp(a,max){ const L=Math.hypot(a.x,a.y); if(L<=max||L<1e-6) return a; const k=max/L; return {x:a.x*k,y:a.y*k}; }
  function vNorm(a){ const L=Math.hypot(a.x,a.y)||1; return {x:a.x/L,y:a.y/L}; }

  let _waveCentroid = null;
  function waveCentroid(){
    if (_waveCentroid) return _waveCentroid;
    const arr = Array.from(S.orig).filter(o => o && !o.ghost);
    if (!arr.length) return null;
    let x=0,y=0; for (const u of arr){ x += u.x + (u.dimx||u.type?.standarddimx||32)/2; y += u.y + (u.dimy||u.type?.standarddimy||32)/2; }
    _waveCentroid = {x:x/arr.length, y:y/arr.length};
    return _waveCentroid;
  }
  function getSlot(u){
    if (u._slotId == null) u._slotId = (window._RWAVE_SLOTCTR = (window._RWAVE_SLOTCTR||0) + 1);
    return u._slotId;
  }
  function lateralOffsetFor(u, fromPt, toPt){
    const dir = vNorm({x: toPt.x - fromPt.x, y: toPt.y - fromPt.y});
    const perp = {x: -dir.y, y: dir.x};
    const i = getSlot(u);
    const pat = ((i%5)===0)? 0 : (((i%2)?1:-1) * Math.ceil((i%10)/2)); // -1,1,-2,2,0,...
    return { x: perp.x * pat * LATERAL_SPACING, y: perp.y * pat * LATERAL_SPACING };
  }

  // Snabb repulsion (kör bara på träd i närheten)
  function repulsionAt(pt, minDist=56, scale=18){
    let ax=0, ay=0; let touched=false;
    const R2 = (minDist+40)*(minDist+40);
    for (const c of T_CIRC){
      const dx = pt.x - c.cx, dy = pt.y - c.cy;
      const d2 = dx*dx + dy*dy;
      if (d2 > (c.r2 + R2)) continue; // för långt bort
      const d  = Math.sqrt(d2)||1e-6;
      const edge = d - c.r;
      if (edge < minDist){
        const push = (minDist - Math.max(0, edge)) / Math.max(minDist,1);
        ax += (dx/d) * push; ay += (dy/d) * push;
        touched = true;
      }
    }
    if (!touched) return {x:0,y:0};
    return { x: ax*scale, y: ay*scale };
  }

  // ===== Rörelse mot punkt/objekt (med throttlad A* + cachad steering) =====
  function shouldPlanThisFrame(u){
    if (u.ai._bucket == null) u.ai._bucket = (Math.random()*PF_BUCKETS)|0;
    return (window._RED_TICK % PF_BUCKETS) === u.ai._bucket;
  }
  function updateSteeringOffset(u, U, g, finalTarget){
    if (!u.ai.off || u.ai.offTTL<=0 || u.ai._lastPi !== u.ai.pi){
      const distTo = Math.hypot(U.x - finalTarget.x, U.y - finalTarget.y);
      const repScale = Math.max(0.25, Math.min(1, distTo / TARGET_DECAY_R));
      const offRep = repulsionAt(g, 56, 18 * repScale);
      const offLat = lateralOffsetFor(u, U, g);
      const Gc = waveCentroid();
      const cohV = Gc ? vMul(vNorm({x:Gc.x - U.x, y:Gc.y - U.y}), COH_DIST) : {x:0,y:0};
      let off = vAdd( vAdd( vMul(offRep, REP_W), vMul(offLat, LAT_W) ), vMul(cohV, COH_W) );
      u.ai.off = vClamp(off, MAX_OFF);
      u.ai.offTTL = OFF_UPDATE_FR;
      u.ai._lastPi = u.ai.pi;
    } else {
      u.ai.offTTL--;
    }
    return u.ai.off || {x:0,y:0};
  }

  function moveToPoint(u, goal) {
    if (!u || !goal) return;
    if (!u.ai) u.ai = { path:null, pi:0, repath:0, lx:u.x, ly:u.y, stuck:0, stuckCD:0, _bucket:null, off:null, offTTL:0, _lastPi:-1 };

    const U = C(u);
    const {w,h}=dims(u);
    const INF = Math.max(w,h)/2 + EXTRA_CLEAR + 6;

    // Stuck + cooldown
    const moved = Math.hypot(u.x - u.ai.lx, u.y - u.ai.ly);
    u.ai.stuck = (moved < 0.5) ? (u.ai.stuck+1) : 0;
    u.ai.lx = u.x; u.ai.ly = u.y;
    if (u.ai.stuck > STUCK_FR) { u.ai.stuckCD = STUCK_COOLDOWN; }
    if (u.ai.stuckCD > 0) u.ai.stuckCD--;

    // Planera path endast när vi MÅSTE och bara för vår bucket
    const freeLOS = (!losBlockedFast(U, goal, null, INF) && !treesBlock(U, goal, EXTRA_CLEAR));
    if (!freeLOS) {
      if ((!u.ai.path || u.ai.repath<=0) && shouldPlanThisFrame(u) && u.ai.stuckCD===0) {
        const p = tryPath(U, goal, null);
        if (p) { u.ai.path=p; u.ai.pi = (p.length>1)?1:0; }
        else   { u.ai.path=null; u.ai.pi=0; }
        u.ai.repath = REPATH_FR + ((Math.random()*8)|0);
      } else {
        if (u.ai.repath>0) u.ai.repath--;
      }
    } else {
      u.ai.path=null; u.ai.pi=0; u.ai.repath=0;
    }

    if (u.ai.path && u.ai.pi < u.ai.path.length) {
      const wp = u.ai.path[u.ai.pi];
      if (Math.hypot(U.x - wp.x, U.y - wp.y) < NEAR_WP) u.ai.pi++;
    }

    const g = (u.ai.path && u.ai.pi<u.ai.path.length) ? u.ai.path[u.ai.pi] : goal;
    const off = updateSteeringOffset(u, U, g, goal);
    u.targetX = (g.x + off.x) - w/2;
    u.targetY = (g.y + off.y) - h/2;
  }

  function moveToObject(u, t) {
    if (!u || !t || !alive(t)) return;
    if (!u.ai) u.ai = { path:null, pi:0, repath:0, lx:u.x, ly:u.y, stuck:0, stuckCD:0, _bucket:null, off:null, offTTL:0, _lastPi:-1 };

    const U = C(u), T = C(t);
    const {w,h}=dims(u);
    const INF = Math.max(w,h)/2 + EXTRA_CLEAR + 6;

    // Stuck + cooldown
    const moved = Math.hypot(u.x - u.ai.lx, u.y - u.ai.ly);
    u.ai.stuck = (moved < 0.5) ? (u.ai.stuck+1) : 0;
    u.ai.lx = u.x; u.ai.ly = u.y;
    if (u.ai.stuck > STUCK_FR) { u.ai.stuckCD = STUCK_COOLDOWN; }
    if (u.ai.stuckCD > 0) u.ai.stuckCD--;

    const dx = T.x - U.x, dy = T.y - U.y;
    u.direction = Math.abs(dx) > Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up");

    if (game.collideswith && game.collideswith(u, t.name, u.direction)) {
      const L = Math.hypot(dx,dy)||1, push=(u.speed||1)*0.25;
      u.targetX = u.x + (dx/L)*push;
      u.targetY = u.y + (dy/L)*push;
      return;
    }

    const freeLOS = (!losBlockedFast(U, T, t, INF) && !treesBlock(U, T, EXTRA_CLEAR));
    if (!freeLOS) {
      if ((!u.ai.path || u.ai.repath<=0) && shouldPlanThisFrame(u) && u.ai.stuckCD===0) {
        const p = tryPath(U, T, t);
        if (p) { u.ai.path=p; u.ai.pi=(p.length>1)?1:0; }
        else   { u.ai.path=null; u.ai.pi=0; }
        u.ai.repath = REPATH_FR + ((Math.random()*8)|0);
      } else {
        if (u.ai.repath>0) u.ai.repath--;
      }
    } else {
      u.ai.path=null; u.ai.pi=0; u.ai.repath=0;
    }

    if (u.ai.path && u.ai.pi < u.ai.path.length) {
      const wp = u.ai.path[u.ai.pi];
      if (Math.hypot(U.x - wp.x, U.y - wp.y) < NEAR_WP) u.ai.pi++;
    }

    const g = (u.ai.path && u.ai.pi<u.ai.path.length) ? u.ai.path[u.ai.pi] : T;
    const off = updateSteeringOffset(u, U, g, T);
    u.targetX = (g.x + off.x) - w/2;
    u.targetY = (g.y + off.y) - h/2;
  }

  // ================= MAIN LOOP =================

  // fighters (endast “färdiga”)
  const rguards  = listReady("rguard");
  const rarchers = listReady("rarcher");
  const fighters = [...rguards, ...rarchers].filter(alive);

  // städa orig-gruppen
  for (const u of [...S.orig]) if (!alive(u)) S.orig.delete(u);

  // räkna om rally om vi inte attackerar aktivt
  if (!S.attacking && now() >= S.rallyNext) {
    const newRally = pickRally();
    if (newRally) S.rally = newRally;
    if (!S.rally) {
      const rb = firstReady("rbase") || firstReady("rbar");
      if (rb) S.rally = C(rb);
    }
    S.rallyNext = now() + RALLY_RECALC_MS;
  }
  if (!S.rally) return;

  // Samla 5 → attack
  if (!S.attacking) {
    const need = 5 - S.orig.size;
    if (need > 0 && fighters.length) {
      const sorted = fighters
        .filter(u => u && !S.orig.has(u))
        .sort((a,b)=> D(C(a), S.rally) - D(C(b), S.rally));
      for (let i=0; i<Math.min(need, sorted.length); i++) S.orig.add(sorted[i]);
    }

    let idx=0, ready=0;
    _waveCentroid = null; // reset cache
    for (const u of S.orig) {
      const ang = (idx++ * 72) * Math.PI/180;
      const target = { x: S.rally.x + Math.cos(ang)*40, y: S.rally.y + Math.sin(ang)*40 };
      moveToPoint(u, target);
      if (D(C(u), S.rally) <= NEAR_RALLY) ready++;
    }

    if (S.orig.size === 5 && ready === 5) S.attacking = true;
    return;
  }

  // attack: mål – enheter först, sen byggnader
  const enemyUnits  = [...listReady("guard"), ...listReady("archer"), ...listReady("worker")];
  const enemyBuilds = [...listReady("base"), ...listReady("bar"), ...listReady("house")];
  let mainTarget = null, bd = Infinity;
  if (enemyUnits.length) {
    for (const e of enemyUnits) { const d=D(S.rally, C(e)); if (d<bd){bd=d; mainTarget=e;} }
  } else if (enemyBuilds.length) {
    for (const b of enemyBuilds){ const d=D(S.rally, C(b)); if (d<bd){bd=d; mainTarget=b;} }
  }

  _waveCentroid = null; // reset cache före rörelser
  if (!mainTarget) {
    for (const u of fighters) moveToPoint(u, S.rally);
  } else {
    for (const u of S.orig) moveToObject(u, mainTarget);
    for (const u of fighters) if (!S.orig.has(u)) moveToObject(u, mainTarget);
  }

  // när original-5 är borta → ny våg
  if (S.attacking && S.orig.size === 0) {
    S.attacking = false;
    S.rallyNext = 0;
    S.rally = null;
  }
}



        </script>
    </body>
</html>
