
<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="mobilspel, mobilegames, js games, javascript games">
        <link rel="icon" href="images/guarddown1.png" type="image/vnd.microsoft.icon" />
	<title>Test4</title>
        
        <script src="js/Game5.js"></script>
        
        
        
        
    </head>
    <body>
        
        
        <div id="build-ui" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">
  <button id="build-base-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkgreen;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Bygg bas</button>
  <button id="build-barracks-btn" style="
  font-size: 16px;
  padding: 10px 20px;
  background: darkred;
  color: white;
  border: none;
  border-radius: 5px;
  touch-action: manipulation;
  display: none; /* <-- GÖMD TILLS VIDARE */
">
  Bygg barack
</button>
  
  
</div>
        
<div id="build-ui2" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-worker-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna arbetare</button>
 
  
</div>        
<div id="build-ui3" style="
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: rgba(0,0,0,0.8);
  padding: 10px;
  display: none;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  z-index: 1000;
">

  <button id="train-warrior-btn" style="
    font-size: 16px;
    padding: 10px 20px;
    background: darkblue;
    color: white;
    border: none;
    border-radius: 5px;
    touch-action: manipulation;
  ">Träna krigare</button>
 
  
</div>            
        
<div id="resourceUI" style="position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; font-family: sans-serif; font-size: 50px; z-index: 100;">
    <img src="images/gold.png" style="width:50px; vertical-align: middle;">Guld: <span id="goldCount">0</span><br>
    <img src="images/wood.png" style="width:50px; vertical-align: middle;">Trä: <span id="woodCount">0</span>
</div>   
  
        
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>
        
        <script>

            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;

            game = new Game5("Spelet");
            var audio = new Audio('sounds/wow.mp3');
            audio.loop = true;
             
             const context = new (window.AudioContext || window.webkitAudioContext)();
             const audio2 = async url => {   
             const source = context.createBufferSource(); 
                const audioBuffer = await fetch(url)
                  .then(res => res.arrayBuffer())
                  .then(ArrayBuffer => context.decodeAudioData(ArrayBuffer)); 
                source.buffer = audioBuffer;
                source.connect(context.destination);
                source.start();
            };
            window.allowSelection = function() {
                return !buildMode; // tillåt bara selektion när man inte bygger
            };
            
            document.addEventListener("touchstart" , function(e) {
                e.preventDefault();
				
                    try{if(audio.paused){ 
                        audio.play();
                    }
                    }catch(error){};
                    if(context.state === 'suspended'){context.suspend();context.resume();}           
            });

            
            
            document.addEventListener("visibilitychange", event => {
                if (document.visibilityState === "visible") {
                        audio.pause();audio.src = 'sounds/wow.mp3';context.resume();
                        
                }
                else {
                   audio.pause(); audio.src = "";context.suspend();
              }
          });

           
            
            
            let keysPressed = {};
                document.addEventListener('click', (event) => {
        
               
                try{if(audio.paused){ 
                        audio.play();
                    }
                }catch(error){};
             });

            
            let keyState = {
                w: false,
                a: false,
                s: false,
                d: false
            };
            
            document.addEventListener("keydown", function(e) {
                if (e.key === "w") keyState.w = true;
                if (e.key === "a") keyState.a = true;
                if (e.key === "s") keyState.s = true;
                if (e.key === "d") keyState.d = true;
            });

            document.addEventListener("keyup", function(e) {
                if (e.key === "w") keyState.w = false;
                if (e.key === "a") keyState.a = false;
                if (e.key === "s") keyState.s = false;
                if (e.key === "d") keyState.d = false;
            });
            let buildMode = false;
            let buildType = null;
            let ghostBuilding = null;
            let pendingBuilds = [];
            let selectedWorkersBeforeBuild = [];
            let selectedWorkers = [];
            let lastTouchPos = null;
            let gold = 1000;
            let wood = 1000;
            let rgold = 1000;
            let rwood = 1000;
            
            document.getElementById("build-base-btn").innerHTML = "Bygg bas<br>1000 guld / 1000 trä";
            document.getElementById("build-barracks-btn").innerHTML = "Bygg barrack<br>500 guld / 500 trä";
            document.getElementById("train-worker-btn").innerHTML = "Träna arbetare<br>200 guld / 100 trä";
            document.getElementById("train-warrior-btn").innerHTML = "Träna warrior<br>300 guld / 100 trä";
            document.getElementById("build-base-btn").addEventListener("click", function() {
                if(gold>=1000&&wood>=1000){gold-=1000;wood-=1000;}    
                else return;    
                buildMode = true;
                buildType = "base";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("base"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
            });
            document.getElementById("build-barracks-btn").addEventListener("click", function() {
                if(gold>=500&&wood>=500){gold-=500;wood-=500;}    
                else return;    
                buildMode = true;
                buildType = "bar";
                selectedWorkersBeforeBuild = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                game.getAllObjects().forEach(o => {
                    if (!selectedWorkersBeforeBuild.includes(o)) {
                        o.selected = false;
                    }
                });
                ghostBuilding = game.addobject(game.getobjecttype("bar"), 0, 0, 150, 150, 0, false);
                ghostBuilding.ghost = true;
                ghostBuilding.selectable = false;
            });
            document.getElementById("train-worker-btn").addEventListener("click", () => {
                const base = game.getAllObjectsoftype(game.getobjecttype("base")).find(b => b.selected);
                if (!base) return;

                if (gold >= 200 && wood >= 100) {
                    gold -= 200;
                    wood -= 100;

                    base.buildQueue = base.buildQueue || [];
                    base.buildQueue.push("worker");
                } else {
                   
                }
            });    
            document.getElementById("train-warrior-btn").addEventListener("click", () => {
                const bar = game.getAllObjectsoftype(game.getobjecttype("bar")).find(b => b.selected);
                if (!bar) return;

                if (gold >= 300 && wood >= 100) {
                    gold -= 300;
                    wood -= 100;

                    bar.buildQueue = bar.buildQueue || [];
                    bar.buildQueue.push("guard");
                } else {
                   
                }
            }); 
            
            
            document.addEventListener("touchmove", function(e) {
                                if (e.target.closest("#build-ui")) {return;}
                if (e.touches.length >= 2 && buildMode) {
                    cancelBuildMode();
                    return;
                }
                
                
    
              if (buildMode && ghostBuilding) {
    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
    let touch = e.touches[0];
    lastTouchPos = {
        x: touch.clientX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2,
        y: touch.clientY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2
    };
    ghostBuilding.x = lastTouchPos.x;
    ghostBuilding.y = lastTouchPos.y;
    isPlacingBuilding = true;
}
            
            
            });
            
            document.addEventListener("touchend", function(e) {
				selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
				
							if(w.counter2>10){
                            if(w.workobject)w.workobject.occupied=false;                                
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
							}
                        }
                
                
                 if(ghostBuilding!=null&&isBuildPlacementValid(ghostBuilding)==false){return;}
        
                if (buildMode && ghostBuilding) {
                    const currentMap = game.maps[game.currentmap];
                    const x = ghostBuilding.x;
                    const y = ghostBuilding.y;

                    
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    isPlacingBuilding = false;
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {
                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
                
                
                
                
                
                
                
                
                
                
            });
            
            document.addEventListener("contextmenu", function(e) {
                e.preventDefault(); // förhindra browserns meny
                
                
                if (buildMode) {
            
                    cancelBuildMode();
                }
            });

            
            document.addEventListener("mousemove", function(e) {
                cursorX = e.clientX;
                cursorY = e.clientY;
                lastTouchPos = null; // ← detta säger "vi är i PC-läge"
            });
            document.addEventListener("mousedown", function(e) {
                selectedWorkers2 = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                for (let w of selectedWorkers2) {
                            if(w.workobject)w.workobject.occupied=false;
                            w.workobject=null;
                            w.returning=false;
                            w.deliveryTarget=null;
                        }
                
                
                if(isBuildPlacementValid(ghostBuilding)==false)return;
                
                if (e.button === 2 && buildMode) {
                    e.preventDefault(); // hindra fokus/kontext
                    return; // inget mer körs
                }
                
                
                if (buildMode && ghostBuilding) {
                    const currentMap = game.maps[game.currentmap];
                    const x = ghostBuilding.x;
                    const y = ghostBuilding.y;

                    
                  
                    ghostBuilding.ghost = false;
                    ghostBuilding.selectable = true;
                    ghostBuilding.canMove=false;
                    
                    pendingBuilds.push(ghostBuilding);
                    
                                            // Tilldela sparade workers detta bygge:
                        for (let w of selectedWorkersBeforeBuild) {

                            w.targetX = ghostBuilding.x+ghostBuilding.dimx/2;
                            w.targetY = ghostBuilding.y+ghostBuilding.dimy/2;
                            w.targetObject=ghostBuilding;
                            w.buildingTarget = ghostBuilding;
                        }

                        // Rensa och avsluta
                        selectedWorkersBeforeBuild = [];
                        buildMode = false;
                        buildType = null;
                        ghostBuilding = null;
                }
            });
            
            
            
            
            
             var check = function(){
                 
                
                 
                canvas.width=document.body.clientWidth;
                canvas.height=document.body.clientHeight-8;
                 
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
                
                const camSpeed = 15;
                const currentMap = game.maps[game.currentmap];

                if (keyState.w) currentMap.cameray += camSpeed;
                if (keyState.s) currentMap.cameray -= camSpeed;
                if (keyState.a) currentMap.camerax += camSpeed;
                if (keyState.d) currentMap.camerax -= camSpeed;
                
                document.getElementById("goldCount").textContent = gold;
                document.getElementById("woodCount").textContent = wood;
                
                
                let anyWorkerSelected = false;
                if (game.maps.length > 0) {
                    const workers = game.getobjecttype("worker");
                    if (workers) {
                        anyWorkerSelected = workers.objects.some(o => o.selected);
                    }
                }
                document.getElementById("build-ui").style.display = anyWorkerSelected ? "flex" : "none";
                
                
                game.updateanimation(ctx);
                
		gras= game.getobjecttype("ground"); 				
                guard =game.getobjecttype("guard"); 
                worker =game.getobjecttype("worker"); 
                tree =game.getobjecttype("tree"); 
                goldmine =game.getobjecttype("goldmine"); 
                base=game.getobjecttype("base"); 
                
                
                //ENEMYS
                rbar =game.getobjecttype("rbar"); 
                rbase =game.getobjecttype("rbase"); 
                rguard =game.getobjecttype("rguard"); 
                rworker =game.getobjecttype("rworker"); 
                
                
                
                
                if (buildMode && ghostBuilding&& lastTouchPos === null) {
                    let zoomFactor = 1 + (1 * game.maps[game.currentmap].zoom / 100);
                    ghostBuilding.x = cursorX / zoomFactor - game.maps[game.currentmap].camerax - ghostBuilding.dimx / 2;
                    ghostBuilding.y = cursorY / zoomFactor - game.maps[game.currentmap].cameray - ghostBuilding.dimy / 2;
                }
                
                
                
                
                
                
                
                
                if(guard!=null){
                    
                    enemyTryToBuildBase();
                    updateRedWorkerAI();
                    
                    const anyBaseSelected = game.getAllObjectsoftype(game.getobjecttype("base")).some(o => o.selected);
                    document.getElementById("build-ui2").style.display = anyBaseSelected ? "flex" : "none";
                    
                    const anyBarSelected = game.getAllObjectsoftype(game.getobjecttype("bar")).some(o => o.selected);
                    document.getElementById("build-ui3").style.display = anyBarSelected ? "flex" : "none";
                    
                    
                    const canAffordBase = gold >= 1000 && wood >= 1000;
                    const canAffordWorker = gold >= 200 && wood >= 100;
                    const canAffordWarrior = gold >= 300 && wood >= 100;
                    const canAffordBar = gold >= 300 && wood >= 100;

                    document.getElementById("build-base-btn").style.opacity = canAffordBase ? "1" : "0.5";
                    document.getElementById("train-worker-btn").style.opacity = canAffordWorker ? "1" : "0.5";
                    document.getElementById("train-warrior-btn").style.opacity = canAffordWarrior ? "1" : "0.5";
                    document.getElementById("build-barracks-btn").style.opacity = canAffordBar ? "1" : "0.5";
                    
                    if (base.objects.length>0&&base.objects[0].animation==1) {
                        document.getElementById("build-barracks-btn").style.display = "inline-block";
                    }
                    
                    
                  
                    selectedWorkers = game.getAllObjectsoftype(game.getobjecttype("worker")).filter(o => o.selected );
                    
                    const basesAndBars = game.getAllObjectsoftype(game.getobjecttype("base"))
                        .concat(game.getAllObjectsoftype(game.getobjecttype("bar")));

                    for (let base of basesAndBars) {
                        base.buildQueue = base.buildQueue || [];
                        base.buildTimer = base.buildTimer || 0;

                        if (base.buildQueue.length > 0) {
                            base.buildTimer++;

                            // så länge vi hinner producera
                            while (base.buildQueue.length > 0 && base.buildTimer >= 1000) {
                                const unitType = game.getobjecttype(base.buildQueue[0]);

                                const spacing = 100;
                                const directions = [
                                    [spacing, 0], [-spacing, 0], [0, spacing], [0, -spacing],
                                    [spacing, spacing], [-spacing, -spacing], [spacing, -spacing], [-spacing, spacing]
                                ];

                                let placed = false;

                                for (let [dx, dy] of directions) {
                                    const px = base.x + base.dimx / 2 + dx;
                                    const py = base.y + base.dimy / 2 + dy;

                                    const newUnit = game.addobject(
                                        unitType,
                                        px,
                                        py,
                                        unitType.standarddimx,
                                        unitType.standarddimy,
                                        0,
                                        false
                                    );

                                    const overlaps = newUnit.collideslist(game.maps, game.currentmap, "any");

                                    if (!overlaps) {
                                        placed = true;
                                        break;
                                    } else {
                                        game.removeobject(unitType, newUnit);
                                    }
                                }

                                if (placed) {
                                    base.buildQueue.shift();
                                    base.buildTimer -= 1000; // 💡 fortsätt direkt om nästa också är klar
                                } else {
                                    // avbryt loopen, försök igen nästa frame
                                    break;
                                }
                            }
                        }
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    for(let i=0;i<goldmine.objects.length;i++){
                    
                        goldmine.objects[i].selectable=true;
                        goldmine.objects[i].canMove=false;
                    
                        if(goldmine.objects[i].mousepressed==true&&anyWorkerSelected){

                            for (let w of selectedWorkers) {

                                w.workobject=goldmine.objects[i];
				w.counter2=0;
                            }
                        }


                    }
                    for(let i=0;i<tree.objects.length;i++){
                    
                        tree.objects[i].selectable=true;
                        tree.objects[i].canMove=false;
                    
                        if(tree.objects[i].mousepressed==true&&anyWorkerSelected){
                            
                             assignWorkersToNearestTreesSmart();
                        }


                    }
                    
                    
                    
                    
                    for(let i=0;i<guard.objects.length;i++){

                        guard.objects[i].selectable=true;
                        
                        if ( guard.objects[i].direction === "up")  guard.objects[i].animation = 0;
                        else if ( guard.objects[i].direction === "right")  guard.objects[i].animation = 1;
                        else if ( guard.objects[i].direction === "down")  guard.objects[i].animation = 2;
                        else if ( guard.objects[i].direction === "left")  guard.objects[i].animation = 3;
                        
                        

                    }
                    
             
                    for(let i=0;i<worker.objects.length;i++){

                        worker.objects[i].selectable=true;
			worker.objects[i].counter2++;
                        
                        
                        
                        
                        
                        if ( worker.objects[i].direction === "up")  worker.objects[i].animation = 0;
                        else if ( worker.objects[i].direction === "right")  {worker.objects[i].animation = 1;worker.objects[i].fliped=false;}
                        else if ( worker.objects[i].direction === "down")  worker.objects[i].animation = 2;
                        else if ( worker.objects[i].direction === "left") { worker.objects[i].animation = 1;worker.objects[i].fliped=true;}
                        
                        
                         for (let j = 0; j < pendingBuilds.length; j++) {
                            let building = pendingBuilds[j];

                            if (game.collideswithanoterobject(worker.objects[i],building)) {
                                building.buildProgress = (building.buildProgress || 0) + 1;
                                
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                
                                 // bygg-animation

                                if (building.buildProgress > 1000) {
                                    // Klar – ta bort från pendingBuilds
                                    pendingBuilds.splice(j, 1);
                                    building.buildProgress = null;
                                    worker.objects[i].buildingTarget = null;
                                    worker.objects[i].animation = 0; // idle
                                    building.animation=1;
                                }
                                
                            }
                        }
                        if(worker.objects[i].workobject!=null&&worker.objects[i].returning==false){
                            
                            
                            worker.objects[i].targetX = worker.objects[i].workobject.x+worker.objects[i].workobject.dimx/2;
                            worker.objects[i].targetY = worker.objects[i].workobject.y+worker.objects[i].workobject.dimy/2;
                            worker.objects[i].targetObject=worker.objects[i].workobject;
                            
                            
                        
                            
                            if(worker.objects[i].workobject.occupied==true){
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<1002) {
                                    if(worker.objects[i].animation==0)worker.objects[i].animation = 3;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 4;
                                    if(worker.objects[i].animation==2)worker.objects[i].animation = 5;
                                    if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 4;
                                    worker.objects[i].counter++;

                                }
                                if (worker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = worker.objects[i].x - b.x;
                                        let dy = worker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        worker.objects[i].targetX = closest.x+closest.dimx/2;
                                        worker.objects[i].targetY = closest.y+closest.dimy/2;
                                        worker.objects[i].targetObject=closest;
                                        worker.objects[i].returning = true; // ny flagga
                                        worker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].workobject)&&worker.objects[i].counter<202) {
                                    worker.objects[i].animation=100;
                                    worker.objects[i].counter++;

                                }
                                
                            if (worker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("base")).filter(b => b.buildProgress == null);
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = worker.objects[i].x - b.x;
                                    let dy = worker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    worker.objects[i].targetX = closest.x+closest.dimx/2;
                                    worker.objects[i].targetY = closest.y+closest.dimy/2;
                                    worker.objects[i].targetObject=closest;
                                    worker.objects[i].returning = true; // ny flagga
                                    worker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (worker.objects[i].returning && worker.objects[i].deliveryTarget) {
                            
                            
                            if(worker.objects[i].workobject.occupied==false){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 6;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 7;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =8;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 7;
                            }
                            if(worker.objects[i].workobject.occupied==true){
                                if(worker.objects[i].animation==0)worker.objects[i].animation = 9;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==false)worker.objects[i].animation = 10;
                                if(worker.objects[i].animation==2)worker.objects[i].animation =11;
                                if(worker.objects[i].animation==1&&worker.objects[i].fliped==true)worker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(worker.objects[i],worker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                worker.objects[i].returning = false;
                                worker.objects[i].deliveryTarget = null;
                                worker.objects[i].counter = 0;
                                worker.objects[i].animation = 0; // idle
                                
                                if(worker.objects[i].workobject.occupied==false)gold += 10;
                                if(worker.objects[i].workobject.occupied==true){wood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
                    
                    for(let i=0;i<rworker.objects.length;i++){

                        rworker.objects[i].selectable=true;
			rworker.objects[i].counter2++;
                        
                        
                        if(rworker.objects[i].workobject!=null && rworker.objects[i].workobject.name=="rbase")break;
                        
                        
                        if ( rworker.objects[i].direction === "up")  rworker.objects[i].animation = 0;
                        else if ( rworker.objects[i].direction === "right")  {rworker.objects[i].animation = 1;rworker.objects[i].fliped=false;}
                        else if ( rworker.objects[i].direction === "down")  rworker.objects[i].animation = 2;
                        else if ( rworker.objects[i].direction === "left") { rworker.objects[i].animation = 1;rworker.objects[i].fliped=true;}
                        
                        
                       
                                

                        if(rworker.objects[i].workobject!=null&&rworker.objects[i].returning==false){
                            
                            
                            rworker.objects[i].targetX = rworker.objects[i].workobject.x+rworker.objects[i].workobject.dimx/2;
                            rworker.objects[i].targetY = rworker.objects[i].workobject.y+rworker.objects[i].workobject.dimy/2;
                            rworker.objects[i].targetObject=rworker.objects[i].workobject;
                            
                            
                        
                            
                            if(rworker.objects[i].workobject.occupied==true){
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<1002) {
                                    if(rworker.objects[i].animation==0)rworker.objects[i].animation = 3;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 4;
                                    if(rworker.objects[i].animation==2)rworker.objects[i].animation = 5;
                                    if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 4;
                                    rworker.objects[i].counter++;

                                }
                                if (rworker.objects[i].counter > 1000) {
                                    // Hitta närmsta base
                           
                                    let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                    let closest = null;
                                    let closestDist = Infinity;
                                    for (let b of bases) {
                                        let dx = rworker.objects[i].x - b.x;
                                        let dy = rworker.objects[i].y - b.y;
                                        let dist = Math.sqrt(dx * dx + dy * dy);
                                        if (dist < closestDist) {
                                            closestDist = dist;
                                            closest = b;
                                        }
                                    }

                                    if (closest) {

                                        rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                        rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                        rworker.objects[i].targetObject=closest;
                                        rworker.objects[i].returning = true; // ny flagga
                                        rworker.objects[i].deliveryTarget = closest;
                                    }


                                }
                                
                                
                            }
                            else{
                                if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].workobject)&&rworker.objects[i].counter<202) {
                                    rworker.objects[i].animation=100;
                                    rworker.objects[i].counter++;

                                }
                                
                            if (rworker.objects[i].counter > 200) {
                                // Hitta närmsta base
                         
                                let bases = game.getAllObjectsoftype(game.getobjecttype("rbase"));
                                let closest = null;
                                let closestDist = Infinity;
                                for (let b of bases) {
                                    let dx = rworker.objects[i].x - b.x;
                                    let dy = rworker.objects[i].y - b.y;
                                    let dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist < closestDist) {
                                        closestDist = dist;
                                        closest = b;
                                    }
                                }

                                if (closest) {

                                    rworker.objects[i].targetX = closest.x+closest.dimx/2;
                                    rworker.objects[i].targetY = closest.y+closest.dimy/2;
                                    rworker.objects[i].targetObject=closest;
                                    rworker.objects[i].returning = true; // ny flagga
                                    rworker.objects[i].deliveryTarget = closest;
                                }


                            }

                            }
                            
                        }
                        if (rworker.objects[i].returning && rworker.objects[i].deliveryTarget) {
                            
                            
                            if(rworker.objects[i].workobject.occupied==false){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 6;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 7;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =8;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 7;
                            }
                            if(rworker.objects[i].workobject.occupied==true){
                                if(rworker.objects[i].animation==0)rworker.objects[i].animation = 9;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==false)rworker.objects[i].animation = 10;
                                if(rworker.objects[i].animation==2)rworker.objects[i].animation =11;
                                if(rworker.objects[i].animation==1&&rworker.objects[i].fliped==true)rworker.objects[i].animation = 10;
                            }
                            
                            
                            
                            if (game.collideswithanoterobject(rworker.objects[i],rworker.objects[i].deliveryTarget)) {
                                // Levererat resurser!
                                rworker.objects[i].returning = false;
                                rworker.objects[i].deliveryTarget = null;
                                rworker.objects[i].counter = 0;
                                rworker.objects[i].animation = 0; // idle
                                
                                if(rworker.objects[i].workobject.occupied==false)rgold += 10;
                                if(rworker.objects[i].workobject.occupied==true){rwood += 10;}
                                
                                // (Valfritt) Öka guldmängd här
                                // gold += 10;
                            }
                        }
                        
                        
                        
                        

                    }
                    
                
                }

                 
                 
                window.requestAnimationFrame(check);   
            };check();
            
            function isBuildPlacementValid(o) {
                if (!o || !o.collideslistan) return false;
                
                            // Avståndsgräns från resurser (t.ex. 100 pixlar)
                const minDistanceToResources = 300;
                const resourceTypes = ["tree", "goldmine"]; // eller hur du identifierar resurser

                for (let type of resourceTypes) {
                    const resources = game.getAllObjectsoftype(game.getobjecttype(type));
                    for (let res of resources) {
                        const dist = game.getDistance(o.x, o.y, res.x, res.y);
                        if (dist < minDistanceToResources) {
                            return false; // För nära en resurs
                        }
                    }
                }
                
                
                
                return o.collideslistan.length === 0;
            }
            function cancelBuildMode() {
   
                
                if (ghostBuilding) {
                    gold+=1000;wood+=1000;
                    game.removeobject(game.getobjecttype("base"),ghostBuilding); // ⬅️ Viktigt!
                    ghostBuilding = null;
                }
                buildMode = false;
                buildType = null;
                selectedWorkersBeforeBuild = [];
                isPlacingBuilding = false;
                console.log("Byggläge avbrutet");
            }
            function assignWorkersToNearestTreesSmart() {
                    const allTrees = game.getAllObjectsoftype(game.getobjecttype("tree"))
                        .filter(t => !t.occupied); // inga distansfilter här

                    const assignedTrees = new Set();

                    for (let w of selectedWorkers) {
                        if(w.workobject!=null)return;
                        
                        let bestTree = null;
                        let bestScore = Infinity;

                        for (let t of allTrees) {
                            if (assignedTrees.has(t)) continue;
                            const distToWorker = getManualDistance(t.x, t.y, w.x, w.y);
                      

                            if (distToWorker < bestScore) {
                                //alert(t.x+" "+ t.y+" "+ w.x+" "+ w.y);
                                
                                bestScore = distToWorker;
                                bestTree = t;
                            }
                        }
                        //alert("NY");
                        if (bestTree) {
                            
                            
                            
                            w.targetX = bestTree.x + bestTree.dimx / 2;
                            w.targetY = bestTree.y + bestTree.dimy / 2;
                            w.workobject = bestTree;
                            w.returning = false;
                            w.counter2 = 0;
                            bestTree.occupied = true;
                            assignedTrees.add(bestTree);
                        }
                    }
                }
            function getManualDistance(x1, y1, x2, y2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
 
            
            
            function enemyTryToBuildBase() {
                
                  const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
                for (let w of rworkers) {
            
                    if (w.workobject && w.workobject.name=="rbase") {
                        // Börja bygga
                
                        if (game.collideswithanoterobject(w,w.workobject)) {
                            w.workobject.buildProgress += 1;
                            if(w.animation==0)w.animation = 3;
                                if(w.animation==1&&w.fliped==false)w.animation = 4;
                                if(w.animation==2)w.animation = 5;
                                if(w.animation==1&&w.fliped==true)w.animation = 4;
                            
                            
                            if (w.workobject.buildProgress > 1000) {
                                w.workobject.ghost = false;
                                w.workobject.selectable = true;
                                w.workobject.animation=1;
                                w.workobject = null;
                                
                            }
                        }
                    }
                }
                
                
       if (rwood < 1000 || rgold < 1000) return;

    const rbaseType = game.getobjecttype("rbase");

    // Finns redan en bas eller ghost-bygge?
    const baseExists = game.getAllObjects().some(o =>
        o.type === rbaseType && (!o.ghost || o.ghost === true)
    );
    if (baseExists) return;

    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));
    if (mines.length === 0) return;

    if (rworkers.length === 0) return;

    const mine = mines[1]; // använd första gruvan
    const spacing = 100;
    let bestPos = null;
    let bestScore = Infinity;

    for (let dx = -5; dx <= 5; dx++) {
        for (let dy = -5; dy <= 5; dy++) {
            const px = mine.x + dx * spacing;
            const py = mine.y + dy * spacing;

            const temp = game.addobject(
                rbaseType,
                px,
                py,
                rbaseType.standarddimx,
                rbaseType.standarddimy,
                0,
                false
                        
            );
            temp.ghost = true;

            if (isBuildPlacementValid(temp)) {
                const distToMine = game.getDistance(px, py, mine.x, mine.y);

                // Hitta närmaste rworker
                let closestWorkerDist = Infinity;
                for (let w of rworkers) {
                    const d = game.getDistance(px, py, w.x, w.y);
                    if (d < closestWorkerDist) closestWorkerDist = d;
                }

                const score = distToMine*1 + closestWorkerDist*0.5; // ev. viktning här

                if (score < bestScore) {
                    bestScore = score;
                    bestPos = { x: px, y: py };
                }
            }

            game.removeobject(rbaseType, temp);
        }
    }

    if (bestPos) {
        const ghost = game.addobject(
            rbaseType,
            bestPos.x,
            bestPos.y,
            rbaseType.standarddimx,
            rbaseType.standarddimy,
            0,
            false
        );
        ghost.ghost = false;
        ghost.canMove = false;
        ghost.selectable = false;
        ghost.enemyBuild = true;
        ghost.buildProgress = 0;

        for (let w of rworkers) {
            w.targetX = bestPos.x;
            w.targetY = bestPos.y;
            w.workobject = ghost;
            w.counter2 = 0;
        }

        rwood -= 1000;
        rgold -= 1000;
    }
}
function updateRedWorkerAI() {
    const rworkers = game.getAllObjectsoftype(game.getobjecttype("rworker"));
    const trees = game.getAllObjectsoftype(game.getobjecttype("tree")).filter(t => !t.occupied);
    const mines = game.getAllObjectsoftype(game.getobjecttype("goldmine"));

    for (let w of rworkers) {
        let istree=true;
        // Hoppa över om redan jobbar
        if (w.workobject || w.buildingTarget) continue;

        let bestTarget = null;
        let bestDist = Infinity;

        // Sök träd först
     //   for (let t of trees) {
     //       const d = game.getDistance(w.x, w.y, t.x, t.y);
    //        if (d < bestDist) {
   //             bestDist = d;
    //            bestTarget = t;
   //         }
   //     }

        // Om inget träd, kolla gruva
        if (!bestTarget && mines.length > 0) {
            for (let m of mines) {
                const d = game.getDistance(w.x, w.y, m.x, m.y);
                if (d < bestDist) {
                    bestDist = d;
                    bestTarget = m;
                    istree=false;
                }
            }
        }

        if (bestTarget) {
            w.targetX = bestTarget.x;
            w.targetY = bestTarget.y;
            w.workobject = bestTarget;
            w.returning = false;
            w.counter2 = 0;
            if(istree) bestTarget.occupied = true;
        }
    }
}            
            
        </script>
    </body>
</html>
