<!DOCTYPE html>
<html lang="sv">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta charset="UTF-8">
  <title>Turnering (Fantasy Edition)</title>
  <style>
    body {
      font-family: 'Papyrus', fantasy;
      background: #1c1c1c;
      color: #f2e8c9;
      padding: 1rem;
      text-align: center;
    }
    h1, h2 {
      color: #ffe680;
      text-shadow: 1px 1px #000;
    }
    input, button, select {
      margin: 0.2rem;
      padding: 0.3rem 0.6rem;
      border-radius: 5px;
      border: 1px solid #8c7c5b;
      background: #2e2e2e;
      color: #f2e8c9;
    }
    button {
      background-color: #5e4b2b;
      color: #ffe680;
      cursor: pointer;
    }
    button:hover {
      background-color: #7b5f36;
    }
    .team {
      margin: 0.5rem 0;
      padding: 0.5rem;
      border: 1px solid #8c7c5b;
      background: #2e2e2e;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    .compact input { width: 120px; }
    .hidden { display: none; }
    .winner { background-color: #334422 !important; }
    .loser { opacity: 0.6; }
    ol#rankingList li:nth-child(1) { color: gold; font-weight: bold; }
    ol#rankingList li:nth-child(2) { color: silver; }
    ol#rankingList li:nth-child(3) { color: peru; }
    
    ol#rankingList {
  list-style-position: inside;
  padding-left: 0;
  text-align: center;

  margin: 0 auto;
}
    
  </style>
</head>
<body>
  <h1>⚔️ Turnering: Hjältarnas Prövning ⚔️</h1>
  <label for="requireHealer">🧙‍♀️ Måste varje lag ha en healer? </label>
  <input type="checkbox" id="requireHealer" checked>
  <br>
  <label for="teamSize">👥 Lagstorlek: </label>
  <select id="teamSize" onchange="adjustInputSize()">
    <option value="2">2v2</option>
    <option value="3">3v3</option>
    <option value="5" selected>5v5</option>
  </select>

  <h2>🧝‍♂️ Hjältar</h2>
  <div id="playerInputs"></div>
  <label for="matchCount">🌀 Antal matcher: </label>
  <input type="number" id="matchCount" value="5" min="1" max="20">
  <button onclick="generateRounds()">🎮 Skapa rundor</button>

  <h2>🗡️ Strider</h2>
  <div id="rounds"></div>

  <h2>🏅 Ranking</h2>
  <button onclick="showRanking()">🔮 Beräkna ranking</button>
  <ol id="rankingList"></ol>

  <script>
    const playerInputs = document.getElementById("playerInputs");
    const roundsContainer = document.getElementById("rounds");
    const rankingList = document.getElementById("rankingList");




    function createPlayerInputs() {
      playerInputs.innerHTML = "";
      for (let i = 0; i < 10; i++) {
        const container = document.createElement("div");
        container.id = `playerContainer${i}`;
        const input = document.createElement("input");
        input.placeholder = `Namn på hjälte ${i + 1}`;
        input.id = `player${i}`;
        const select = document.createElement("select");
        select.id = `role${i}`;
        select.innerHTML = `<option value="dps">DPS</option><option value="healer">Healer</option>`;
        container.appendChild(input);
        container.appendChild(select);
        playerInputs.appendChild(container);
      }
    }
    function adjustInputSize() {
      const size = parseInt(document.getElementById("teamSize").value);
      if (size <= 3) {
        playerInputs.classList.add("compact");
      } else {
        playerInputs.classList.remove("compact");
      }

      const visibleCount = size * 2;
      for (let i = 0; i < 10; i++) {
        const container = document.getElementById(`playerContainer${i}`);
        if (i < visibleCount) {
          container.classList.remove("hidden");
        } else {
          container.classList.add("hidden");
        }
      }
    }

    createPlayerInputs();
    adjustInputSize();

    let players = [];
    let rounds = [];
    let results = [];

function generateRounds() {
  players = [];
  const requireHealer = document.getElementById("requireHealer").checked;
  const teamSize = parseInt(document.getElementById("teamSize").value);

  for (let i = 0; i < 10; i++) {
    const container = document.getElementById(`playerContainer${i}`);
    if (container.classList.contains("hidden")) continue;
    const name = document.getElementById(`player${i}`).value.trim();
    const role = document.getElementById(`role${i}`).value;
    if (name) players.push({ name, role });
  }

  if (players.length < teamSize * 2) {
    alert(`Minst ${teamSize * 2} hjältar krävs för ${teamSize}v${teamSize}.`);
    return;
  }

  const desiredMatchCount = parseInt(document.getElementById("matchCount").value);
  if (isNaN(desiredMatchCount) || desiredMatchCount < 1 || desiredMatchCount > 1000) {
    alert("Ange ett giltigt antal matcher (1–1000).");
    return;
  }

  function combinations(arr, k) {
    const res = [];
    function helper(start, combo) {
      if (combo.length === k) {
        res.push(combo);
        return;
      }
      for (let i = start; i < arr.length; i++) {
        helper(i + 1, combo.concat([arr[i]]));
      }
    }
    helper(0, []);
    return res;
  }

  function teamKey(team) {
    return team.map(p => p.name).sort().join(",");
  }

  const healers = players.filter(p => p.role === "healer");
  const dps = players.filter(p => p.role === "dps");
  const possibleTeams = [];

  if (requireHealer) {
    if (healers.length < 2) {
      alert("Minst två healers krävs för att skapa lag med healer-krav.");
      return;
    }
    const dpsCombos = combinations(dps, teamSize - 1);
    healers.forEach(healer => {
      dpsCombos.forEach(dpsGroup => {
        possibleTeams.push([healer, ...dpsGroup]);
      });
    });
  } else {
    possibleTeams.push(...combinations(players, teamSize));
  }

  const baseRounds = [];
  const usedCombos = new Set();

  for (let i = 0; i < possibleTeams.length; i++) {
    for (let j = i + 1; j < possibleTeams.length; j++) {
      const team1 = possibleTeams[i];
      const team2 = possibleTeams[j];
      const names1 = team1.map(p => p.name);
      const names2 = team2.map(p => p.name);
      if (names1.some(name => names2.includes(name))) continue;
      const key = [...names1.sort(), '|', ...names2.sort()].join("");
      if (usedCombos.has(key)) continue;
      usedCombos.add(key);
      baseRounds.push({ team1, team2 });
    }
  }

  if (baseRounds.length === 0) {
    alert("Kunde inte skapa några matcher med givna begränsningar.");
    return;
  }

  rounds = [];
  results = [];
  const usedRecently = new Set();
  const shuffledBase = [...baseRounds];

  while (rounds.length < desiredMatchCount) {
    const available = shuffledBase.filter(match => {
      const key = teamKey(match.team1) + '|' + teamKey(match.team2);
      return !usedRecently.has(key);
    });

    if (available.length === 0) usedRecently.clear();

    const matchPool = available.length > 0 ? available : shuffledBase;
    const nextMatch = matchPool[Math.floor(Math.random() * matchPool.length)];
    const key = teamKey(nextMatch.team1) + '|' + teamKey(nextMatch.team2);

    rounds.push({
      team1: nextMatch.team1,
      team2: nextMatch.team2
    });
    results.push(null);
    usedRecently.add(key);
  }

  if (baseRounds.length < desiredMatchCount) {
    const info = document.createElement("p");
    info.style.color = "#ccc";
    info.textContent = `${baseRounds.length} unika matcher hittades. Matcher upprepas för att nå ${desiredMatchCount} rundor.`;
    roundsContainer.innerHTML = "";
    roundsContainer.appendChild(info);
  }

  showRounds();
}


    function showRounds() {
      roundsContainer.innerHTML = "";
      rounds.forEach((round, index) => {
        const div = document.createElement("div");
        div.className = "team";
        div.innerHTML = `
          <strong>🧩 Runda ${index + 1} (${round.team1.length}v${round.team2.length})</strong><br>
          <b>⚔️ Lag 1:</b> ${round.team1.map(p => p.name).join(", ")}<br>
          <b>🛡️ Lag 2:</b> ${round.team2.map(p => p.name).join(", ")}<br>
          <label>Vinnare: </label>
          <select onchange="setWinner(${index}, this.value)">
            <option value="">-</option>
            <option value="team1">Lag 1</option>
            <option value="team2">Lag 2</option>
          </select>
        `;
        roundsContainer.appendChild(div);
      });
    }

    function setWinner(index, value) {
      results[index] = value;
    }

    function showRanking() {
      if (results.includes(null)) {
        alert("Alla rundor måste ha en vinnare.");
        return;
      }

      const scores = {};
      const wins = {};
      const games = {};
      players.forEach(p => {
        scores[p.name] = 0;
        wins[p.name] = 0;
        games[p.name] = 0;
      });

      rounds.forEach((round, i) => {
        const winners = round[results[i]];
        const losers = results[i] === "team1" ? round.team2 : round.team1;

        winners.forEach(p => {
          scores[p.name] += 1;
          wins[p.name] += 1;
          games[p.name] += 1;
        });
        losers.forEach(p => {
          games[p.name] += 1;
        });
      });

      const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
      rankingList.innerHTML = "";
      sorted.forEach(([name, score], i) => {
        const percent = ((wins[name] / games[name]) * 100).toFixed(1);
        const li = document.createElement("li");
        li.textContent = `${name} (${score} poäng, ${percent}% vinster)`;
        rankingList.appendChild(li);
      });

      const winner = sorted[0][0];
      const message = document.createElement("p");
      message.innerHTML = `<strong>🏆 ${winner} är turneringens mästare! 🥳</strong>`;
      rankingList.parentElement.appendChild(message);
    }
  </script>
<audio id="bgMusic" src="wow.mp3" loop></audio>
<button id="muteBtn" onclick="toggleMute()">🔈 Mute</button>
<script>
  const bgMusic = document.getElementById("bgMusic");
  let bgStarted = false;
  let isMuted = false;
  let musicstopped=false;
  function playEffects() {
        
    try{if(bgMusic.paused&&musicstopped==false){ 
       bgMusic.play();
    }
    }catch(error){};  
    }
    function toggleMute() {
        isMuted = !isMuted;
        bgMusic.muted = isMuted;
        muteBtn.textContent = isMuted ? "🔇 Unmute" : "🔈 Mute";
    }
   const originalColors = ["#2e2e2e", "#443a29", "#3a2f2f", "#2c3e50", "#2f2f2f"];
   let conter=0;
  function randomColor() {
      conter++;
      if(conter==5)conter=1;
      
    return originalColors[conter];
  }

  const originalShowRounds = showRounds;
  showRounds = function() {
    roundsContainer.innerHTML = "";
    rounds.forEach((round, index) => {
      const div = document.createElement("div");
      div.className = "team";
      div.style.background = randomColor();
      div.innerHTML = `
        <strong>🧩 Runda ${index + 1} (${round.team1.length}v${round.team2.length})</strong><br>
        <b>⚔️ Lag 1:</b> ${round.team1.map(p => p.name).join(", ")}<br>
        <b>🛡️ Lag 2:</b> ${round.team2.map(p => p.name).join(", ")}<br>
        <label>Vinnare: </label>
        <select onchange="setWinner(${index}, this.value)">
          <option value="">-</option>
          <option value="team1">Lag 1</option>
          <option value="team2">Lag 2</option>
        </select>
      `;
      roundsContainer.appendChild(div);
    });
  }

  document.addEventListener("click", playEffects);
  document.addEventListener("touchstart", playEffects);
  
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden"||document.visibilityState != "visible") {
        // When the page is hidden, pause the music and clear its source to release resources
        bgMusic.pause();
        bgMusic.src = ""; // This stops the download and releases the audio stream
        musicstopped = true; // Mark that music was stopped due to visibility
    } else {
        // When the page becomes visible again
        if (!isMuted) { // Only attempt to play if the user hasn't manually muted it
            bgMusic.src = "wow.mp3"; // Re-assign the source
            bgMusic.load(); // Load the new source
            bgMusic.play().catch(e => console.log("Autoplay prevented:", e)); // Attempt to play, catch potential autoplay errors
            musicstopped = false; // Mark that music is no longer stopped by visibility
        }
    }
});
  
</script>
</body>
</html>