<html>
    <head>
        <meta name="viewport" content="user-scalable=no, shrink-to-fit=no">
        <meta charset="utf-8">
        <meta name="keywords" content="golvläggningsprogram, golvläggnings program">
        <link rel="icon" href="bilder/trä.jpg" type="image/vnd.microsoft.icon" />
	    <title>Golv</title>
    
            
<style>

html, body { background:#121417; }

</style>
            
<style>
  :root{
    --ui-bg: rgba(28,28,30,.96);
    --ui-fg: #fff;
    --ui-accent:#3b82f6;
    --ui-muted: rgba(255,255,255,.7);
    --ui-border: rgba(255,255,255,.12);
    --safe-bottom: env(safe-area-inset-bottom,12px);
  }
  #floor-ui{ position:fixed; left:50%; bottom:var(--safe-bottom); transform:translateX(-50%);
    width:min(880px,96vw); background:var(--ui-bg); color:var(--ui-fg);
    border:1px solid var(--ui-border); border-radius:16px; padding:12px; z-index:1000;
    box-shadow:0 18px 45px rgba(0,0,0,.35); }
  #floor-ui *{ box-sizing:border-box; }
  #floor-ui .title{ font-weight:600; letter-spacing:.2px; }
  #floor-ui .bar{ display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
  
  #floor-ui .actions{ display:flex; gap:10px; align-items:center; }
  #floor-ui .grid{ display:grid; gap:10px; margin-top:8px; }
  #floor-ui .cols-2{ grid-template-columns:1fr 1fr; }
  #floor-ui .cols-3{ grid-template-columns:1fr 1fr 1fr; }
  #floor-ui label{ font-size:16px; color:var(--ui-muted); display:block; margin:2px 2px 6px; }
  #floor-ui input[type="number"]{
    width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--ui-border);
    background:rgba(255,255,255,.08); color:var(--ui-fg); font-size:18px; outline:none;
  }
  #floor-ui .seg{ display:grid; grid-auto-flow:column; gap:6px; background:rgba(255,255,255,.06);
    padding:6px; border-radius:10px; }
  #floor-ui .seg button{ border:1px solid var(--ui-border); border-radius:8px;
    background:rgba(255,255,255,.06); color:var(--ui-fg); padding:8px 10px; font-size:18px; }
  #floor-ui .seg button.active{ background:var(--ui-accent); border-color:var(--ui-accent); }
  #ui-tiles{ display:none; } /* visas bara när programmnummer=1 */
  /* Dölj gamla DOM-kontroller helt */
  .legacy-hide{ display:none !important; visibility:hidden !important; pointer-events:none !important; }
</style>
            
<style>
  /* Tillåt skroll */
  html, body { overflow: auto; height: auto; }

  /* Reservyta underst = panelens höjd */
  :root { --floor-ui-h: 140px; }            /* default tills JS mäter */
  body { padding-bottom: var(--floor-ui-h); }

  /* Collapse-läge för panelen */
  #floor-ui.collapsed{
    transform: translateY(calc(100% - 38px));  /* lämna kvar en flik */
    transition: transform .22s ease;
  }
  #floor-ui:not(.collapsed){ transition: transform .22s ease; }

  /* Liten flik/knapp i panelens topp-rad */
  #floor-ui .toggle {
    border:1px solid var(--ui-border);
    border-radius:8px;
    background:rgba(255,255,255,.08);
    color:#fff; padding:6px 10px; font-size:18px;
    cursor:pointer;
  }
</style>            
            
            
            
    </head>
    <body>
        <canvas id="myCanvas" width="10" height="10" style="border:0px solid black"></canvas>



        
        
        
        <script>
            

            
            
            let PLAN_BITMAP = null; 
            const kaprader = {Första1: 0,Sista1: 0,antal1:0,Första2: 0,Sista2: 0,antal2:0,Första3: 0,Sista3: 0,antal3:0,Första4: 0,Sista4: 0,antal4:0,Första5: 0,Sista5: 0,antal5:0};
            const kapraderdata={FörstaSistaKap:0,HelaBrädor:0,Brädor:0,M2BrädorKöpa:0,Totalyta:0,Golvyta:0,utnyttjande:0};
            
            
            const harringbone = {
                starttrianglar: 0,
                högertriangeln: 0,
                vänstertriangeln: 0,
                helabrädor:0,
                brädor:0,
                M2brädor:0,
                end: [],
                bits: {
                  höger1:  { long:0, short:0, color:"", count:0 },
                  höger2:  { long:0, short:0, color:"", count:0 },
                  vänster1:{ long:0, short:0, color:"", count:0 },
                  vänster2:{ long:0, short:0, color:"", count:0 }
                }
              };
            
                    
            
            
////GAMMALT---------------------------------------------------------------------------------------------------------------------   
////GAMMALT--------------------------------------------------------------------------------------------------------------------- 
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            document.getElementById("myCanvas").style.width=window.innerWidth;
            document.getElementById("myCanvas").style.height=window.innerHeight;
 
            var cursorX;
            var cursorY;
            document.onmousemove = function(e){
                cursorX = e.pageX;
                cursorY = e.pageY;
            };

            canvas.onclick = function(){
                
                if(cursorX<200&&cursorY<200)
                    window.location.href = "https://quantumstahl.github.io/";
                 


            };
        
        
        
            var input = document.createElement('input');document.body.appendChild(input);
            var input2 = document.createElement('input');document.body.appendChild(input2);
            var input3 = document.createElement('input');document.body.appendChild(input3);
            var input4 = document.createElement('input');document.body.appendChild(input4);
            var input5 = document.createElement('input');document.body.appendChild(input5);
            

        
            var button = document.createElement("button");document.body.appendChild(button);
            var button3 = document.createElement("button");document.body.appendChild(button3);
            var button4 = document.createElement("button");document.body.appendChild(button4);  
            var button5 = document.createElement("button");document.body.appendChild(button5);
            var button6 = document.createElement("button");document.body.appendChild(button6);
            var button7 = document.createElement("button");document.body.appendChild(button7);
            var button8 = document.createElement("button");document.body.appendChild(button8);
            var button9 = document.createElement("button");document.body.appendChild(button9);

            input.value=4000 ; 
            input2.value=4000 ; 
            input3.value=1000 ; 
            input4.value=200 ; 
            input5.value=1.5 ; 
        
            brada_image = new Image();
            brada_image.src = 'bilder/tra.jpg';
          
            base_image = new Image();
            base_image.src = 'bilder/loggo.png';
            
            kilnker_image= new Image();
            kilnker_image.src = 'bilder/kakel.jpg';
    
            vinyl_image= new Image();
            vinyl_image.src = 'bilder/vinyl.jpg';
    
            var array = [];
            let element = {lenght: 0, width: 0, row: 0, start:0};  
            let element2 = {lenght: 0, width: 0, row: 0, start:0};
            let elementstart = {lenght: 0, width: 0, row: 0, start:0};
            
            let firstnummber=0;
            let woody=100;
            let woodcalc=0;
            let miniwood=0;
            let rowcontertext=0;
            let capx=input.value;
            let capy=input2.value;
            let rows=input2.value/input4.value;
            let startansa=true;
            let breddkapad=0;
            let programmnummer=0;
            let programmnummer2=0;
            let rotateroom=false;
            
            
            setbuttonlocation(button,0,230);                
            setbuttonlocation(button3,0,300);
            setbuttonlocation(button4,0,580);               
            setbuttonlocation(button5,0,370);
            setbuttonlocation(button6,0,440);
            setbuttonlocation(button7,0,510);
            setbuttonlocation(button8,0,650);
            setbuttonlocation(button9,180, 400);
            
            
            
            
            
            
            
            
            var check = function(){
                
                try{
                
                kaprader.Första1=0;
                kaprader.Första2=0;
                kaprader.Första3=0;
                kaprader.Första4=0;
                kaprader.Första5=0;
                kaprader.Sista1=0;
                kaprader.Sista2=0;
                kaprader.Sista3=0;
                kaprader.Sista4=0;
                kaprader.Sista5=0;
                kaprader.antal1=0;
                kaprader.antal2=0;
                kaprader.antal3=0;
                kaprader.antal4=0;
                kaprader.antal5=0;
                
                kapraderdata.FörstaSistaKap=0;
                kapraderdata.HelaBrädor=0;
                kapraderdata.Brädor=0;
                kapraderdata.M2BrädorKöpa=0;
                kapraderdata.Golvyta=0;
                kapraderdata.Totalyta=0;
                kapraderdata.utnyttjande=0;
                
                harringbone.starttrianglar=0;
                harringbone.högertriangeln=0;
                harringbone.vänstertriangeln=0;
                harringbone.bits.höger1.count=0;
                harringbone.bits.höger2.count=0;
                harringbone.bits.vänster1.count=0;
                harringbone.bits.vänster2.count=0;

                harringbone.end=[];
                
                
                
                canvas.width=document.body.clientWidth-8;
                canvas.height=document.body.clientHeight-8;
                
            //    const my_gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            //    my_gradient.addColorStop(0, "white");
            //    my_gradient.addColorStop(1, "gray");
           //     ctx.fillStyle = "lightgray";
            //    ctx.fillRect(0, 0, canvas.width, canvas.height);
 
 
                setinputlocation(input,canvas.width/2-120,20);
                setinputlocation(input2,canvas.width/2-120,90);
                setinputlocation(input3,canvas.width/2-120,160);
                setinputlocation(input4,canvas.width/2-120,230);
                setinputlocation(input5,canvas.width/2-120,300);
                
             
                ctx.font = "18px serif";
                ctx.fillStyle = "black";
                ctx.fillText("Golvläggnings program", 10, 215);
                ctx.fillText("Rummets bredd", canvas.width/2-245, 50);
                ctx.fillText("Rummets djup", canvas.width/2-235, 120);
                ctx.fillText("Brädas längd", canvas.width/2-225, 190);
                ctx.fillText("Brädas bredd", canvas.width/2-225, 260);
                ctx.fillText("Distans per M", canvas.width/2-235, 330);

                ctx.drawImage(base_image, 0, 0,200,200);
                
                
                
                
                
                
                    ctx.fillStyle = "white";
                    ctx.fillRect((canvas.width/2)-(input.value/20), 450, input.value/10, input2.value/10);
                
                if(input3.value<260||input4.value<50||input.value>1000000||input2.value>1000000||input.value<200||input2.value<200){}
                else{
               
                   
                    capx=input.value-((input5.value*input.value)/1000);
                    capy=input2.value-((input5.value*input2.value)/1000);
               
                    if(rotateroom){
                        
                        
                        capy=input.value-((input5.value*input.value)/1000);
                        capx=input2.value-((input5.value*input2.value)/1000);
                        
                    }

                
                    
                    

                    if(programmnummer==0){
//000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000                           
                        array =[];
                        rows=capy/input4.value;

                        rows=Math.ceil(rows);
                        breddkapad=0;
         //   if(!rotateroom){            
                        if(rows*input4.value>capy){

                            breddkapad=rows*input4.value-capy;
                            breddkapad=breddkapad/2;
                            breddkapad=breddkapad;
                            if(rows==1)breddkapad=breddkapad*2;

                            breddkapad=Math.ceil(breddkapad);

                        }

                        let xposition=0;
                            for (let i = 0; i < rows; i++) {

                                while(xposition<=capx){
                                    if((capx-xposition)>input3.value){

                                        if(xposition==0){

                                            let firstbrada=parseInt(calcfirstwood());

                                            if(breddkapad>0&&(i==0||i==rows-1)){
                                                element = {lenght: parseInt(firstbrada), width: input4.value-breddkapad, row: i, start:xposition};
                                                array.push(element);

                                            }
                                            else{
                                                element = {lenght: parseInt(firstbrada), width: input4.value, row: i, start:xposition};
                                                array.push(element);
                                            }
                                            xposition=xposition+firstbrada;
                                        }
                                        else{
                                            if(breddkapad>0&&(i==0||i==rows-1)){
                                                element = {lenght: parseInt(input3.value), width: input4.value-breddkapad, row: i, start:xposition};
                                                array.push(element);

                                            }
                                            else{
                                                element = {lenght: parseInt(input3.value), width: input4.value, row: i, start:xposition};
                                                array.push(element);
                                            }
                                            xposition=xposition+parseInt(input3.value); 
                                        }
                                    }
                                    else{
                                        if(parseInt((capx-xposition))==0){}
                                        else if(breddkapad>0&&(i==0||i==rows-1)){
                                            element = {lenght: parseInt(capx-xposition), width: input4.value-breddkapad, row: i, start:xposition};
                                            array.push(element);

                                        }
                                        else{
                                            element = {lenght: parseInt(capx-xposition), width: input4.value, row: i, start:xposition};
                                            array.push(element);

                                        }
                                        xposition=xposition+100000;
                                    }
                                }
                                xposition=0;
                            }
                            firstnummber=0;
              //  }            
               
                            
                            
                        if(rotateroom){    
                            ctx.save();ctx.translate(canvas.width/2, 450+(input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450+(input2.value/20)));    
                            for(let i = 0; i < array.length; i++){           
                                element=array[i];
                                ctx.fillStyle = "black";

                            
    
                                if(element.row==0){
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                                }
                                else if(element.row==rows-1){
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                                }
                                else{
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                                }


                        }
                            
                            
                            ctx.restore();
                        }
                        else{
                            
                            for(let i = 0; i < array.length; i++){           
                                element=array[i];
                                ctx.fillStyle = "black";

                                if(element.row==0){
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                                }
                                else if(element.row==rows-1){
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                                }
                                else{
                                    ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                    ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                                }
                            }
      
                        }
                        
                        
                        
                        
                        
                        
                        
                        
                        

                        ctx.font = "25px serif";
                        ctx.fillStyle = "black";

                        rowcontertext=0;
                        let antalförsta1=0;
                        let antalförsta2=0;
                        let antalförsta3=0;
                        let antalförsta4=0;
                        let antalförsta5=0;
                        
                        for(let i = 0; i < array.length; i++){
                            element=array[i];
                            element2=array[i-1];
                            if(rowcontertext==0||element.row>element2.row){
                                if(rowcontertext==5)rowcontertext=0;
                                if(rowcontertext==0)
                                    antalförsta1++;
                                if(rowcontertext==1)
                                    antalförsta2++;
                                if(rowcontertext==2)    
                                   antalförsta3++;
                                if(rowcontertext==3) 
                                    antalförsta4++;
                                if(rowcontertext==4)
                                    antalförsta5++;
                                rowcontertext++;
                                
                            }
                        }                        
                        rowcontertext=0;
       
                        for(let i = 0; i < array.length; i++){
                            element=array[i];
                            element2=array[i-1];
                            if(rowcontertext==0||element.row>element2.row){
                                if(rowcontertext==0){kaprader.Första1=element.lenght;kaprader.antal1=antalförsta1;}
                                    ///ctx.fillText("Rad1:Första brädans längd:"+element.lenght +" X:"+antalförsta1, canvas.width/2+80, 40);
                                if(rowcontertext==1){kaprader.Första2=element.lenght;kaprader.antal2=antalförsta2;}
                                   // ctx.fillText("Rad2:Första brädans längd:"+element.lenght+" X:"+antalförsta2, canvas.width/2+80, 110);
                                if(rowcontertext==2){kaprader.Första3=element.lenght;kaprader.antal3=antalförsta3;}    
                                  // ctx.fillText("Rad3:Första brädans längd:"+element.lenght+" X:"+antalförsta3, canvas.width/2+80, 180);
                                if(rowcontertext==3){kaprader.Första4=element.lenght;kaprader.antal4=antalförsta4;} 
                                  //  ctx.fillText("Rad4:Första brädans längd:"+element.lenght+" X:"+antalförsta4, canvas.width/2+80, 250);
                                if(rowcontertext==4){kaprader.Första5=element.lenght;kaprader.antal5=antalförsta5;}
                                   // ctx.fillText("Rad5:Första brädans längd:"+element.lenght+" X:"+antalförsta5, canvas.width/2+80, 320);
                                rowcontertext++;
                            }
                        }

                        element=array[0];
                        element2=array[1];
                   
                        if(element.row<element2.row){}
                        else{
                            rowcontertext=0;
                            for(let i = 0; i < array.length; i++){
                                element=array[i];
                                element2=array[i+1];
                                if(i==array.length-1||element.row<element2.row){
                                    if(rowcontertext==0)kaprader.Sista1=element.lenght;
                                        //ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta1, canvas.width/2+140, 70);
                                    if(rowcontertext==1)kaprader.Sista2=element.lenght;
                                      //  ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta2, canvas.width/2+140, 140);
                                    if(rowcontertext==2)kaprader.Sista3=element.lenght;    
                                      // ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta3, canvas.width/2+140, 210);
                                    if(rowcontertext==3)kaprader.Sista4=element.lenght; 
                                      //  ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta4, canvas.width/2+140, 280);
                                    if(rowcontertext==4)kaprader.Sista5=element.lenght;
                                      //  ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta5, canvas.width/2+140, 350);
                                    rowcontertext++;
                                }
                            }
                        }
                        antalförsta1=0;
                        let antalbrädorrr=0;
                        for(let i = 0; i < array.length; i++){
                             element=array[i];
                             antalbrädorrr++;
                             if(element.lenght==input3.value){
                                 antalförsta1++;
                                 
                             }
                            
                        }
                        ctx.fillStyle = "black";
                       // ctx.fillText("Första/sista radens kap:"+breddkapad, canvas.width/2+200, 400);
                       kapraderdata.FörstaSistaKap=breddkapad;
                       
                       
                       // ctx.fillText("Hela brädor:"+antalförsta1, canvas.width/2+200, 430);
                        kapraderdata.HelaBrädor=antalförsta1;
                        
                        
                        
                        ctx.font = "25px serif";
                        ctx.fillStyle = "black";
                        //ctx.fillText("Brädor:" + (antalbrädorrr) +" M2:"+Math.round(((((antalbrädorrr))*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100, canvas.width/2-200, 390);
                        kapraderdata.Brädor=antalbrädorrr;
                        kapraderdata.M2BrädorKöpa=Math.round(((((antalbrädorrr))*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100;
                        
                        
                }
                if(programmnummer==1){
//1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111                    
                     
                        array =[];
                        rows=capy/input4.value;
                        rows=Math.ceil(rows);
                        breddkapad=0;

                        if(rows*input4.value>capy){

                            breddkapad=rows*input4.value-capy;
                            breddkapad=breddkapad/2;
                            breddkapad=breddkapad;
                            if(rows==1)breddkapad=breddkapad*2;

                            breddkapad=Math.ceil(breddkapad);

                        }

                        let xposition=0;
                            for (let i = 0; i < rows; i++) {

                                while(xposition<=capx){
                                    if((capx-xposition)>input3.value){

                                        if(xposition==0){

                                            let firstbrada=parseInt(calcfirtsclincer());

                                            if(breddkapad>0&&(i==0||i==rows-1)){
                                                element = {lenght: parseInt(firstbrada), width: input4.value-breddkapad, row: i, start:xposition};
                                                array.push(element);

                                            }
                                            else{
                                                element = {lenght: parseInt(firstbrada), width: input4.value, row: i, start:xposition};
                                                array.push(element);
                                            }
                                            xposition=xposition+firstbrada;



                                        }
                                        else{
                                            if(breddkapad>0&&(i==0||i==rows-1)){
                                                element = {lenght: parseInt(input3.value), width: input4.value-breddkapad, row: i, start:xposition};
                                                array.push(element);

                                            }
                                            else{
                                                element = {lenght: parseInt(input3.value), width: input4.value, row: i, start:xposition};
                                                array.push(element);
                                            }
                                            xposition=xposition+parseInt(input3.value); 
                                        }
                                    }
                                    else{
                                        if(parseInt((capx-xposition))==0){}
                                        else if(breddkapad>0&&(i==0||i==rows-1)){
                                            element = {lenght: parseInt(capx-xposition), width: input4.value-breddkapad, row: i, start:xposition};
                                            array.push(element);

                                        }
                                        else{
                                            element = {lenght: parseInt(capx-xposition), width: input4.value, row: i, start:xposition};
                                            array.push(element);

                                        }
                                        xposition=xposition+100000;
                                    }
                                }
                                xposition=0;
                            }
                            firstnummber=0;
                            
                           if(rotateroom){
                            ctx.save();ctx.translate(canvas.width/2, 450+(input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450+(input2.value/20))); 
                        for(let i = 0; i < array.length; i++){           
                            element=array[i];
                            ctx.fillStyle = "black";

                            if(element.row==0){
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                            }
                            else if(element.row==rows-1){
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            else{
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, +(input2.value-input.value)/20+450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, +(input2.value-input.value)/20+450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            
                            
                            
                        }
                        ctx.restore();
                        }
                        else{
                            
                            for(let i = 0; i < array.length; i++){           
                            element=array[i];
                            ctx.fillStyle = "black";

                            if(element.row==0){
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                            }
                            else if(element.row==rows-1){
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            else{
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10, 450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(kilnker_image,(canvas.width/2)-(capx/20)+1+element.start/10, 450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                        }
                            
                            
                            
                            
                            
                            
                            
                            
                        }
                        
                        
                        
                        
                        
                        
                        
                        

                        ctx.font = "25px serif";
                        ctx.fillStyle = "black";



                        let antalförsta12=0;
                        let antalförsta22=0;
                        
                        rowcontertext=0;
                        for(let i = 0; i < array.length; i++){
                            element=array[i];
                            element2=array[i-1];
                           if(rowcontertext==0||element.row>element2.row){
                                if(rowcontertext==2)rowcontertext=0;
                                if(rowcontertext==0)
                                    antalförsta12++;
                                if(rowcontertext==1)
                                    antalförsta22++;
                               rowcontertext++;
                                
                            }
                        }
                        rowcontertext=0;
                        for(let i = 0; i < array.length; i++){
                            element=array[i];
                            element2=array[i-1];
                            if(rowcontertext==0||element.row>element2.row){
                                if(rowcontertext==0){kaprader.Första1=element.lenght;kaprader.antal1=antalförsta12;}
                                   // ctx.fillText("Rad1:Första brädans längd:"+element.lenght+" X:"+antalförsta12, canvas.width/2+80, 40);
                                if(rowcontertext==1&&programmnummer2 !=3){kaprader.Första2=element.lenght;kaprader.antal2=antalförsta22;}
                                   // ctx.fillText("Rad2:Första brädans längd:"+element.lenght+" X:"+antalförsta22, canvas.width/2+80, 110);       
                                rowcontertext++;
                            }
                        }

                        element=array[0];
                        element2=array[1];

                        if(element.row<element2.row){}
                        else{
                            rowcontertext=0;
                            for(let i = 0; i < array.length; i++){
                                element=array[i];
                                element2=array[i+1];
                                if(i==array.length-1||element.row<element2.row){
                                    if(rowcontertext==0)kaprader.Sista1=element.lenght;
                                       // ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta12, canvas.width/2+140, 70);
                                    if(rowcontertext==1&&programmnummer2 !=3)kaprader.Sista2=element.lenght;
                                       // ctx.fillText("Sista brädans längd:"+element.lenght+" X:"+antalförsta22, canvas.width/2+140, 140);
                                    rowcontertext++;
                                }
                            }
                        }
                        
                        antalförsta12=0;
                        antalbrädorrr=0;
                        for(let i = 0; i < array.length; i++){
                             antalbrädorrr++;
                             element=array[i];
                             if(element.lenght==input3.value){
                                 antalförsta12++;
                                 
                             }
                            
                        }         
                        
                        kapraderdata.FörstaSistaKap=breddkapad;
                        kapraderdata.HelaBrädor=antalförsta12;
                        
                        //ctx.fillText("Första/sista radens kap:"+breddkapad, canvas.width/2+140, 190);
                        //ctx.fillText("Hela brädor:"+antalförsta12, canvas.width/2+140, 220);
                      
                      kapraderdata.Brädor=(antalbrädorrr);
                      kapraderdata.M2BrädorKöpa=Math.round(((((antalbrädorrr))*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100;
                        
                      ctx.font = "25px serif";
                      ctx.fillStyle = "black";
                      ctx.fillText("Brädor:" + (antalbrädorrr) +" M2:"+Math.round(((((antalbrädorrr))*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100, canvas.width/2-200, 390);
                        
                        
                        
                    
                }
                if(programmnummer==2){
//222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222                 
                    
                    rows=capy/input4.value;
                    array =[];
                        rows=capy/input4.value;



                        rows=Math.ceil(rows)-1;
                        breddkapad=0;
                        let breddansa=0;
                        if(rows*input4.value>capy){

                            breddkapad=rows*input4.value-capy;
                            breddkapad=breddkapad/2;
                            breddkapad=breddkapad;
                            if(rows==1)breddkapad=breddkapad*2;

                            breddkapad=Math.ceil(breddkapad);

                        }

                        let xposition=0;
                            for (let i = 0; i < rows; i++) {

                                while(xposition<=capx){
                                    if((capx-xposition)>input3.value){
                                        element = {lenght: parseInt(input3.value), width: input4.value, row: i, start:xposition};
                                        array.push(element);
                                        xposition=xposition+parseInt(input3.value); 
                                        
                                    }
                                    else{
                                        breddansa=xposition;
                                        xposition=xposition+100000;
                                    }
                                }
                                xposition=0;
                            }
                            firstnummber=0;
                            if(rotateroom){
                            ctx.save();ctx.translate(canvas.width/2, 450+(input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450+(input2.value/20))); 
                        for(let i = 0; i < array.length; i++){           
                            element=array[i];
                            

                            if(element.row==0){
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                            }
                            else if(element.row==rows-1){
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            else{
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)+(capx/20)-breddansa/10+1+element.start/10+((((input5.value*input2.value)/1000))/20), +(input2.value-input.value)/20+450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            
                            
                        }
                        ctx.restore();
                        }
                        else{
                            
                            for(let i = 0; i < array.length; i++){           
                            element=array[i];
                            ctx.fillStyle = "black";

                            if(element.row==0){
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10-((((input5.value*input.value)/1000))/20), 450+element.row*element.width/10, 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*element.width/10, element.lenght/10, element.width/10);
                            }
                            else if(element.row==rows-1){
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10-((((input5.value*input.value)/1000))/20), 450+element.row*input4.value/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*input4.value/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                            else{
                                ctx.fillStyle = "black";
                                ctx.fillRect((canvas.width/2)-(capx/20)+element.start/10-((((input5.value*input.value)/1000))/20), 450+element.row*element.width/10-(breddkapad/10), 2+element.lenght/10, 2+element.width/10);
                                ctx.drawImage(brada_image,(canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                                ctx.fillStyle= "rgba(255, 255, 255, 0.3)";
                                ctx.fillRect((canvas.width/2)-(capx/20)+1+element.start/10-((((input5.value*input.value)/1000))/20), 450+1+element.row*element.width/10-(breddkapad/10), element.lenght/10, element.width/10);
                            }
                        }
                            
                            
                            
                            
                            
                            
                            
                        }
                       
                        ctx.font = "25px serif";
                        ctx.fillStyle = "black";
                        //ctx.fillText("Antal: "+array.length, canvas.width/2+250, 340);
                        kapraderdata.HelaBrädor=array.length;
                        
                    let golvytans=0;
                    for(let i = 0; i < array.length; i++){
                        element=array[i];

                        golvytans=golvytans+element.lenght*element.width;


                    }
                    golvytans=(golvytans/(capx*capy));
                
                //    golvytans=Math.round((golvytans + Number.EPSILON) * 10000) / 10000;
                   // golvytans=golvytans*100;
                    
                    
                    
                    //ctx.fillText("Utnyttjande grad:"+Math.round(((((golvytans*100)))+ Number.EPSILON) * 100)/100+"%", canvas.width/2+159, 280);
                    kapraderdata.utnyttjande=Math.round(((((golvytans*100)))+ Number.EPSILON) * 100)/100;
                
                    
                    
                }
                if(programmnummer==3){
//33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333                  
                    
                    
                     if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    
                    
                    
                    let fiskx=input3.value/10;
                    let fisky=input4.value/10;
                    
                    let fiskbredd=capx/20;
                    
                    let Offset=Math.sqrt(fisky*fisky+fisky*fisky)/4;
                    
                    fiskbredd=fiskbredd+(fiskx*Math.sqrt(2))/2;
                    fiskbredd=fiskbredd+(Math.sqrt(fisky*fisky+fisky*fisky))/2;
                    fiskbredd=fiskbredd-Offset;
                    
                    let fiskbredd2=capx/20;
                    fiskbredd2=fiskbredd2+Offset;
                    fiskbredd2=fiskbredd2+(fiskx*Math.sqrt(2))/2;
                    
                    
                    let antalstarttrianglar=(fiskbredd)/(fiskx*Math.sqrt(2));
                    let antalstarttrianglar2=(fiskbredd2)/(fiskx*Math.sqrt(2));
         
                    
                    
                    let antalsansa=capx/20;
                    antalsansa=antalsansa+(fiskx*Math.sqrt(2))/2;
                    antalsansa=antalsansa-Offset;
                    antalsansa=antalsansa/(fiskx*Math.sqrt(2));
                    
                    let kapvänster=(fiskx*Math.sqrt(2))*(antalstarttrianglar);
                    kapvänster=((fiskx*Math.sqrt(2))*(Math.floor(antalsansa)))-(kapvänster)+(((Math.sqrt(fisky*fisky+fisky*fisky))/2));
                    kapvänster=-kapvänster;
                    kapvänster=kapvänster*10;
                    
                    
                    let antalsansa2=capx/20;
                    antalsansa2=antalsansa2+Offset;
                    antalsansa2=antalsansa2+(fiskx*Math.sqrt(2))/2;
                    antalsansa2=antalsansa2/(fiskx*Math.sqrt(2));
                    
                    let kaphöger=(fiskx*Math.sqrt(2))*(antalstarttrianglar2);
                    kaphöger=(fiskx*Math.sqrt(2))*(Math.floor(antalsansa2))-(kaphöger);
                    kaphöger=-kaphöger;
                    kaphöger=kaphöger*10;
                    
                    
                    let koko= capx/20;
                    koko=koko+((fiskx)*Math.sqrt(2))/2+(((Math.sqrt(fisky*fisky+fisky*fisky))/2));
                    koko=koko-Offset;
                    koko=koko/((fiskx*Math.sqrt(2))/2);
                    
                    let högersmåbit= (fiskx*Math.sqrt(2))*(antalstarttrianglar);
                    
                    högersmåbit=(högersmåbit)-(((fiskx*Math.sqrt(2))/2)*(Math.floor(koko)));
                    
                    let ishögerbitred= "red";
                    if(!Number.isInteger(Math.floor(koko)/2))ishögerbitred="gray";
                    
                    let ishögerbitgray="red";
                    if(Number.isInteger(Math.floor(koko)/2))ishögerbitgray="gray";
                    
                    
                    högersmåbit=(högersmåbit*10)/Math.sqrt(2);
                    högersmåbit=högersmåbit*2;
                    
                    if(högersmåbit>fiskx*10)högersmåbit=högersmåbit/2;
                    let högersmåbitlängd=högersmåbit-fisky*10;
                    
                    
                    
                    koko= capx/20;
                    koko=koko+((fiskx*Math.sqrt(2))/2);
                    koko=koko+Offset;
                    koko=koko/((fiskx*Math.sqrt(2))/2);
                    
                    let väntersmåbit=((fiskx*Math.sqrt(2)))*(antalstarttrianglar2);
                    väntersmåbit=(väntersmåbit)-(((fiskx*Math.sqrt(2))/2)*(Math.floor(koko)));
                    väntersmåbit=(väntersmåbit*10)/Math.sqrt(2);
                    väntersmåbit=väntersmåbit*2;
                    
                    if(väntersmåbit>fiskx*10)väntersmåbit=väntersmåbit/2;
                    let vänstersmåbitlängd=väntersmåbit-fisky*10;
                    //--------------------------------------------------------------------------------------------------------------------
                    
                    koko= capx/20;
                    koko=koko+((fiskx*Math.sqrt(2))/2);
                    koko=koko-Offset;
                    koko=koko/((fiskx*Math.sqrt(2))/2);
                    
                    
                    let högersmåbit2= ((fiskx*Math.sqrt(2)))*(antalstarttrianglar);
                    högersmåbit2=(högersmåbit2)-(((fiskx*Math.sqrt(2))/2)*(Math.floor(koko)));
                    högersmåbit2=(högersmåbit2*10)/Math.sqrt(2);
                    högersmåbit2=högersmåbit2*2;
                    let högersmåbitlängd2=högersmåbit2;
                    
                    
                    
                    if(högersmåbit2>fiskx*10)högersmåbit2=högersmåbit2-fisky*10;
                    
                    
                    if(högersmåbit2>fiskx*10)högersmåbit2=(fiskx*10)-(fisky*10)+(högersmåbit2-fiskx*10)*2;
                    
                    
                    
                    
                    
                    
                    koko= capx/20;
                    koko=koko+((fiskx*Math.sqrt(2))/2);
                    koko=koko-Offset;
                    koko=koko/((fiskx*Math.sqrt(2))/2);
                    
                    
                    let väntersmåbit2= ((fiskx*Math.sqrt(2)))*(antalstarttrianglar);
                   väntersmåbit2=(väntersmåbit2)-(((fiskx*Math.sqrt(2))/2)*(Math.floor(koko)));
                    väntersmåbit2=(väntersmåbit2*10)/Math.sqrt(2);
                    väntersmåbit2=väntersmåbit2*2;
                    let vänstersmåbitlängd2=väntersmåbit2;
                    
                    
                    
                    if(väntersmåbit2>fiskx*10)väntersmåbit2=väntersmåbit2-fisky*10;
                    
                    
                    if(väntersmåbit2>fiskx*10)väntersmåbit2=(fiskx*10)-(fisky*10)+(väntersmåbit2-fiskx*10)*2;
                    
                    
                    
                    let fisklängd=capy/10;
                      fisklängd= fisklängd-(fiskx/Math.sqrt(2));
                      fisklängd= fisklängd/Math.sqrt(fisky*fisky+fisky*fisky);
                      fisklängd=Math.ceil(fisklängd);
                     fisklängd=((capy/10-fisklängd*Math.sqrt(fisky*fisky+fisky*fisky))+((capy/10)-(fiskx/Math.sqrt(2)))/Math.sqrt(fisky*fisky+fisky*fisky));
                    fisklängd=Math.ceil(fisklängd);
                    
                    
                    
                     let fisklängd3=capy/10;
                    let fisklängd2=capy/10;
                    fisklängd3= fisklängd3-((fiskx/Math.sqrt(2)));
                    fisklängd3= fisklängd3/Math.sqrt(fisky*fisky+fisky*fisky);
                    fisklängd3=Math.floor(fisklängd3);
                    if(ishögerbitred=="red"){
                        if(kapvänster/10+(fisky/Math.sqrt(2))>(Math.sqrt(fiskx*fiskx+fiskx*fiskx)/2))fisklängd2= fisklängd2-(Math.sqrt(fiskx*fiskx+fiskx*fiskx)/2)+kapvänster/20+(fisky/Math.sqrt(2));
                        else fisklängd2= fisklängd2-kapvänster/10;
                        fisklängd2= fisklängd2/Math.sqrt(fisky*fisky+fisky*fisky);
                        fisklängd2=Math.floor(fisklängd2);
                        
                        
                        
                        
                        
                        
                    }
                    if(ishögerbitred=="gray"){
                        
                        fisklängd2= fisklängd2-((fiskx/Math.sqrt(2)));
                        fisklängd2= fisklängd2/Math.sqrt(fisky*fisky+fisky*fisky);
                        fisklängd2=Math.floor(fisklängd2);
                        
                        
                        
                        
                    }
                    
                    
                    let fisklängd4=capy/10;
                    let fisklängd5=capy/10;
                    fisklängd5= fisklängd5-((fiskx/Math.sqrt(2)))+(fisky/Math.sqrt(2));
                    fisklängd5= fisklängd5/Math.sqrt(fisky*fisky+fisky*fisky);
                    fisklängd5=Math.floor(fisklängd5);
                    
                    if(ishögerbitred=="gray"){
                        
                        fisklängd4= fisklängd4-((fiskx/Math.sqrt(2)))+(fisky/Math.sqrt(2));
                        fisklängd4= fisklängd4/Math.sqrt(fisky*fisky+fisky*fisky);
                        fisklängd4=Math.floor(fisklängd4);
                        
                        
                    }
                    if(ishögerbitred=="red"){
                        
                 
                        
                        
                        
                        if(kaphöger/10+(fisky/Math.sqrt(2))>(Math.sqrt(fiskx*fiskx+fiskx*fiskx)/2))fisklängd4= fisklängd4-(Math.sqrt(fiskx*fiskx+fiskx*fiskx)/2)+kaphöger/20+(fisky/Math.sqrt(2));
                        else fisklängd4= fisklängd4-kaphöger/10;
                        fisklängd4= fisklängd4/Math.sqrt(fisky*fisky+fisky*fisky);
                        fisklängd4=Math.floor(fisklängd4);
                        
                        
                        
                        
                        
                    }
                    
                    
                    let fisklängd6=capy/10;
                    fisklängd6= fisklängd6-(fiskx/Math.sqrt(2));
                      fisklängd6= fisklängd6/Math.sqrt(fisky*fisky+fisky*fisky);
                      fisklängd6=Math.ceil(fisklängd6);
                    
                    
                    /*
                    if(ishögerbitred=="gray"){
                    fisklängd2= fisklängd2-((fiskx/Math.sqrt(2)));
                    fisklängd2= fisklängd2/Math.sqrt(fisky*fisky+fisky*fisky);
                    fisklängd2=Math.floor(fisklängd2);
                    }  
                    else{
                   // fisklängd2= fisklängd2-((fiskx/Math.sqrt(2)));
                    fisklängd2= fisklängd2/Math.sqrt(fisky*fisky+fisky*fisky);
                    fisklängd2=Math.floor(fisklängd2);
                        
                        
                    }
                      
                      */
                    let colorred= "rgba(255, 0, 0, 0.3)";
                    let colorgray= "rgba(0, 0, 0, 0.3)";
                    
                    
                    
                    //exepelbräda
                    

                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                    ctx.rotate((-45 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorgray;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                    ctx.rotate((-135 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorred;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                    ctx.rotate((-45 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorgray;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                    ctx.rotate((-135 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorred;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                    ctx.rotate((-45 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorgray;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90* Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                    if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                    if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                    ctx.rotate((-135 * Math.PI) / 180);
                    ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                    ctx.fillStyle = colorred;
                    ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                    ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }

                    
                    
                   
                    
                    for(let k=1;k<antalstarttrianglar;k++){
                    
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                          
                    
                    
                    } 
                  for(let k=1;k<antalstarttrianglar2;k++){
                    
                    
                      
                        
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-3*(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-5*(fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                        
                    
                    
                    }
                    
                    
                     
                    for(let k =1; k<fisklängd;k++){
                        if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*k*fisky/Math.sqrt(2)));
                        if(rotateroom)ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*k*fisky/Math.sqrt(2)));
                        ctx.rotate((-45 * Math.PI) / 180);
                        ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                        ctx.fillStyle = colorgray;
                        ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                        ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                        if(!rotateroom)ctx.translate((canvas.width/2)-Offset, 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*k*fisky/Math.sqrt(2)));
                       if(rotateroom) ctx.translate((canvas.width/2)-Offset, +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*k*fisky/Math.sqrt(2)));
                        ctx.rotate((-135 * Math.PI) / 180);
                        ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                        ctx.fillStyle = colorred;
                        ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                        ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                        
                        
                        
                    }
                   
                    for(let m =1; m<fisklängd;m++){
                        for(let k=1;k<antalstarttrianglar;k++){
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset+(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            
                            
                            
                    
                    
                        }
                    }
                    
                    
                    for(let m =1; m<fisklängd;m++){
                        for(let k=1;k<antalstarttrianglar2;k++){
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            ctx.rotate((-45 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorgray;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            if(!rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), 450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            if(rotateroom)ctx.translate((canvas.width/2)-Offset-(fiskx*Math.sqrt(2)*k), +(input2.value-input.value)/20+450+((fiskx/Math.sqrt(2)))-(fisky/Math.sqrt(2))+(2*m*fisky/Math.sqrt(2)));
                            ctx.rotate((-135 * Math.PI) / 180);
                            ctx.fillStyle = "black";ctx.fillRect(0, 0, fiskx, fisky);
                            ctx.fillStyle = colorred;
                            ctx.drawImage(brada_image,1, 1, fiskx-2, fisky-2);ctx.fillRect(0,0, fiskx, fisky);
                            ctx.setTransform(1, 0, 0, 1, 0, 0);if(rotateroom){ctx.save();ctx.translate(canvas.width/2, 450 + (input2.value/20));ctx.rotate((-90 * Math.PI) / 180);ctx.translate(-canvas.width/2, -(450 + (input2.value/20))); }
                            
                            
                    
                        }
                    }
                  
                    if(rotateroom){
                        
                        
                        ctx.fillStyle = "blue";
                        ctx.fillRect((canvas.width/2),+(input2.value-input.value)/20+450,1,capy/10);
                        ctx.restore();
                        ctx.fillStyle = "#121417";
                        ctx.fillRect(0,0, 5000, 450);
                        ctx.fillRect(0,450+(input2.value/10), 5000, 5000);
                        ctx.fillRect(0,450+(input2.value/10), 5000, 5000);
                       if(-(((canvas.width/2)-(input.value/20)))<0) ctx.fillRect(-(((canvas.width/2)-(input.value/20))),0,(((canvas.width/2)-(input.value/20)))*2,5000);
                       ctx.fillRect((((canvas.width/2)+(input.value/20))),0,(((canvas.width/2)+(input.value/20)))*2,5000);
                        ctx.fillStyle = "white";
           
                        ctx.fillRect((((canvas.width/2)-(input.value/20))),450, (input.value/10), ((input5.value*input2.value)/20000));
                        ctx.fillRect((((canvas.width/2)-(input.value/20))),450+(input2.value/10)-((input5.value*input2.value)/20000), (input.value/10), ((input5.value*input2.value)/20000));
                       // ctx.fillRect((((canvas.width/2)-(input2.value/20))),450, ((input5.value*input2.value)/10000), (input.value/10));
                        ctx.fillRect((((canvas.width/2)+(input.value/20)))-((input5.value*input.value)/10000),450, ((input5.value*input.value)/10000), (input2.value/10)); 
                        
                        
                       
                   
           
           
           
           
                    }
                    else{
                        
                        ctx.fillStyle = "blue";
                        ctx.fillRect((canvas.width/2),450,1,capy/10);
                        ctx.fillStyle = "#121417";
                        ctx.fillRect(0,0, 5000, 450);
                        ctx.fillRect(0,-5000, (canvas.width/2)-(capx/20), 10000);
                        ctx.fillRect((canvas.width/2)+(capx/20),0, 5000, 5000);
                        ctx.fillRect((canvas.width/2)-(input.value/20),450+(capy/10), input.value/10,5000);
                        ctx.fillStyle = "white";
                        ctx.fillRect((canvas.width/2)-(input.value/20),450, input.value/20-capx/20, input2.value/10);
                        ctx.fillRect((canvas.width/2)+(capx/20),450, input.value/20-capx/20, input2.value/10);
                        ctx.fillRect((canvas.width/2)-(input.value/20),450+(capy/10), input.value/10, input2.value/10-capy/10);
                        
                        
                    }
                    
                    
                    
                    
                    
                    ctx.restore();
                    ctx.font = "18px serif";
                    ctx.fillStyle = "black";
                    ctx.fillText("Golvläggnings program", 10, 215);
                    ctx.fillText("Rummets bredd", canvas.width/2-245, 50);
                    ctx.fillText("Rummets djup", canvas.width/2-235, 120);
                    ctx.fillText("Brädas längd", canvas.width/2-225, 190);
                    ctx.fillText("Brädas bredd", canvas.width/2-225, 260);
                    ctx.fillText("Distans per M", canvas.width/2-235, 330);
                    ctx.drawImage(base_image, 0, 0,200,200);
                    
                    ctx.font = "20px serif";
                   // ctx.fillText("Start trianglar:"+((((Math.ceil(antalsansa)+Math.ceil(antalsansa2))))-1), canvas.width/2+80, 20);
                    
                    harringbone.starttrianglar=((((Math.ceil(antalsansa)+Math.ceil(antalsansa2))))-1);
                    
                    if(((((Math.ceil(antalsansa)+Math.ceil(antalsansa2))))-1)>1){
                       // ctx.fillText("Höger triangeln:"+Math.round((kapvänster + Number.EPSILON) * 1) / 1, canvas.width/2+80, 40);
                       // ctx.fillText("Vänster triangeln:"+Math.round((kaphöger + Number.EPSILON) * 1) / 1, canvas.width/2+80, 60);
                        harringbone.högertriangeln=Math.round((kapvänster + Number.EPSILON) * 1) / 1;
                        harringbone.vänstertriangeln=Math.round((kaphöger + Number.EPSILON) * 1) / 1;
                    }
                    
                    let högervänsterbitar=0;
                    
                    
                    let högerlängdansa=högersmåbitlängd2;
                    let vänsterlängdansa=vänstersmåbitlängd2;
                    if(högerlängdansa>fiskx*10)högerlängdansa=fiskx*10;
                    if(vänsterlängdansa>fiskx*10)vänsterlängdansa=fiskx*10;
                    
                    let högersmåsmå=högersmåbitlängd;
                    let vänstersmåsmå=vänstersmåbitlängd;
                    
                    
                    if(högersmåsmå<0)högersmåsmå=0;
                    if(vänstersmåsmå<0)vänstersmåsmå =0;
                    
                    

                    
                    
                    
                    if(högersmåbit2!=högersmåbit){
                        
                        harringbone.bits.höger1.long=Math.round((högersmåbit + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger1.short=Math.round((högersmåsmå + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger1.color = ishögerbitred;
                        harringbone.bits.höger1.count = Math.floor(fisklängd2);
                        
                        harringbone.bits.höger2.long=Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger2.short=Math.round((högerlängdansa + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger2.color = ishögerbitgray;
                        harringbone.bits.höger2.count = Math.floor(fisklängd3);
                        
                        //ctx.fillText("Höger bit:  "+Math.round((högersmåbit + Number.EPSILON) * 1) / 1+ "/" + Math.round((högersmåsmå + Number.EPSILON) * 1) / 1+ " "+ishögerbitred  +" X:" + Math.floor(fisklängd2), canvas.width/2+80, 80);
                        //ctx.fillText("Höger bit2:  "+Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1 + "/" + Math.round((högerlängdansa + Number.EPSILON) * 1) / 1+ " "+ishögerbitgray +" X:" + Math.floor(fisklängd3), canvas.width/2+80, 100);
                        högervänsterbitar=högervänsterbitar+Math.floor(fisklängd2)+Math.floor(fisklängd3);
                    }
                    else{ 
                        
                        harringbone.bits.höger1.long=Math.round((högersmåbit + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger1.short=Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1;
                        harringbone.bits.höger1.color = ishögerbitred;
                        harringbone.bits.höger1.count = Math.floor(fisklängd2);
                        //ctx.fillText("Höger bit:  "+Math.round((högersmåbit + Number.EPSILON) * 1) / 1+ "/" + Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1 + " "+ishögerbitred  + " X:" + Math.floor(fisklängd2), canvas.width/2+80, 80);
                        högervänsterbitar=högervänsterbitar+Math.floor(fisklängd2);
                    }
                    if(Math.round((väntersmåbit2 + Number.EPSILON) * 1) / 1!=Math.round((väntersmåbit + Number.EPSILON) * 1) / 1){
                        
                        harringbone.bits.vänster1.long  = Math.round((väntersmåbit + Number.EPSILON) * 1) / 1;
                        harringbone.bits.vänster1.short = Math.round((vänstersmåsmå + Number.EPSILON) * 1) / 1 ;
                        harringbone.bits.vänster1.color = ishögerbitgray;
                        harringbone.bits.vänster1.count = Math.floor(fisklängd4);
                        
                        harringbone.bits.vänster2.long  = Math.round((väntersmåbit2 + Number.EPSILON) * 1) / 1;
                        harringbone.bits.vänster2.short = Math.round((vänsterlängdansa + Number.EPSILON) * 1) / 1;
                        harringbone.bits.vänster2.color = ishögerbitred;
                        harringbone.bits.vänster2.count = Math.floor(fisklängd5);
                        
                       // ctx.fillText("Vänster bit:"+Math.round((väntersmåbit + Number.EPSILON) * 1) / 1 + "/" + Math.round((vänstersmåsmå + Number.EPSILON) * 1) / 1 + " "+ishögerbitgray +" X:" + Math.floor(fisklängd4), canvas.width/2+80, 120);
                       // ctx.fillText("Vänster bit2:"+Math.round((väntersmåbit2 + Number.EPSILON) * 1) / 1+ "/" + Math.round((vänsterlängdansa + Number.EPSILON) * 1) / 1 + " "+ishögerbitred + " X:" + Math.floor(fisklängd5), canvas.width/2+80, 140);
                        högervänsterbitar=högervänsterbitar+Math.floor(fisklängd4)+Math.floor(fisklängd5);
                    }
                    else{ 
                        
                        harringbone.bits.vänster1.long  = Math.round((väntersmåbit + Number.EPSILON) * 1) / 1;
                        harringbone.bits.vänster1.short = Math.round((vänstersmåbitlängd + Number.EPSILON) * 1) / 1 ;
                        harringbone.bits.vänster1.color = ishögerbitgray;
                        harringbone.bits.vänster1.count = Math.floor(fisklängd4);
        
                       // ctx.fillText("Vänster bit:"+Math.round((väntersmåbit + Number.EPSILON) * 1) / 1+ "/" + Math.round((vänstersmåbitlängd + Number.EPSILON) * 1) / 1 + " "+ishögerbitgray +" X:" + Math.floor(fisklängd4), canvas.width/2+80, 120);
                        högervänsterbitar=högervänsterbitar+Math.floor(fisklängd4);
                    }
                    
                    let helabrädor=calcwholebits(capx/10,capy/10,fiskx,fisky,Offset,Math.floor(fisklängd6),Math.floor(antalsansa)+Math.floor(antalsansa2));
                    
                   // ctx.fillText("Antal hela brädor:" + helabrädor, canvas.width/2+80, 160);
                    harringbone.helabrädor=helabrädor;
                    
                    
                    let antalbottomboards=calcbottomfloor(capx/10,capy/10,fiskx,fisky,Offset,Math.floor(antalsansa)+Math.floor(antalsansa2)+1,Math.ceil(fisklängd));
                    
                    let antalstarttringelbrädor=(1+(Math.floor(antalsansa)+Math.floor(antalsansa2)))*6;
                    
                    
                    
                   // console.log(högervänsterbitar);
                  //  ((helabrädor+högervänsterbitar+antalstarttringelbrädor)*input3.value*input4.value/1000000)
                    
                    ctx.font = "25px serif";
                    ctx.fillStyle = "black";
                   // ctx.fillText("Brädor:" + (helabrädor+högervänsterbitar+antalstarttringelbrädor+antalbottomboards) +" M2:"+Math.round((((helabrädor+högervänsterbitar+antalstarttringelbrädor+antalbottomboards)*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100, canvas.width/2-200, 390);
                    harringbone.brädor=(helabrädor+högervänsterbitar+antalstarttringelbrädor+antalbottomboards);
                    harringbone.M2brädor=Math.round((((helabrädor+högervänsterbitar+antalstarttringelbrädor+antalbottomboards)*input3.value*input4.value/1000000)+ Number.EPSILON) * 100)/100;
                    
                    
                    
                    if(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1==Math.round((högersmåbit + Number.EPSILON) * 1) / 1){
                    let x=canvas.width/2;
                    let y=input2.value/10+500;
                    let högrelängd1=Math.round((högersmåbit/2.5 + Number.EPSILON) * 1) / 1;
                    let högrelängd2=Math.round((högersmåbitlängd/2.5 + Number.EPSILON) * 1) / 1;
                    
                    let corners = [
                        {x: x, y: y}, // top-left (origin)
                        {x: x +  högrelängd1* Math.cos((90 * Math.PI) / 180), y: y + högrelängd1 * Math.sin((90 * Math.PI) / 180)}, // top-right
                        {x: x + högrelängd2 * Math.cos((90 * Math.PI) / 180) + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2),y: y + högrelängd2 * Math.sin((90 * Math.PI) / 180) + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)}, // bottom-right
                        {x: x + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2), y: y + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)} // bottom-left
                    ];
                    
                    
                    ctx.save();
                    ctx.rect(x-2000, y, 4000, fiskx*4);
                    ctx.clip();
                    
              
                    
                    if(ishögerbitred=="red"){
                    
                    
                      ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners[0].x-input.value/40, corners[0].y);
                      ctx.lineTo(corners[1].x-input.value/40, corners[1].y);
                      ctx.lineTo(corners[2].x-input.value/40, corners[2].y);
                      ctx.lineTo(corners[3].x-input.value/40 ,corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners[3].x+input.value/40+fisky*4, corners[0].y);
                      ctx.lineTo(corners[2].x+input.value/40+fisky*4, corners[1].y);
                      ctx.lineTo(corners[1].x+input.value/40+fisky*4, corners[2].y);
                      ctx.lineTo(corners[0].x+input.value/40+fisky*4, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();  
                      
                      
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-fisky*4, input2.value/10+500+högrelängd2/20+10);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4, input2.value/10+500+högrelängd2/2+10);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();    
                      
                      
                      
                    }  
                    else{
                        
                        
                        ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners[0].x+input.value/40+fisky*4, corners[0].y);
                      ctx.lineTo(corners[1].x+input.value/40+fisky*4, corners[1].y);
                      ctx.lineTo(corners[2].x+input.value/40+fisky*4, corners[2].y);
                      ctx.lineTo(corners[3].x+input.value/40+fisky*4, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners[3].x-input.value/40, corners[0].y);
                      ctx.lineTo(corners[2].x-input.value/40, corners[1].y);
                      ctx.lineTo(corners[1].x-input.value/40, corners[2].y);
                      ctx.lineTo(corners[0].x-input.value/40, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();  
                      
                      
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+0+input.value/40+fisky*4-fisky*4, input2.value/10+500+högrelängd2/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40, input2.value/10+500+högrelängd2/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-fisky*4, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore(); 
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    }  
                      
                      
                      
                      
                    }
                      
                      
                    if(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1!=Math.round((högersmåbit + Number.EPSILON) * 1) / 1){
                    
               
               
               
                     let x=canvas.width/2;
                     let y=input2.value/10+500;
                    let högrelängd1=Math.round((högersmåbit/2.5 + Number.EPSILON) * 1) / 1;
                    let högrelängd2=Math.round((högersmåbitlängd/2.5 + Number.EPSILON) * 1) / 1;
                    
                    let corners = [
                        {x: x, y: y}, // top-left (origin)
                        {x: x +  högrelängd1* Math.cos((90 * Math.PI) / 180), y: y + högrelängd1 * Math.sin((90 * Math.PI) / 180)}, // top-right
                        {x: x + högrelängd2 * Math.cos((90 * Math.PI) / 180) + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2),y: y + högrelängd2 * Math.sin((90 * Math.PI) / 180) + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)}, // bottom-right
                        {x: x + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2), y: y + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)} // bottom-left
                    ];
                    
                    ctx.save();
                   ctx.rect(x-2000, y, 4000, fiskx*4);
                    ctx.clip();
                    
                    
                     if(ishögerbitred=="red"){
                    
                    
                      ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners[3].x-input.value/40, corners[0].y);
                      ctx.lineTo(corners[2].x-input.value/40, corners[1].y);
                      ctx.lineTo(corners[1].x-input.value/40, corners[2].y);
                      ctx.lineTo(corners[0].x-input.value/40, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners[0].x+input.value/40+fisky*4, corners[0].y);
                      ctx.lineTo(corners[1].x+input.value/40+fisky*4, corners[1].y);
                      ctx.lineTo(corners[2].x+input.value/40+fisky*4, corners[2].y);
                      ctx.lineTo(corners[3].x+input.value/40+fisky*4, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();  
               
               
               
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40, input2.value/10+500+högrelängd2/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0-17);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-fisky*4, input2.value/10+500+högrelängd1/2+20);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4, input2.value/10+500+högrelängd1/2+20);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4-fisky*4, input2.value/10+500+högrelängd2/2-17);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore(); 
                    
               
                     }
               else{
                   
                   
                   ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners[3].x+input.value/40+fisky*4, corners[0].y);
                      ctx.lineTo(corners[2].x+input.value/40+fisky*4, corners[1].y);
                      ctx.lineTo(corners[1].x+input.value/40+fisky*4, corners[2].y);
                      ctx.lineTo(corners[0].x+input.value/40+fisky*4, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners[0].x-input.value/40, corners[0].y);
                      ctx.lineTo(corners[1].x-input.value/40, corners[1].y);
                      ctx.lineTo(corners[2].x-input.value/40, corners[2].y);
                      ctx.lineTo(corners[3].x-input.value/40, corners[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();  
               
               
               
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4, input2.value/10+500+högrelängd2/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4-fisky*4, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40, input2.value/10+500+högrelängd1/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-fisky*4, input2.value/10+500+högrelängd2/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbitlängd + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore(); 
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
               }
               
               
  
               
               
               
               
               
               
               
               
               
                    let högrelängd11=Math.round((högersmåbit2/2.5 + Number.EPSILON) * 1) / 1;
                    let högrelängd22=Math.round((högersmåbitlängd2/2.5 + Number.EPSILON) * 1) / 1;
                    
                
                    
                    
                    let corners2 = [
                        {x: x, y: y}, // top-left (origin)
                        {x: x +  högrelängd11* Math.cos((90 * Math.PI) / 180), y: y + högrelängd11 * Math.sin((90 * Math.PI) / 180)}, // top-right
                        {x: x + högrelängd22 * Math.cos((90 * Math.PI) / 180) + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2),y: y + högrelängd22 * Math.sin((90 * Math.PI) / 180) + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)}, // bottom-right
                        {x: x + fisky*4 * Math.cos((90 * Math.PI) / 180 + Math.PI/2), y: y + fisky*4 * Math.sin((90 * Math.PI) / 180 + Math.PI/2)} // bottom-left
                    ];
                    
                    
                    ctx.save();
                     ctx.rect(x-2000, y, 4000, fiskx*4);
                    ctx.clip();
                    
                    if(ishögerbitred=="red"){
                    
                      ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners2[3].x+input.value/40+fisky*4+100, corners2[0].y);
                      ctx.lineTo(corners2[2].x+input.value/40+fisky*4+100, corners2[1].y);
                      ctx.lineTo(corners2[1].x+input.value/40+fisky*4+100, corners2[2].y);
                      ctx.lineTo(corners2[0].x+input.value/40+fisky*4+100, corners2[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners2[0].x-input.value/40-100, corners2[0].y);
                      ctx.lineTo(corners2[1].x-input.value/40-100, corners2[1].y);
                      ctx.lineTo(corners2[2].x-input.value/40-100, corners2[2].y);
                      ctx.lineTo(corners2[3].x-input.value/40-100, corners2[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke(); 
                      
                    
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4+100, input2.value/10+500+högrelängd22/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högerlängdansa + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4+100-fisky*4, input2.value/10+500+högrelängd11/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-100, input2.value/10+500+högrelängd11/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-100-fisky*4, input2.value/10+500+högrelängd22/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högerlängdansa + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore(); 
                      
                      
                    }
                    else{
                        
                        
                        ctx.fillStyle = "gray";
                      ctx.beginPath();
                      ctx.moveTo(corners2[3].x-input.value/40-100, corners2[0].y);
                      ctx.lineTo(corners2[2].x-input.value/40-100, corners2[1].y);
                      ctx.lineTo(corners2[1].x-input.value/40-100, corners2[2].y);
                      ctx.lineTo(corners2[0].x-input.value/40-100, corners2[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke();
                    
                      ctx.fillStyle = "red";
                      ctx.beginPath();
                      ctx.moveTo(corners2[0].x+input.value/40+fisky*4+100, corners2[0].y);
                      ctx.lineTo(corners2[1].x+input.value/40+fisky*4+100, corners2[1].y);
                      ctx.lineTo(corners2[2].x+input.value/40+fisky*4+100, corners2[2].y);
                      ctx.lineTo(corners2[3].x+input.value/40+fisky*4+100, corners2[3].y);
                      ctx.fill();
                      ctx.closePath();
                      ctx.stroke(); 
                      
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-100, input2.value/10+500+högrelängd22/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högerlängdansa + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)-input.value/40-100-fisky*4, input2.value/10+500+högrelängd11/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();  
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4+100, input2.value/10+500+högrelängd11/2);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högersmåbit2 + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore();
                      
                    ctx.fillStyle = "black"; 
                    ctx.save();
                    ctx.translate((canvas.width/2)+input.value/40+fisky*4+100-fisky*4, input2.value/10+500+högrelängd22/2);
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.fillText(Math.round((högerlängdansa + Number.EPSILON) * 1) / 1, 0, 0);
                    ctx.restore(); 
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    }
                      
                      
                      
 
                       
                      
                      
                      
                      
                      
                      
                    
                }
                      
                      
                      
                      
                      
                      
                      
                     
                      
                      
                      
                      
                      
                      
                      
                      
                      
                      
                }
                
             
                
                
                
                
                 ctx.restore();ctx.restore();
                
                
                ctx.font = "25px serif";
                ctx.fillStyle = "black";
              //  ctx.fillText("Total yta:"+Math.round((((input.value*input2.value)/1000000)+ Number.EPSILON) * 100)/100+" M2", canvas.width/2-200, 415);
                kapraderdata.Totalyta=Math.round((((input.value*input2.value)/1000000)+ Number.EPSILON) * 100)/100;
                
                if(programmnummer!=2)golvytans=capy*capx;
                else{
                    golvytans=capy*capx*(kapraderdata.utnyttjande/100);
                    
                    
                }
                
                
                
                
                
                //ctx.fillText("Golv yta:"+Math.round(((((golvytans)/1000000)) + Number.EPSILON) * 100) / 100+" M2", canvas.width/2-200, 440);
                kapraderdata.Golvyta=Math.round(((((golvytans)/1000000)) + Number.EPSILON) * 100) / 100;
                
         
                
                
            }
            
        }catch(error){};
            NYTT();    
            setTimeout(check, 50);     
            };check();
            function setinputlocation(input,x,y){
                
                input.type = 'text';
                input.style.position = 'absolute';
                input.style.left = (x - 4) + 'px';
                input.style.top = (y - 4) + 'px';
                
                
                input.size=7;
                input.style.height=60;
                input.style.fontSize=35;
               
                
            }
            function setbuttonlocation(inputs,x,y){
                inputs.style.position = 'absolute';
                inputs.style.left = (x - 4) + 'px';
                inputs.style.top = (y - 4) + 'px'
                inputs.style.fontSize=20;
                
                
                if(inputs==button){
                    inputs.innerHTML = "Fallande längder";
                    inputs.onclick = function(){
                        programmnummer=0;
                        if(programmnummer==3)programmnummer=0;


                    }
                
                }
   
                if(inputs==button3){
                    inputs.innerHTML = "Tiles 1/2";
                    inputs.onclick = function(){
                        programmnummer=1;
                        programmnummer2=0;
                        if(programmnummer==3)programmnummer=0;

                    
                    }
                    
                }
                if(inputs==button4){
                    inputs.innerHTML = "Hela skivor";
                    inputs.onclick = function(){
                        programmnummer=2;
                      
                    }
                    
                }
                if(inputs==button5){
                    inputs.innerHTML = "Tiles 1/3";
                    
                    inputs.onclick = function(){
                        programmnummer2=1;
                        programmnummer=1;
                     
                    }
                }
                if(inputs==button6){
                    inputs.innerHTML = "Tiles 2/3";
                    
                    inputs.onclick = function(){
                        programmnummer2=2;
                        programmnummer=1;
                  
                    }
                    
                }
                if(inputs==button7){
                    inputs.innerHTML = "Tiles 3/3";
                    
                    inputs.onclick = function(){
                        programmnummer2=3;
                        programmnummer=1;

                    }
                }
                if(inputs==button8){
                    inputs.innerHTML = "Fiskben";
                    
                    inputs.onclick = function(){
                
                        programmnummer=3;

                    }
                }
                if(inputs==button9){
                    inputs.innerHTML = "rotera";
                    
                    button9.onclick = function(){
                
                    if(rotateroom==false)rotateroom=true;
                    else rotateroom=false;
                        

                }
                    
                    
                    
                    
                }
                
                
                
                
                

    }
    function calcwholebits(xroom,yroom,floox,floory,offsetToRight,numberofheight,numberofwidth){
        
    let bottomY = 450 + yroom;
    let leftX = (canvas.width/2) - xroom/2;
    let rightX = (canvas.width/2) + xroom/2;
    let startX = (canvas.width/2) - offsetToRight;
    let spacing=floox* Math.sqrt(2);
    
    
    let antal=0;
    
    // Store lengths of boards intersecting with bottom
    let boardLengths = [];
    
    // Use clipping to restrict drawing to within the room boundaries
    //ctx.save();
    //ctx.beginPath();
    //ctx.rect(leftX, 450, xroom, yroom);
    //ctx.clip();
    
    // Draw the herringbone pattern with gray boards first and red boards after
    for (let row = 1; row < numberofheight+1; row++) {
        // Y position for this row
       // let rowY = 450 + (floory * row * Math.sqrt(2));
        let rowY=450+((floox/Math.sqrt(2)))-(floory/Math.sqrt(2))+(2*row*floory/Math.sqrt(2));
         
        
        
        // First, draw gray boards (-45 degrees)
        for (let k = -numberofwidth; k <= numberofwidth; k++) {
            // X position for this board
            let posX = startX + (spacing * k);
            
            // Skip boards that are clearly outside the room width
            if (posX < leftX || posX +(floox* Math.sqrt(2)/2)+floory/Math.sqrt(2) > rightX) continue;
            
              
                if (rowY  +(1*floory/Math.sqrt(2)) < bottomY){
                antal++;
              //  ctx.save();
              //  ctx.translate(posX, rowY);
              //  ctx.rotate((-45 * Math.PI) / 180);
              //  ctx.fillStyle = "gray";
              //  ctx.fillRect(0, 0, floox, floory);
             //   ctx.strokeStyle = "black";
              //  ctx.strokeRect(0, 0, floox, floory);
               // ctx.restore();
                }
        }
        
        
        
        
        // Then, draw red boards (-135 degrees)
        for (let k = -numberofwidth; k <= numberofwidth; k++) {
            // X position for this board
            let posX = startX + (spacing * k);
            
            // Skip boards that are clearly outside the room width
            if (posX -(floox* Math.sqrt(2)/2) < leftX || posX  > rightX) continue;
            
           
                 if (rowY   < bottomY){
                antal++;
             //   ctx.save();
             //   ctx.translate(posX, rowY);
             //   ctx.rotate((-135 * Math.PI) / 180);
             //  ctx.fillRect(0, 0, floox, floory);
             //   ctx.fillStyle = "red";
             ///   ctx.strokeStyle = "black";
            //    ctx.strokeRect(0, 0, floox, floory);
            //    ctx.restore();
                 }
        }
    }
        
        
        
        
        
        
        return antal;
        
    }
    
    
 
     function checkBoardIntersection(x, y, width, height, angleDegrees, bottomY, leftX, rightX) {
    // Convert angle to radians
    let angleRad = (angleDegrees * Math.PI) / 180;
    
    // Calculate all four corners of the board
    let corners = [
        {x: x, y: y}, // top-left (origin)
        {x: x + width * Math.cos(angleRad), y: y + width * Math.sin(angleRad)}, // top-right
        {x: x + width * Math.cos(angleRad) + height * Math.cos(angleRad + Math.PI/2),y: y + width * Math.sin(angleRad) + height * Math.sin(angleRad + Math.PI/2)}, // bottom-right
        {x: x + height * Math.cos(angleRad + Math.PI/2), y: y + height * Math.sin(angleRad + Math.PI/2)} // bottom-left
    ];
    
    if (angleDegrees === -45) {
        corners = [corners[0], corners[1], corners[2], corners[3]];
    }
    
    if (angleDegrees === -135) {
        corners = [corners[3], corners[2], corners[1], corners[0]];

    }
    
    
    let intersectionXs = [];
     let isUndersideIntersectingRoom = doesSegmentIntersectRoom(corners[3], corners[2], leftX, bottomY, rightX);
     let isOversideIntersectingRoom=doesSegmentIntersectRoom(corners[1], corners[0], leftX, bottomY, rightX);
     
     //if(isUndersideIntersectingRoom==true) isUndersideIntersectingRoom= doesSegmentIntersectRoom(corners[3], corners[0], leftX, bottomY, rightX);
    // Helper function to add a unique intersection value to intersectionXs.
    function addIntersection(val) {
        const tol = 1e-10;
        if (!intersectionXs.some(existing => Math.abs(existing - val) < tol)) {
            intersectionXs.push(val);
        }
    }
    for (let i = 0; i < corners.length; i++) {
        let p1 = corners[i];
        let p2 = corners[(i + 1) % corners.length];
        
        // Check if the edge is horizontal and exactly on bottomY
        if (Math.abs(p2.y - p1.y) < 1e-10) {
            if (Math.abs(p1.y - bottomY) < 1e-10) {
                // Add both endpoints if they are within the horizontal bounds
                if (p1.x >= leftX && p1.x <= rightX) {
                    addIntersection(p1.x);
                }
                if (p2.x >= leftX && p2.x <= rightX) {
                    addIntersection(p2.x);
                }
            }
            continue;
        }
        
        if ((p1.y - bottomY) * (p2.y - bottomY) <= 0) {
            // Calculate parameter t for the intersection point along the edge
            let t = (bottomY - p1.y) / (p2.y - p1.y);
            // Ensure t falls within the segment [0, 1]
            if (t >= 0 && t <= 1) {
                let intersectX = p1.x + t * (p2.x - p1.x);
                // Include the intersection only if it lies within the horizontal boundaries
                if (intersectX >= leftX && intersectX <= rightX) {
                    addIntersection(intersectX);
                }
            }
        }
    }
    let cutLengths =[];
    if (intersectionXs.length === 0) {
        // No valid intersections found; the board does not cross bottomY within [leftX, rightX]
        return {
            intersects: false,
            length: 0
        };
    }
    //After calc

    for (let i = 0; i < corners.length; i++){
        let c1 = corners[i];
        
        
        let newY = c1.y;
        let prev = corners[(i - 1 + corners.length) % corners.length];
        let next = corners[(i + 1) % corners.length];
        let newX = c1.x;
        
        if(c1.y > bottomY){
            // Adjust c1.x based on board's rotation when intersecting bottomY
            
            
            if(prev.y <= bottomY){
                let t = (bottomY - prev.y) / (c1.y - prev.y);
                newX = prev.x + t * (c1.x - prev.x);
                
                
            } else if(next.y <= bottomY){
                let t = (bottomY - c1.y) / (next.y - c1.y);
                newX = c1.x + t * (next.x - c1.x);
            }
            c1.x = newX;
            c1.y = bottomY;
        }
        
        
    }
  
        
        
      if((corners[0].x < leftX && corners[1].x > leftX) || (corners[0].x > leftX && corners[1].x < leftX)){
         
         if(corners[0].x < leftX){
             // Find intersection with left boundary
             // Using point-slope formula to find intersection
             let dx = corners[1].x - corners[0].x;
             let dy = corners[1].y - corners[0].y;
             
             // Guard against division by zero
             if (Math.abs(dx) > 1e-10) {
                 let slope = dy / dx;
                 let newY = corners[0].y + slope * (leftX - corners[0].x);
                 
                 corners[0].x = leftX;
                 corners[0].y = newY;
             }
         }
         
         if(corners[1].x < leftX){
             // Find intersection with left boundary
             let dx = corners[0].x - corners[1].x;
             let dy = corners[0].y - corners[1].y;
             
             // Guard against division by zero
             if (Math.abs(dx) > 1e-10) {
                 let slope = dy / dx;
                 let newY = corners[1].y + slope * (leftX - corners[1].x);
                 
                 corners[1].x = leftX;
                 corners[1].y = newY;
             }
         }
     }   
        
     if((corners[2].x < leftX && corners[3].x > leftX) || (corners[2].x > leftX && corners[3].x < leftX)){
         
         if(corners[2].x < leftX){
             // Find intersection with left boundary
             let dx = corners[3].x - corners[2].x;
             let dy = corners[3].y - corners[2].y;
             
             // Guard against division by zero
             if (Math.abs(dx) > 1e-10) {
                 let slope = dy / dx;
                 let newY = corners[2].y + slope * (leftX - corners[2].x);
                 
                 corners[2].x = leftX;
                 corners[2].y = newY;
             }
         }
         
         if(corners[3].x < leftX){
             // Find intersection with left boundary
             let dx = corners[2].x - corners[3].x;
             let dy = corners[2].y - corners[3].y;
             
             // Guard against division by zero
             if (Math.abs(dx) > 1e-10) {
                 let slope = dy / dx;
                 let newY = corners[3].y + slope * (leftX - corners[3].x);
                 
                 corners[3].x = leftX;
                 corners[3].y = newY;
             }
         }
     }      
        
     if((corners[0].x < rightX && corners[1].x > rightX) || (corners[0].x > rightX && corners[1].x < rightX)){
         
        if(corners[0].x > rightX){
            // Find intersection with right boundary
            let dx = corners[1].x - corners[0].x;
            let dy = corners[1].y - corners[0].y;
             
            // Guard against division by zero
            if (Math.abs(dx) > 1e-10) {
                let slope = dy / dx;
                let newY = corners[0].y + slope * (rightX - corners[0].x);
                 
                corners[0].x = rightX;
                corners[0].y = newY;
            }
        }
         
        if(corners[1].x > rightX){
            // Find intersection with right boundary
            let dx = corners[0].x - corners[1].x;
            let dy = corners[0].y - corners[1].y;
             
            // Guard against division by zero
            if (Math.abs(dx) > 1e-10) {
                let slope = dy / dx;
                let newY = corners[1].y + slope * (rightX - corners[1].x);
                 
                corners[1].x = rightX;
                corners[1].y = newY;
            }
        }
    }   
        
    if((corners[2].x < rightX && corners[3].x > rightX) || (corners[2].x > rightX && corners[3].x < rightX)){
         
        if(corners[2].x > rightX){
            // Find intersection with right boundary
            let dx = corners[3].x - corners[2].x;
            let dy = corners[3].y - corners[2].y;
             
            // Guard against division by zero
            if (Math.abs(dx) > 1e-10) {
                let slope = dy / dx;
                let newY = corners[2].y + slope * (rightX - corners[2].x);
                 
                corners[2].x = rightX;
                corners[2].y = newY;
            }
        }
         
        if(corners[3].x > rightX){
            // Find intersection with right boundary
            let dx = corners[2].x - corners[3].x;
            let dy = corners[2].y - corners[3].y;
             
            // Guard against division by zero
            if (Math.abs(dx) > 1e-10) {
                let slope = dy / dx;
                let newY = corners[3].y + slope * (rightX - corners[3].x);
                 
                corners[3].x = rightX;
                corners[3].y = newY;
            }
        }
    }   
        
        
    // Check if the underside actually intersects with the room
   
    
    //calculate boards upperside length and underside length
     // Calculate upperside length (from adjusted corner[0] to corner[1])
     
    if(isOversideIntersectingRoom){
    let upperSideLength = Math.sqrt(
        Math.pow(corners[1].x - corners[0].x, 2) + 
        Math.pow(corners[1].y - corners[0].y, 2)
    );
    cutLengths.push(upperSideLength);
     }
    // Calculate underside length (from adjusted corner[3] to corner[2])
    if (isUndersideIntersectingRoom) {
    let underSideLength = Math.sqrt(
        Math.pow(corners[2].x - corners[3].x, 2) + 
        Math.pow(corners[2].y - corners[3].y, 2)
    );
    cutLengths.push(underSideLength);
    }
      //  ctx.beginPath();
     //   ctx.strokeStyle = "yellow";
      //  ctx.moveTo(corners[0].x, corners[0].y);
      //  ctx.lineTo(corners[1].x, corners[1].y);
     //   ctx.moveTo(corners[2].x, corners[2].y);
     //   ctx.lineTo(corners[3].x, corners[3].y);
     //  ctx.closePath();
     //   ctx.stroke();
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return {
        intersects: true,
        length: cutLengths.length === 1 ? cutLengths[0] : cutLengths
    };
    
    
   
    
    
    
    
    
}


// Helper function to check if a line segment intersects with the room
    function doesSegmentIntersectRoom(p1, p2, leftX, bottomY, rightX) {
        // Check if either endpoint is inside the room
        const isP1Inside = p1.x >= leftX && p1.x <= rightX && p1.y <= bottomY;
        const isP2Inside = p2.x >= leftX && p2.x <= rightX && p2.y <= bottomY;
        
        if (isP1Inside || isP2Inside) {
            return true;
        }
        
        // Check for intersections with room boundaries
        
        // Check bottom boundary
        if ((p1.y - bottomY) * (p2.y - bottomY) <= 0) {
            // Calculate where the line intersects y = bottomY
            const t = (bottomY - p1.y) / (p2.y - p1.y);
            if (t >= 0 && t <= 1) {
                const intersectX = p1.x + t * (p2.x - p1.x);
                if (intersectX >= leftX && intersectX <= rightX) {
                    return true;
                }
            }
        }
       /*
        // Check left boundary
        if ((p1.x - leftX) * (p2.x - leftX) <= 0) {
            // Calculate where the line intersects x = leftX
            const t = (leftX - p1.x) / (p2.x - p1.x);
            if (t >= 0 && t <= 1) {
                const intersectY = p1.y + t * (p2.y - p1.y);
                if (intersectY <= bottomY) {
                    return true;
                }
            }
        }
        
        // Check right boundary
        if ((p1.x - rightX) * (p2.x - rightX) <= 0) {
            // Calculate where the line intersects x = rightX
            const t = (rightX - p1.x) / (p2.x - p1.x);
            if (t >= 0 && t <= 1) {
                const intersectY = p1.y + t * (p2.y - p1.y);
                if (intersectY <= bottomY) {
                    return true;
                }
            }
        }
         */
        return false;
    }









function calcbottomfloor(xroom, yroom, floox, floory, offsetToRight, numberofwidth, numberofheight) {
    // Define colors for the rectangles
    let colorred = "rgba(255, 0, 0, 0.7)";
    let colorgray = "rgba(0, 0, 0, 0.7)";
    
    // Room boundaries
    let bottomY = 450 + yroom;
    let leftX = (canvas.width/2) - xroom/2;
    let rightX = (canvas.width/2) + xroom/2;
    
    // Starting X position aligned with the herringbone pattern
    //let startX = (canvas.width/2) - (floory/2 * Math.sqrt(2)) + offsetToRight;
    let startX = (canvas.width/2) - offsetToRight;
 
    
    // Spacing between rectangles in the pattern
    //let spacing = (floory * (floox/floory) * Math.sqrt(2));
        let spacing=floox* Math.sqrt(2);
    
    
    // Store lengths of boards intersecting with bottom
    let boardLengths = [];
    
    // Use clipping to restrict drawing to within the room boundaries
    //ctx.save();
    //ctx.beginPath();
    //ctx.rect(leftX, 450, xroom, yroom);
    //ctx.clip();
    
    // Draw the herringbone pattern with gray boards first and red boards after
    for (let row = 0; row < numberofheight; row++) {
        // Y position for this row
       // let rowY = 450 + (floory * row * Math.sqrt(2));
        let rowY=450+((floox/Math.sqrt(2)))-(floory/Math.sqrt(2))+(2*row*floory/Math.sqrt(2));
        
        // Skip rows that are clearly above the bottom
        if (rowY  +(2*floory/Math.sqrt(2)) < bottomY) continue;
        
        // First, draw gray boards (-45 degrees)
        for (let k = -numberofwidth; k <= numberofwidth; k++) {
            // X position for this board
            let posX = startX + (spacing * k);
            
            // Skip boards that are clearly outside the room width
            if (posX + floox * Math.sqrt(2) < leftX || posX - floox * Math.sqrt(2) > rightX) continue;
            
            let intersects45 = checkBoardIntersection(posX, rowY, floox, floory, -45, bottomY, leftX, rightX);
            if (intersects45.intersects) {
                boardLengths.push({angle: 45, length: intersects45.length});
                
              //  ctx.save();
              //  ctx.translate(posX, rowY);
             //   ctx.rotate((-45 * Math.PI) / 180);
             //   ctx.fillStyle = colorgray;
              //  ctx.fillRect(0, 0, floox, floory);
             //   ctx.strokeStyle = "black";
             //   ctx.strokeRect(0, 0, floox, floory);
             //   ctx.restore();
            }
        }
        // Then, draw red boards (-135 degrees)
        for (let k = -numberofwidth; k <= numberofwidth; k++) {
            // X position for this board
            let posX = startX + (spacing * k);
            
            // Skip boards that are clearly outside the room width
            if (posX + floox * Math.sqrt(2) < leftX || posX - floox * Math.sqrt(2) > rightX) continue;
            
            let intersects135 = checkBoardIntersection(posX, rowY, floox, floory, -135, bottomY, leftX, rightX);
            if (intersects135.intersects) {
                boardLengths.push({angle: 135, length: intersects135.length});
                
              //  ctx.save();
              //  ctx.translate(posX, rowY);
              //  ctx.rotate((-135 * Math.PI) / 180);
              //  ctx.fillStyle = colorred;
              //  ctx.fillRect(0, 0, floox, floory);
              //  ctx.strokeStyle = "black";
              //  ctx.strokeRect(0, 0, floox, floory);
              //  ctx.restore();
            }
        }
    }
    
    // Restore context (removes clipping)
    ctx.restore();
    
    // Display the results
    ctx.font = "20px serif";
    ctx.fillStyle = "black";
    ctx.fillText("Bottom boards: " + boardLengths.length, canvas.width/2+80, 190);
    
    if (boardLengths.length > 0) {
        ctx.fillText("Board lengths:", canvas.width/2+80, 210);
        
        // Group by length (rounded to nearest mm)
        let groups = {};
        for (let board of boardLengths) {
            let key;
            let angleText = board.angle === 45 ? "Gray" : "Red";
            
            if (Array.isArray(board.length)) {
                // For boards with multiple cut lengths
                let roundedLengths = board.length.map(len => Math.round(len * 10));
                // Sort to ensure consistent key generation
                roundedLengths.sort((a, b) => a - b);
                key = angleText + "-" + roundedLengths.join("+");
            } else {
                // For boards with a single cut length
                let roundedLength = Math.round(board.length * 10);
                key = angleText + "-" + roundedLength;
            }
            
            if (!groups[key]) {
                groups[key] = {
                    angle: angleText,
                    length: Array.isArray(board.length) ? board.length.map(len => Math.round(len * 10)) : Math.round(board.length * 10),
                    count: 0
                };
            }
            groups[key].count++;
        }
        
        // Separate groups into gray and red
        let grayGroups = [];
        let redGroups = [];

        for (let key in groups) {
            let group = groups[key];
            if (group.angle === "Gray") {
                grayGroups.push(group);
            } else {
                redGroups.push(group);
            }
        }

        // Display the gray groups first
        let y = 230;
        for (let group of grayGroups) {
            let lengthText;
            
            if (Array.isArray(group.length)) {
                // For multiple cut lengths, show each value (e.g., "Cut1: 120mm, Cut2: 80mm")
                lengthText = group.length.map((len, i) => `Cut${i+1}: ${len}mm`).join(", ");
            } else {
                // For single cut length
                lengthText = `${group.length}mm`;
            }
            
            ctx.fillText(`${group.angle}: ${lengthText} - ${group.count} boards`, 
                        canvas.width/2+80, y);
                        
            harringbone.end.push(`${group.angle}: ${lengthText} - ${group.count} boards`);            
            y += 20;
            
            // Check if we're reaching the display limit
          //  if (y > 850) {
          //      ctx.fillText("...and more", canvas.width/2+80, y);
          //      break;
          //  }
        }

        // Then display the red groups (if we haven't hit display limit)
        if (y <= 550) {
            for (let group of redGroups) {
                let lengthText;
                
                if (Array.isArray(group.length)) {
                    // For multiple cut lengths, show each value (e.g., "Cut1: 120mm, Cut2: 80mm")
                    lengthText = group.length.map((len, i) => `Cut${i+1}: ${len}mm`).join(", ");
                } else {
                    // For single cut length
                    lengthText = `${group.length}mm`;
                }
                
                ctx.fillText(`${group.angle}: ${lengthText} - ${group.count} boards`, 
                            canvas.width/2+80, y);
                harringbone.end.push(`${group.angle}: ${lengthText} - ${group.count} boards`);             
                y += 20;
                
                // Check if we're reaching the display limit
             //   if (y > 850) {
             //       ctx.fillText("...and more", canvas.width/2+80, y);
              //      break;
             //   }
            }
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return boardLengths.length;
    
}
   
   
            
            function calcfirtsclincer(){
                
                if(firstnummber==0){
                    
                    woody=input3.value;
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=woody;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<miniwood)woody--;
                        else break;


                    }
                   savestorst=parseInt(woody);
                }
                if(firstnummber==1){
                    
                    if(programmnummer2==0)
                        woody=savestorst-input3.value/2;
                    if(programmnummer2==1)
                        woody=savestorst-input3.value/3-input3.value/3;
                    if(programmnummer2==2)
                        woody=savestorst-input3.value/3;
                    if(programmnummer2==3)
                        woody=savestorst;
                    if(woody<0)woody=0;
                    
                    firstnummber=-1;
                }
                
                firstnummber++;
                return woody;
                
                
            }
             function calcfirstwood(){
                
                if(input3<250){miniwood=0;}
                else{miniwood=250;}
                
                if(firstnummber==0){
                    
                    woody=input3.value;
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=woody;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)woody--;
                        else break;


                    }
                    savestorst=parseInt(woody);
                }
                if(firstnummber==1){
                    
                  woody=250;
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=woody;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)woody++;
                        else break;


                    }
                    if(woody>250)woody--;
                    saveminst=parseInt(woody);
                  
                  
                  //----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                  
                   wood=(savestorst/2+saveminst/2)/2+saveminst/2;
                   let woo1=(savestorst/2+saveminst/2)/2+saveminst/2;
                  let woo2=(savestorst/2+saveminst/2)/2+saveminst/2;
                  for (let i = 0; i < capx-1; i++){

                        woodcalc=woo1;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)woo1--;
                        else break;
                    }
                    
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=woo2;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)woo2++;
                        else break;
                    }
                    
                    wood=(Math.abs(woo1 - wood) < Math.abs(woo2 - wood) ? woo1 : woo2);
                  
                  
                  
                  //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                  
                   woo=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                    let wo1=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                  let wo2=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                  for (let i = 0; i < capx-1; i++){

                        woodcalc=wo1;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)wo1--;
                        else break;
                    }
                    
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=wo2;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)wo2++;
                        else break;
                    }
                    
                    
                    woo=(Math.abs(wo1 - woo) < Math.abs(wo2 - woo) ? wo1 : wo2);
                  
                  
                  
                   woody=wood+((woo-wood)/2);
                  
                  let wood1=wood+((woo-wood)/2);
                  let wood2=wood+((woo-wood)/2);
                  
                  
                  
                  //--------------------------------------------------------------------------------------------------------------------------------------------------------------------
                  for (let i = 0; i < capx-1; i++){

                        woodcalc=wood1;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)wood1--;
                        else break;
                    }
                    
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=wood2;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)wood2++;
                        else break;
                    }
                    woody=(Math.abs(wood1 - woody) < Math.abs(wood2 - woody) ? wood1 : wood2);
                    
                    
                    
                    
                    
                }
                if(firstnummber==2){
                   
                   woody=250;
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=woody;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)woody++;
                        else break;
                    }
                    if(woody>250)woody--;
                    saveminst=parseInt(woody);
                  
                }
                if(firstnummber==3){
                   
                   woody=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                    let wood1=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                  let wood2=((savestorst-(savestorst/2+saveminst/2))/2)+savestorst/2+saveminst/2;
                  for (let i = 0; i < capx-1; i++){

                        woodcalc=wood1;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)wood1--;
                        else break;
                    }
                    
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=wood2;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)wood2++;
                        else break;
                    }
                    
                    
                    woody=(Math.abs(wood1 - woody) < Math.abs(wood2 - woody) ? wood1 : wood2);

                   
                   
                }
                if(firstnummber==4){
                   
                    woody=(savestorst/2+saveminst/2)/2+saveminst/2;
                   let wood1=(savestorst/2+saveminst/2)/2+saveminst/2;
                  let wood2=(savestorst/2+saveminst/2)/2+saveminst/2;
                  for (let i = 0; i < capx-1; i++){

                        woodcalc=wood1;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood)wood1--;
                        else break;
                    }
                    
                    for (let i = 0; i < capx-1; i++){

                        woodcalc=wood2;
                        while(woodcalc<capx-1){

                            woodcalc=parseInt(input3.value)+parseInt(woodcalc);

                        }
                        woodcalc=woodcalc-input3.value;
                        if((capx-woodcalc)<=miniwood&&woody<input3.value)wood2++;
                        else break;
                    }
                    
                    
                    woody=(Math.abs(wood1 - woody) < Math.abs(wood2 - woody) ? wood1 : wood2);
                   
                    
                    firstnummber=-1;
                }
                firstnummber++;
                return woody;
            }
////GAMMALT--------------------------------------------------------------------------------------------------------------------- 
////GAMMALT--------------------------------------------------------------------------------------------------------------------- 
         
    // === On-canvas report helpers ===
function patternLabel(p, v){
  switch(Number(p)){
    case 0: return 'Planks (random lengths)';
    case 1: {
      const map = ['1/2','1/3','2/3','3/3'];
      const tag = map[Number(v)|0] ?? '1/2';
      return `Tiles ${tag}`;
    }
    case 2: return 'Whole boards';
    case 3: return 'Herringbone';
    default: return `Program ${p}`;
  }
}
function safeStr(val, def=''){ return (val==null||val==='') ? def : String(val); }
function safeNum(val, def=0){
  const n = parseFloat(String(val||'').replace(',','.'));
  return Number.isFinite(n) ? n : def;
}
function drawRoundedRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}
function drawKVGrid(ctx, x, y, colW, lineH, items){
  // items: [{k:'Room width', v:'5000 mm'}, ...]
  ctx.save();
  ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  items.forEach((row, i)=>{
    const yy = y + i*lineH;
    ctx.fillStyle = 'rgba(17,24,39,.65)'; // muted
    ctx.fillText(row.k, x, yy);
    ctx.fillStyle = '#111827';
    ctx.textAlign = 'right';
    ctx.fillText(row.v, x + colW, yy);
    ctx.textAlign = 'left';
  });
  ctx.restore();
}
function drawReportOnCanvas(ctx, planBitmap){
  const W = canvas.width, H = canvas.height;

  // 1) Mörk bakgrund (du har redan fyllt #121417 i NYTT, så hoppa om du vill)
  // ctx.fillStyle = '#121417'; ctx.fillRect(0,0,W,H);

  // 2) Vitt "papper" med skugga
  const margin = Math.round(Math.min(W,H) * 0.04);       // ~4% marginal
  const sheetW = Math.min(W - margin*2, 1100);
  const sheetH = Math.min(H - margin*2, Math.max(720, H - margin*2));
  const sx = Math.floor((W - sheetW)/2);
  const sy = Math.floor((H - sheetH)/2);
  window.__REPORT_BOUNDS = { x: sx, y: sy, w: sheetW, h: sheetH, r: 16 };
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.35)';
  ctx.shadowBlur = 24;
  ctx.shadowOffsetY = 8;
  ctx.fillStyle = '#ffffff';
  drawRoundedRect(ctx, sx, sy, sheetW, sheetH, 14);
  ctx.fill();
  ctx.restore();

  // 3) Inre paddings och typografi
  const pad = 20;
  const gx = sx + pad;
  let gy = sy + pad;

  ctx.save();
  ctx.fillStyle = '#111827';
  ctx.font = '600 20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Floor plan', gx, gy + 18);
  gy += 36;

  ctx.fillStyle = 'rgba(17,24,39,.6)';
  ctx.font = '16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Automatically generated report', gx, gy);
  gy += 12 + 8;
  ctx.restore();

  // 4) Hero-bild (ritningen)
  const heroW = sheetW - pad*2;
  const heroH = Math.round(sheetH * 0.42); // ~övre halvan
  if(planBitmap){
    const scale = Math.min(heroW / planBitmap.width, heroH / planBitmap.height);
    const drawW = Math.floor(planBitmap.width * scale);
    const drawH = Math.floor(planBitmap.height * scale);
    const hx = gx;
    const hy = gy;

    // ram
    ctx.save();
    ctx.fillStyle = '#f9fafb';
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, hx, hy, heroW, heroH, 8);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    // centerat i ramen
    const ix = hx + Math.floor((heroW - drawW)/2);
    const iy = hy + Math.floor((heroH - drawH)/2);
    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(planBitmap, ix, iy, drawW, drawH);
    ctx.restore();
  }
  gy += heroH + 14;

  // 5) Samla data
  const roomW  = safeStr(window.input?.value ?? 5000);
  const roomH  = safeStr(window.input2?.value ?? 4000);
  const boardL = safeStr(window.input3?.value ?? 1000);
  const boardW = safeStr(window.input4?.value ?? 200);
  const gapMMm = safeStr(window.input5?.value ?? '1,5'); // visa som användaren skriver
  const rot    = !!window.rotateroom;
  const p      = Number(window.programmnummer|0);
  const v      = Number(window.programmnummer2|0);



  // 6) Två kort i grid (Room/Boards + Pattern)
  const colGap = 14;
  const colW = Math.floor((sheetW - pad*2 - colGap) / 2);

  // Kort 1
  (function(){
    const x = gx, y = gy, w = colW, h = 140;
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, x, y, w, h, 10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = '#111827';
    ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Room & boards', x+10, y+18);

    drawKVGrid(ctx, x+10, y+38, w-20, 18, [
      {k:'Room width',    v: `${roomW} mm`},
      {k:'Room depth',    v: `${roomH} mm`},
      {k:'Board length',  v: `${boardL} mm`},
      {k:'Board width',   v: `${boardW} mm`},
      {k:'Expansion gap', v: `${gapMMm} mm/m`},
    ]);
    ctx.restore();
  })();

  // Kort 2
  (function(){
    const x = gx + colW + colGap, y = gy, w = colW, h = 140;
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    drawRoundedRect(ctx, x, y, w, h, 10);
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = '#111827';
    ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Pattern', x+10, y+18);
    
    
    if(programmnummer==3){
    drawKVGrid(ctx, x+10, y+38, w-20, 18, [
      {k:'Type',        v: patternLabel(p, v)},
      {k:'Rotate room', v: rot ? 'Yes' : 'No'},
      {k:'Generated',   v: new Date().toLocaleString()},
      {k:'Rum m2',   v: kapraderdata.Totalyta},
      {k:'Floor m2',   v: kapraderdata.Golvyta},
      {k:'Planks to buy m2',   v: harringbone.M2brädor},
    ]);
    }
    else{
    drawKVGrid(ctx, x+10, y+38, w-20, 18, [
      {k:'Type',        v: patternLabel(p, v)},
      {k:'Rotate room', v: rot ? 'Yes' : 'No'},
      {k:'Generated',   v: new Date().toLocaleString()},
      {k:'Rum m2',   v: kapraderdata.Totalyta},
      {k:'Floor m2',   v: kapraderdata.Golvyta},
      {k:'Planks to buy m2',   v: kapraderdata.M2BrädorKöpa},
    ]);    
    }
    
    ctx.restore();
  })();

  gy += 140 + 12;

// 7) Computed totals + (för herringbone) Edge cuts till höger
const haveTotals = 100;
if(haveTotals){

  const ppp = Number(programmnummer|0);

  // --- Hjälpare för HB-bitar ---
    const bitsRows = [];
    const b = harringbone.bits || {};

    // Samma formattering som innan
    const fmtBit = (o)=> `${o.long}/${o.short} ${o.color}  X:${o.count}`;
    const hasBit = (o) => !!o && ((o.count|0) > 0); // eller din gamla om du vill

    // Mappa färg -> A/B (A=röd, B=grå)
    const bandOf = (o) => (String(o.color).toLowerCase() === 'red') ? 'A' : 'B';

    // Ta bara med bitar som faktiskt används
    const list = [];

  // =========================
  // CASE: Herringbone (p==3)
  // =========================
  if(ppp === 3){

    // ---- Vänster kort: Computed totals (kompakt) ----
    (function(){
      const x = gx, y = gy, w = colW, h = 180;

      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      drawRoundedRect(ctx, x, y, w, h, 10);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = '#111827';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('Computed totals', x+10, y+18);

      const rows = [];

      // översikt
      rows.push({k:'Start triangles', v:String(harringbone.starttrianglar)});
      rows.push({k:'Left triangle',   v:String(harringbone.vänstertriangeln + ' mm')});
      rows.push({k:'Right triangle',  v:String(harringbone.högertriangeln  + ' mm')});
      rows.push({k:'Whole boards',    v:String(harringbone.helabrädor)});
      rows.push({k:'Boards total',    v:String(harringbone.brädor)});

      // bits (bit2 skrivs bara ut om den behövs)
        if(hasBit(b.höger1))   list.push({side:'Right', idx:1, o:b.höger1});
        if(hasBit(b.höger2))   list.push({side:'Right', idx:2, o:b.höger2});
        if(hasBit(b.vänster1)) list.push({side:'Left',  idx:1, o:b.vänster1});
        if(hasBit(b.vänster2)) list.push({side:'Left',  idx:2, o:b.vänster2});

        // Sortera så det blir stabilt: A först, sen B (valfritt)
       // list.sort((a,bx)=> (bandOf(a.o) > bandOf(bx.o)) ? 1 : -1);

        // Skriv ut med A/B istället för color + Right/Left
        for(const it of list){
          const band = bandOf(it.o);
         rows.push({
            k: `${band} bit (${it.side} ${it.idx})`,
            v: fmtBit(it.o).replace(/\sred\s/i,'').replace(/\sgray\s/i,'') // ta bort "red/gray" i texten
          });
        }

      // 1 kolumn (för att slippa trängsel)
      drawKVGrid(ctx, x+10, y+38, w-20, 18, rows.slice(0, 9));

      ctx.restore();
    })();

    // ---- Höger kort: Edge cuts (harringbone.end) ----
    (function(){
      const x = gx + colW + colGap, y = gy, w = colW, h = 380;

      ctx.save();
      ctx.fillStyle = '#ffffff';
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      drawRoundedRect(ctx, x, y, w, h, 10);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle = '#111827';
      ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText('End cuts', x+10, y+18);

      // Förbered rader (gruppera Gray/Red om dina strängar börjar så)
      const endArr = Array.isArray(harringbone.end) ? harringbone.end : [];
      const lines = endArr.map(e => (typeof e === 'string') ? e : JSON.stringify(e));

      const gray = lines.filter(s => String(s).trim().startsWith('Gray'));
      const red  = lines.filter(s => String(s).trim().startsWith('Red'));
      const other= lines.filter(s => !(String(s).trim().startsWith('Gray') || String(s).trim().startsWith('Red')));

      // Render i 1 kolumn
        const innerX = x + 10;
        const innerY = y + 38;
        const innerW = w - 20;
        const innerH = h - 48;
        const lineH  = 20;

      ctx.save();
      ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillStyle = 'rgba(17,24,39,65)';

      let cx = innerX, cy = innerY;

      function drawHeader(t){
        ctx.fillStyle = '#111827';
        ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.fillText(t, cx, cy);
        cy += lineH;
        ctx.fillStyle = 'rgba(17,24,39,65)';
        ctx.font = '20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      }
      function drawLine(t){
        
        // klipp texten lite om den blir för lång
        const s = String(t);
        let s2 = s.trim();
s2 = s2.replace(/^Gray:\s*/,''); // B
s2 = s2.replace(/^Red:\s*/,'');  // A

        ctx.fillText(s2, cx, cy);
        cy += lineH;
        return true;
      }
      if(red.length){  drawHeader('A');  for(const s of red){  if(!drawLine(s)) break; } }
      if(gray.length){ drawHeader('B'); for(const s of gray){ if(!drawLine(s)) break; } }
      if(other.length){drawHeader('Other');for(const s of other){if(!drawLine(s)) break; } }

      ctx.restore();
      ctx.restore();
    })();

    // OBS: vi har ritat båda korten -> hoppa över gamla fullbredds-kortet
    ctx.restore?.();
    return;
  }

  // =========================
  // Default: gamla fullbredds
  // =========================
  const x = gx, y = gy, w = sheetW - pad*2, h = 180;
  ctx.save();
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 1;
  drawRoundedRect(ctx, x, y, w, h, 10);
  ctx.fill(); ctx.stroke();

  ctx.fillStyle = '#111827';
  ctx.font = '600 16px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Computed totals', x+10, y+18);

  const rows = [];
  if(programmnummer===0){
    rows.push({k:'Row1: first/last plank', v:String(kaprader.Första1+" / "+kaprader.Sista1+" X:" +kaprader.antal1 )});
    rows.push({k:'Row2: first/last plank', v:String(kaprader.Första2+" / "+kaprader.Sista2+" X:" +kaprader.antal2 )});
    rows.push({k:'Row3: first/last plank', v:String(kaprader.Första3+" / "+kaprader.Sista3+" X:" +kaprader.antal3 )});
    rows.push({k:'Row4: first/last plank', v:String(kaprader.Första4+" / "+kaprader.Sista4+" X:" +kaprader.antal4 )});
    rows.push({k:'Row5: first/last plank', v:String(kaprader.Första5+" / "+kaprader.Sista5+" X:" +kaprader.antal5 )});
  }
  if(programmnummer==1){
    rows.push({k:'Row1: first/last plank', v:String(kaprader.Första1+" / "+kaprader.Sista1+" X:" +kaprader.antal1 )});
    rows.push({k:'Row2: first/last plank', v:String(kaprader.Första2+" / "+kaprader.Sista2+" X:" +kaprader.antal2 )});
  }
  if(programmnummer==2){
    rows.push({k:'Coverage ratio', v:String(kapraderdata.utnyttjande +"%" )});
  }

  const left = rows.slice(0, Math.ceil(5));
  const right= rows.slice(5);

  drawKVGrid(ctx, x+10, y+38, Math.floor((w-30)/2), 18, left);
  ctx.save(); ctx.textAlign='left';
  drawKVGrid(ctx, x+Math.floor(w/2), y+38, Math.floor((w-30)/2), 18, right);
  ctx.restore();

  ctx.restore();
}

}

// === Din NYTT() – lägg till anropet i slutet ===
async function NYTT(){
  if (PLAN_BITMAP) PLAN_BITMAP.close();

  const { sx, sy, sw, sh } = getPlanBounds();
  PLAN_BITMAP = await createImageBitmap(canvas, sx, sy, sw, sh);

  // Bakgrund till rapport
  ctx.fillStyle = "#121417";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Rita rapporten på canvas
  drawReportOnCanvas(ctx, PLAN_BITMAP);

  // (om du vill: rita debug-värden överst)
  // ctx.fillStyle = "black";
  // ctx.fillText(`hb end: ${ (harringbone?.end ?? []).slice(-1)[0] ?? '-' }`, 50, 50);
} 
         
    function drawPlanBitmapAt(ctx2d, x, y, scale = 1, rotationRad = 0, center = true) {
      if (!PLAN_BITMAP) return;
      const w = PLAN_BITMAP.width * scale;
      const h = PLAN_BITMAP.height * scale;

      ctx2d.save();
      ctx2d.translate(x, y);
      if (rotationRad) ctx2d.rotate(rotationRad);
      if (center) ctx2d.drawImage(PLAN_BITMAP, -w/2, -h/2, w, h);
      else        ctx2d.drawImage(PLAN_BITMAP, 0, 0, w, h);
      ctx2d.restore();
    }
    function getPlanBounds() {
        // Grundytan du redan ritar (den vita rektangeln)
        const x = (canvas.width/2) - (Number(input.value) / 20);
        const y = 450;
        const w = Number(input.value) / 10;
        const h = Number(input2.value) / 10;

        // (valfritt) lägg på en pixelpadding för att få med kanter/linjer
        const pad = 1;

        // Returnera heltal (krav för image bitmap crop i vissa motorer)
        const sx = Math.floor(x - pad);
        const sy = Math.floor(y - pad);
        const sw = Math.ceil(w + pad*2);
        const sh = Math.ceil(h + pad*2);

        // Skydda mot negativa/värden utanför canvas
        return {
          sx: Math.max(0, sx),
          sy: Math.max(0, sy),
          sw: Math.max(1, Math.min(sw, canvas.width  - Math.max(0, sx))),
          sh: Math.max(1, Math.min(sh, canvas.height - Math.max(0, sy))),
        };
    }     
         
// ===== Helpers: tabellrendering & datanormalisering =====
function pickKeysForObjects(arr, maxCols=6){
  // Välj upp till maxCols mest förekommande nycklar i objekt
  const freq = new Map();
  for(const o of arr){
    if(!o || typeof o!=='object') continue;
    for(const k of Object.keys(o)) freq.set(k, (freq.get(k)||0)+1);
  }
  // prioritera vanliga fältnamn
  const preferred = ['row','index','x','y','angle','dir','length','len','width','w','count','pieces','waste','type','side'];
  const keys = Array.from(freq.keys()).sort((a,b)=>{
    const ai = preferred.indexOf(a), bi = preferred.indexOf(b);
    if(ai!==-1 || bi!==-1) return (ai===-1?99:ai) - (bi===-1?99:bi);
    return freq.get(b)-freq.get(a);
  }).slice(0, maxCols);
  return keys;
}
function rowsFromArray(arr, maxRows=60){
  // Returnerar {headers, rows} för arr av objekt/array/nummer
  if(!Array.isArray(arr) || arr.length===0) return {headers:[], rows:[]};

  // Objekt?
  if (arr.some(v => v && typeof v === 'object' && !Array.isArray(v))){
    const keys = pickKeysForObjects(arr);
    const rows = [];
    for(let i=0;i<Math.min(arr.length, maxRows);i++){
      const o = arr[i] || {};
      rows.push(keys.map(k => o[k]));
    }
    return { headers: keys, rows };
  }
  // Array?
  if (arr.some(v => Array.isArray(v))){
    const maxLen = Math.min(
      Math.max(...arr.map(a => Array.isArray(a) ? a.length : 0)),
      8
    );
    const headers = Array.from({length:maxLen}, (_,i)=> `col${i}`);
    const rows = [];
    for(let i=0;i<Math.min(arr.length, maxRows);i++){
      const a = Array.isArray(arr[i]) ? arr[i] : [];
      rows.push(headers.map((_,j)=> a[j]));
    }
    return { headers, rows };
  }
  // Platt lista (nummer/strängar)
  return { headers:['value'], rows: arr.slice(0, maxRows).map(v=>[v]) };
}
function formatCell(v){
  if(v==null) return '';
  const s = String(v);
  // byt punkt→komma för mm om det ser numeriskt ut
  if(/^-?\d+(\.\d+)?$/.test(s)) return s.replace('.', ',');
  return s;
}
function drawTableCard(ctx, title, x, y, w, data, opts={}){
  const { headers=[], rows=[] } = data || {};
  const lineH  = opts.lineH  || 18;
  const pad    = opts.pad    || 10;
  const headBg = opts.headBg || '#f3f4f6';
  const rule   = '#e5e7eb';

  const visibleRows = Math.min(rows.length, opts.maxRows || 20);
  const h =  // titel + header + rader + padd
    20 + 6 + lineH + visibleRows*lineH + pad*2;

  // kort
  ctx.save();
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = rule;
  ctx.lineWidth = 1;
  drawRoundedRect(ctx, x, y, w, h, 10);
  ctx.fill(); ctx.stroke();

  // titel
  ctx.fillStyle = '#111827';
  ctx.font = '600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(title, x+pad, y+pad+13);

  // header bakgrund
  const headY = y + pad + 20 + 6;
  ctx.fillStyle = headBg;
  ctx.fillRect(x+pad, headY-14, w-pad*2, lineH);

  // kolumnbredder (jämn fördelning)
  const colW = Math.floor((w - pad*2) / Math.max(headers.length,1));

  // header text
  ctx.fillStyle = 'rgba(17,24,39,.75)';
  ctx.font = '600 12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  headers.forEach((hname, i)=>{
    const cx = x+pad + i*colW + 6;
    ctx.fillText(String(hname), cx, headY);
  });

  // rader
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillStyle = '#111827';
  for(let r=0;r<visibleRows;r++){
    const yy = headY + (r+1)*lineH;
    // horisontal linje
    ctx.strokeStyle = rule; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x+pad, yy-14 + lineH); ctx.lineTo(x+w-pad, yy-14 + lineH); ctx.stroke();

    const row = rows[r] || [];
    for(let c=0;c<headers.length;c++){
      const cell = formatCell(row[c]);
      const cx = x+pad + c*colW + 6;
      ctx.fillText(cell, cx, yy);
    }
  }

  ctx.restore();
  return h + 10; // nytt y-offset
}
function sumFields(arr, fieldNames){
  // summerar första fält som finns i fieldNames
  if(!Array.isArray(arr)) return null;
  const f = fieldNames.find(fn => arr.some(o => o && typeof o==='object' && o[fn]!=null));
  if(!f) return null;
  let s = 0;
  for(const o of arr){
    const v = o && typeof o==='object' ? o[f] : null;
    const n = parseFloat(String(v ?? '').replace(',', '.'));
    if(Number.isFinite(n)) s += n;
  }
  return { field:f, sum:s };
}         
         </script>
         
<!-- === Mobile/Capacitor UI bridge (v2) === -->


<div id="floor-ui" role="group" aria-label="Floor controls">
  <div class="bar">
    <div class="title">Floor planner</div>
    <div class="actions">
        
        <button id="ui-export-pdf" type="button" class="toggle">Save PDF</button>
      <label class="switch" style="display:flex;align-items:center;gap:8px;font-size:18px;color:var(--ui-muted);">
        <input id="ui-rotate" type="checkbox" style="width:20px;height:20px;accent-color:var(--ui-accent)">
        Rotate room
      </label>
    </div>
  </div>

  <div class="grid cols-2">
    <div>
      <label>Room width (mm)</label>
      <input id="ui-room-w" type="number" min="200" step="10" inputmode="numeric">
    </div>
    <div>
      <label>Room depth (mm)</label>
      <input id="ui-room-h" type="number" min="200" step="10" inputmode="numeric">
    </div>
  </div>

  <div class="grid cols-3">
    <div>
      <label>Board length (mm)</label>
      <input id="ui-board-l" type="number" min="260" step="10">
    </div>
    <div>
      <label>Board width (mm)</label>
      <input id="ui-board-w" type="number" min="50" step="1">
    </div>
    <div>
      <label>Expansion gap mm/m</label>
      <input id="ui-gap" type="number" min="0" step="0.1">
    </div>
  </div>

  <div class="grid">
    <label>Pattern</label>
    <div class="seg" id="ui-program">
      <button data-p="0">Planks</button>
      <button data-p="1">Tiles</button>
      <button data-p="2">Whole boards</button>
      <button data-p="3">Herringbone</button>
    </div>
  </div>

  <div class="grid" id="ui-tiles">
    <label>Tiles variant</label>
    <div class="seg" id="ui-tiles-variants">
      <button data-v="0">1/2</button>
      <button data-v="1">1/3</button>
      <button data-v="2">2/3</button>
      <button data-v="3">3/3</button>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const ui = {
    w:  $('#ui-room-w'),
    h:  $('#ui-room-h'),
    bl: $('#ui-board-l'),
    bw: $('#ui-board-w'),
    gap:$('#ui-gap'),
    rot:$('#ui-rotate'),
    progWrap: $('#ui-program'),
    tilesWrap: $('#ui-tiles'),
    tilesSeg:  $('#ui-tiles-variants'),
  };

  // --- Dölj legacy-kontroller helt (de skapas i din fil) ---
  [
    window.input, window.input2, window.input3, window.input4, window.input5,
    window.button, window.button3, window.button4, window.button5, window.button6,
    window.button7, window.button8, window.button9
  ].forEach(el => { if(el){ el.classList?.add('legacy-hide'); el.tabIndex=-1; } });

  // --- Hjälpare ---
  const V = (val, lo=-Infinity, hi=Infinity) => {
    // Tar både "1.5" och "1,5"
    const n = parseFloat(String(val ?? '').replace(',', '.'));
    const x = isFinite(n) ? n : 0;
    return Math.min(Math.max(x, lo), hi);
  };
  let t=null;
  const scheduleRender = () => { clearTimeout(t); t=setTimeout(()=>{ try{ syncToLegacy(); window.check && window.check(); }catch(_){} }, 60); };
  const setActive = (wrap, test) => wrap.querySelectorAll('button').forEach(b => b.classList.toggle('active', test(b)));

  // --- Sync från legacy -> UI ---
  function syncFromLegacy(){
    if (window.input)  ui.w.value  = V(window.input.value, 0, 1e6);
    if (window.input2) ui.h.value  = V(window.input2.value, 0, 1e6);
    if (window.input3) ui.bl.value = V(window.input3.value, 0, 1e6);
    if (window.input4) ui.bw.value = V(window.input4.value,  0, 1e6);
    if (window.input5) ui.gap.value= V(window.input5.value,  0, 1e6); // visa med komma om du vill

    ui.rot.checked = !!window.rotateroom;

    const p = Number(programmnummer|0);
    const v = Number(programmnummer2|0);
    setActive(ui.progWrap, b => Number(b.dataset.p)===p);
    ui.tilesWrap.style.display = (p===1) ? 'block' : 'none';
    setActive(ui.tilesSeg, b => Number(b.dataset.v)===v);
  }

  // --- Sync från UI -> legacy ---
  function syncToLegacy(){
    if (window.input)  window.input.value  = V(ui.w.value,  0, 1e6);
    if (window.input2) window.input2.value = V(ui.h.value,  0, 1e6);
    if (window.input3) window.input3.value = V(ui.bl.value, 0, 1e6);
    if (window.input4) window.input4.value = V(ui.bw.value,  0, 1e6);
    if (window.input5) window.input5.value = V(ui.gap.value, 0,   100);
    rotateroom = !!ui.rot.checked;
  }

  // Inmatning
  [ui.w, ui.h, ui.bl, ui.bw, ui.gap].forEach(inp=>{
    inp.addEventListener('input', scheduleRender, {passive:true});
    inp.addEventListener('change', scheduleRender, {passive:true});
  });
  ui.rot.addEventListener('change', scheduleRender, {passive:true});

  // Programval
  ui.progWrap.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('button[data-p]');
    if(!btn) return;
    const p = Number(btn.dataset.p);
    programmnummer = p;                            // 0,1,2,3  (se legacy) :contentReference[oaicite:2]{index=2}
    if(p!==1) programmnummer2 = 0;                 // reset tiles-variant när man lämnar Tiles
    syncFromLegacy();
    scheduleRender();
  });

  // Tiles-varianter -> programmnummer2 (0..3)
  ui.tilesSeg.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('button[data-v]');
    if(!btn) return;
    programmnummer = 1;                            // säkerställ Tiles-läge
    programmnummer2 = Number(btn.dataset.v);       // 0..3 (1/2,1/3,2/3,3/3) :contentReference[oaicite:3]{index=3}
    syncFromLegacy();
    scheduleRender();
  });

  // Om något utanför UI råkar ändra legacy-värden (skulle vara ovanligt
  // nu när vi gömmer dem), håll UI i synk.
  const moTargets = [window.input, window.input2, window.input3, window.input4, window.input5].filter(Boolean);
  if(moTargets.length){
    const mo = new MutationObserver(()=> syncFromLegacy());
    moTargets.forEach(el=> mo.observe(el, {attributes:true, attributeFilter:['value']}));
  }

  // Init
  syncFromLegacy();
  scheduleRender();
  window.addEventListener('resize', scheduleRender, {passive:true});
})();
</script>
<script>
(function(){
  const ui = document.getElementById('floor-ui');



  // 2) Mät panelhöjden och sätt body padding-bottom så inget döljs bakom
  function measureAndPad(){
    if(!ui) return;
    // höjd som antingen är full panel eller bara fliken om collapsed
    const h = ui.classList.contains('collapsed') ? 42 : Math.ceil(ui.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--floor-ui-h', h + 'px');
  }

  // Mät vid start, resize och om panelens storlek ändras (t.ex. tiles-variant visas)
  measureAndPad();
  window.addEventListener('resize', measureAndPad, {passive:true});
  if (window.ResizeObserver){
    const ro = new ResizeObserver(measureAndPad);
    ro.observe(ui);
  }


})();
</script>         
<script>
// ---- PDF utils (canvas -> PDF Blob) ----
async function canvasToPdfBlob_fromCrop(sourceCanvas, cropRect, opts={}){
  const mmToPt = mm => mm * 72 / 25.4;
  const pageWpt = mmToPt(210), pageHpt = mmToPt(297);       // A4 porträtt
  const marginTopPt = mmToPt(opts.marginTopMM ?? 10);       // toppmarginal
  const marginLeftPt= mmToPt(opts.marginLeftMM ?? 10);      // vänstermarginal
  const marginRightPt= mmToPt(opts.marginRightMM ?? (opts.marginLeftMM ?? 10));

  // 1) Bygg ett "rent ark" med vit bakgrund + rundad clip
  const sx = cropRect.x|0, sy = cropRect.y|0;
  const sw = Math.max(1, cropRect.w|0), sh = Math.max(1, cropRect.h|0);
  const r  = Math.max(0, cropRect.r|0 || 0);

  const sheet = document.createElement('canvas');
  sheet.width = sw; sheet.height = sh;
  const sctx = sheet.getContext('2d');

  // vit bakgrund
  sctx.fillStyle = '#ffffff'; sctx.fillRect(0,0,sw,sh);

  // rundad clip så vi bara tar innehållet "inne i arket"
  if(r > 0){
    sctx.beginPath();
    const rr = Math.min(r, sw/2, sh/2);
    sctx.moveTo(rr, 0);
    sctx.arcTo(sw, 0,  sw, sh, rr);
    sctx.arcTo(sw, sh, 0,  sh, rr);
    sctx.arcTo(0,  sh, 0,  0,  rr);
    sctx.arcTo(0,  0,  sw, 0,  rr);
    sctx.closePath();
    sctx.clip();
  }

  // rita käll-canvasens ark-innehåll inuti clippen
  sctx.drawImage(sourceCanvas, sx, sy, sw, sh, 0, 0, sw, sh);

  // 2) JPEG av "rena arket"
  const dataUrl = sheet.toDataURL('image/jpeg', 0.92);
  const base64  = dataUrl.split(',')[1];
  const imgBytes= Uint8Array.from(atob(base64), c => c.charCodeAt(0));

  // 3) Placera uppe/åt vänster med marginaler (inte centrerat)
  const availWpt = pageWpt - marginLeftPt - marginRightPt;
  // skala bara om arket är bredare än ytan; annars 1:1
  const scale = Math.min(1, availWpt / sw);
  const drawW = sw * scale, drawH = sh * scale;

  const leftPt   = marginLeftPt;
  const bottomPt = pageHpt - marginTopPt - drawH;  // toppjusterat

  // 4) Minimal PDF
  const enc = s => new TextEncoder().encode(s);
  const parts=[], offs=[]; const size=()=>parts.reduce((s,a)=>s+a.length,0);
  const push=u8=>{ offs.push(size()); parts.push(u8); };

  push(enc('%PDF-1.4\n%âãÏÓ\n'));
  push(enc('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n'));
  push(enc('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n'));
  push(enc(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 ${pageWpt.toFixed(2)} ${pageHpt.toFixed(2)}] /Resources << /XObject << /Im0 4 0 R >> /ProcSet [/PDF /ImageC] >> /Contents 5 0 R >>\nendobj\n`));
  push(enc(`4 0 obj\n<< /Type /XObject /Subtype /Image /Width ${sw} /Height ${sh} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${imgBytes.length} >>\nstream\n`));
  parts.push(imgBytes);
  push(enc('\nendstream\nendobj\n'));

  const stream = `q\n${drawW.toFixed(2)} 0 0 ${drawH.toFixed(2)} ${leftPt.toFixed(2)} ${bottomPt.toFixed(2)} cm\n/Im0 Do\nQ\n`;
  push(enc(`5 0 obj\n<< /Length ${stream.length} >>\nstream\n${stream}endstream\nendobj\n`));

  const xrefStart = size();
  let xref = 'xref\n0 6\n0000000000 65535 f \n';
  for(let i=0;i<parts.length;i++){ xref += String(i===0?0:offs[i]).padStart(10,'0') + ' 00000 n \n'; }
  push(enc(xref));
  push(enc(`trailer\n<< /Size 6 /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`));

  const out = new Uint8Array(size()); let p=0; for(const a of parts){ out.set(a,p); p+=a.length; }
  return new Blob([out], { type:'application/pdf' });
}

// Spara/dela (samma som tidigare)
async function savePdfBlob(blob, filename='FloorPlan.pdf'){
  if(!window.Capacitor){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
    return true;
  }
  try{
    const { Filesystem } = window.Capacitor.Plugins || {};
    const toB64 = b => new Promise(r=>{ const fr=new FileReader(); fr.onload=()=>r(String(fr.result).split(',')[1]); fr.readAsDataURL(b); });
    const data = await toB64(blob);
    const path = `FloorPlan-${Date.now()}.pdf`;
    await Filesystem.writeFile({ path, data, directory: 'DOCUMENTS' });
    const Share = window.Capacitor.Plugins?.Share;
    if(Share) await Share.share({ title:'Floor plan', url:`file://${path}` });
  }catch(e){ console.warn('Capacitor save failed', e); }
}

// ---- Save/Share helper ----
async function savePdfBlob(blob, filename='FloorPlan.pdf'){
  // Web: ladda ned
  if(!window.Capacitor){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; document.body.appendChild(a);
    a.click(); a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
    return true;
  }
  // Capacitor: skriv fil och dela/öppna
  try{
    const { Filesystem } = window.Capacitor.Plugins || {};
    const toBase64 = (blob) => new Promise(r=>{
      const fr = new FileReader(); fr.onload = () => r(String(fr.result).split(',')[1]); fr.readAsDataURL(blob);
    });
    const b64 = await toBase64(blob);
    const path = `FloorPlan-${Date.now()}.pdf`;
    await Filesystem.writeFile({ path, data: b64, directory: 'DOCUMENTS' });
    // Dela om Share finns, annars bara klart
    const Share = window.Capacitor.Plugins?.Share;
    if(Share){
      await Share.share({ title:'Floor plan', text:'PDF exported', url:`file://${path}`, dialogTitle:'Share PDF' });
    }
    return true;
  }catch(e){
    console.warn('Capacitor PDF save failed:', e);
    return false;
  }
}

// ---- Hooka upp knappen ----
(function(){
  const btn = document.getElementById('ui-export-pdf');
  if(!btn) return;

  // tiny helper: let the UI settle
  const nextFrame = () => new Promise(r => requestAnimationFrame(()=>r()));

  async function doExport(){
    // 1) DO NOT call NYTT() here – it clears/close()s PLAN_BITMAP
    //    Just snapshot what the user currently sees.
    const live = (window.canvas instanceof HTMLCanvasElement)
      ? window.canvas
      : document.querySelector('canvas');
    if(!live){ alert('No canvas'); return; }

    // wait 1 frame in case of last keystroke
    await nextFrame();

    // 2) Freeze current pixels into an offscreen copy (atomic snapshot)
    const bmp = await createImageBitmap(live);
    const off = document.createElement('canvas');
    off.width = live.width; off.height = live.height;
    const octx = off.getContext('2d', { alpha: true });
    octx.drawImage(bmp, 0, 0);
    bmp.close();

    // 3) Use the report bounds we stored when drawing the report
    const r = window.__REPORT_BOUNDS;
    if(!r){ alert('Report not ready'); return; }

    // 4) Build PDF from the cropped report only (no black background)
    const pdf = await canvasToPdfBlob_fromCrop(off, r, { marginMM: 10 });
    await savePdfBlob(pdf, 'FloorPlan.pdf');
  }

  const handle = e => {
    if(e.type==='keydown' && !['Enter',' '].includes(e.key)) return;
    e.preventDefault(); e.stopPropagation();
    doExport();
  };

  btn.type = 'button';
  btn.addEventListener('click', handle, {passive:false});
  btn.addEventListener('touchstart', handle, {passive:false});
  btn.addEventListener('keydown', handle, {passive:false});
})();
</script>         
    </body>
</html>
