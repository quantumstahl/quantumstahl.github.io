<!DOCTYPE html>

<html>
<head>
<title>MaxPaint</title>
<meta charset="utf-8"/>
<meta content="user-scalable=no, shrink-to-fit=no" name="viewport"/>
<meta content="maxpaint,paint" name="keywords"/>
<link href="loggo.png" rel="icon" type="image/vnd.microsoft.icon"/>
<style>
            
              body {
    overscroll-behavior: none;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }       

            
        canvas {
          background-color: #50459b;
          max-width: 100%;
          max-height: 100%;
          image-rendering: pixelated;
          /* Enhanced pixel rendering properties for all browsers */
          image-rendering: -moz-crisp-edges;    /* Firefox */
          image-rendering: -webkit-crisp-edges; /* Webkit */
          image-rendering: pixelated;           /* Chrome, Edge, Opera, Safari */
          image-rendering: crisp-edges;         /* Standard syntax */
          -ms-interpolation-mode: nearest-neighbor;  /* IE */
          display: block;
          margin: auto;
        }
        .btn-open {
          padding: 8px 15px;
          font-size: 16px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          position: absolute;
          top: 50px; /* Centered in toolbar height */
          left: 0px;
          transform: translateY(-50%);
          z-index: 100;
          outline: none; /* Remove outline */
          box-shadow: none;
        }
        .btn-open:hover {
          background-color: #45a049;
        }
        .zoom-container {
          position: absolute;
          top: 50px; /* Centered in toolbar height */
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          z-index: 100;
          touch-action: none;
          -webkit-touch-callout: none;
          pointer-events: auto;
          outline: none; /* Remove outline */
          box-shadow: none;
        }
        #zoomLabel, #brushSizeLabel {
            -webkit-user-select: none;  /* Safari */
            -moz-user-select: none;     /* Firefox */
            -ms-user-select: none;      /* IE/Edge */
            user-select: none;          /* Standard syntax */
            cursor: default;            /* Change cursor to default instead of text */
          }

          /* Make all labels and text in the control area non-selectable */
          .zoom-container, label {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default;
          }
        #zoomSlider, #brushSizeSlider {
            touch-action: none;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
          }
          #zoomSlider, #brushSizeSlider, .zoom-container, #zoomLabel, #brushSizeLabel,.color-palette {
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            -khtml-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            touch-action: none !important;
            outline: none; /* Remove outline */
            box-shadow: none;
            touch-action: none;
        }
          
          
          
        
        @media (max-width: 768px), (pointer: coarse) {
          .btn-open {
            padding: 15px 25px;
            font-size: 22px;
            top: 60px;
            left: 20px;
          }
        .scrollbar-hitbox {
            position: absolute;
            z-index: 99;
          }
          .zoom-container {
            top: 68px;
            left: 390px;
            transform: translateY(-50%);
            padding: 0 80px;
            box-sizing: border-box;
          }

          #zoomSlider {
            width: 100%;
            height: 30px;
            margin-top: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #d3d3d3;
            outline: none;
            border-radius: 15px;
          }

          #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #4CAF50;
            border-radius: 50%;
            width: 180px; 
            height: 180px;
            transform: scale(0.3);
            margin-left: -65px; /* Adjust this value to center the thumb vertically */
            margin-right: 220px;
            cursor: pointer; 
            
          }

          #zoomSlider::-moz-range-thumb {
            width: 45px; 
            height: 45px;
            background: #4CAF50;
            border-radius: 50%;
            transform: scale(0.8);
          }
          
          /* Brush size slider styling similar to zoomSlider */
          #brushSizeSlider {
            width: 100%;
            height: 30px;
            margin-top: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #d3d3d3;
            outline: none;
            border-radius: 15px;
          }

          #brushSizeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 180px; 
            height: 180px;
            transform: scale(0.3);
            margin-left: -65px; /* Adjust this value to center the thumb vertically */
            margin-right: 220px;;
            background: #4CAF50;
            border-radius: 50%;
          }

          #brushSizeSlider::-moz-range-thumb {
            width: 35px;
            height: 35px;
            background: #4CAF50;
            border-radius: 50%;
          }

          #zoomLabel, #brushSizeLabel {
            font-size: 18px;
            font-weight: bold;
            
          }
        }
          .color-palette {
            border: 1px solid transparent;  
            position: absolute;
            will-change: transform;
            background-color: #f1f1f1;
            padding: 9px;
            border-radius: 4px;
            left: 50%; margin-left: 120px; margin-top: 0;
            outline: none; /* Remove outline */
            box-shadow: none;
                
          }

          .color-row {
            display: flex;
            margin-bottom: 5px;
            outline: none; /* Remove outline */
            box-shadow: none;
          }

          .color-row:last-child {
            margin-bottom: 0;
          }

          .color-swatch {
            width: 28px;
            height: 28px;
            margin: 0 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s;
          }

          .color-swatch:hover {
            transform: scale(1.1);
          }

          .color-swatch.active {
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #000;
          }

          @media (max-width: 768px), (pointer: coarse) {
            .color-palette {
              position: absolute;
              border: 1px solid transparent;  
              will-change: transform;
              top: 0px;
              left: 560px;
              outline: none; /* Remove outline */
              box-shadow: none;
              
            
            }

            .color-swatch {
              width: 35px;
              height: 35px;
              margin: 0 3px;
              outline: none; /* Remove outline */
              box-shadow: none;
            }
          }
          /* Modal dialog styling */
      .modal {
        display: none;
        position: fixed;
        z-index: 3000; /* Higher than toolbar */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4);
      }
      
      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 300px;
        border-radius: 5px;
      }
      
      .modal-content h3 {
        margin-top: 0;
      }
      
      .modal-content .form-group {
        margin-bottom: 15px;
      }
      
      .modal-content label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      
      .modal-content input {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
      }
      
      .modal-content .button-row {
        text-align: right;
        margin-top: 20px;
      }
      
      .modal-content button {
        padding: 8px 15px;
        margin-left: 10px;
        cursor: pointer;
      }
        
.color-pop.hidden{ display:none }
.color-pop{
  position:fixed; inset:auto 1rem 1rem auto; z-index:9999;
  background:#222; color:#fff; border:1px solid #444; border-radius:12px;
  box-shadow:0 8px 30px rgba(0,0,0,.35);
  top:200px;
}
.color-pop-inner{ padding:12px; min-width:360px }
.color-pop .row{ display:flex }
#rainbowCanvas{ cursor:crosshair; border-radius:8px; outline:1px solid #555 }
#colorPreview{
  width:36px; height:36px; border-radius:8px; outline:1px solid #555; background:#fff;
}
.btn-primary,.btn-secondary,.tool-btn{
  font:inherit; padding:.45rem .8rem; border-radius:.6rem; border:0; cursor:pointer;
}
.btn-primary{ background:#4f8cff; color:#fff }
.btn-secondary{ background:#3a3a3a; color:#fff }
.tool-btn{ background:#2a2a2a; color:#fff; margin-left:.5rem }
.tool-btn[disabled]{ opacity:.5; cursor:not-allowed }
@media (max-width:700px){ .color-pop{ inset:auto .5rem .5rem .5rem; min-width:auto } }  
        
        
        </style>
</head>
<body>
<label for="directFileInput" style="position:absolute; top:10px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; min-width:90px; text-align:center; font-size:16px;">Open Image</label>
<input accept="image/*" id="directFileInput" style="position:absolute; left:-200px;" type="file"/>
<!-- Save Image button, positioned much lower -->
<button id="saveImageBtn" style="position:absolute; top:130px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:90px; text-align:center; font-size:16px;">Save Image</button>
<button id="project1Btn" style="position:absolute; top:150px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 1</button>
<button id="project2Btn" style="position:absolute; top:150px; left:100px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 2</button>
<button id="project3Btn" style="position:absolute; top:150px; left:202px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 3</button>
<button id="ResizeBtn" style="position: absolute;right: 0%; top:150px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Resize</button>
<div class="tool-buttons" style="position: absolute; top: 120px; z-index: 110; display: grid; grid-template-columns: repeat(6, 40px); grid-gap: 5px; transform: translateY(-50%);">
<!-- Pen Tool -->
<button class="tool-btn" id="penTool" style="width: 40px; height: 40px; background-color: #d4ffd4; border: 2px solid #4CAF50; border-radius: 4px; cursor: pointer; padding: 2px; position: relative;" title="Pen Tool (P)">
<svg style="width: 100%; height: 100%;" viewbox="0 0 24 24">
<path d="M3,17.25V21h3.75L17.81,9.94l-3.75-3.75L3,17.25z M20.71,7.04c0.39-0.39,0.39-1.02,0-1.41l-2.34-2.34c-0.39-0.39-1.02-0.39-1.41,0 l-1.83,1.83l3.75,3.75L20.71,7.04z" fill="#333"></path>
</svg>
</button>
<!-- Fill Tool (Watering Can) -->
<button class="tool-btn" id="fillTool" style="width: 40px; height: 40px; background-color: #f1f1f1; border: 2px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px; position: relative;" title="Fill Tool (F)">
<svg style="width: 100%; height: 100%;" viewbox="0 0 24 24">
<path d="M19,11.5c0,0-2,2.17-2,3.5c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M5.21,10L10,5.21L14.79,10H5.21z M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.46,17.15,9.5,16.56,8.94z" fill="#333"></path>
</svg>
</button>
<!-- Select Tool -->
<button class="tool-btn" id="selectTool" style="width: 40px; height: 40px; background-color: #f1f1f1; border: 2px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px; position: relative;" title="Selection Tool (S)">
<svg style="width: 100%; height: 100%;" viewbox="0 0 24 24">
<path d="M3,5h2V3C3,3,3,5,3,5z M7,3v2h2V3H7z M11,3v2h2V3H11z M15,3v2h2V3H15z M19,3v2h2V3H19z M3,9h2V7H3V9z M19,7v2h2V7H19z M3,13h2 v-2H3V13z M19,11v2h2v-2H19z M3,17h2v-2H3V17z M19,15v2h2v-2H19z M3,21h2v-2H3V21z M7,21h2v-2H7V21z M11,21h2v-2h-2V21z M15,21h2 v-2h-2V21z M19,21h2v-2h-2V21z" fill="#333"></path>
</svg>
</button>
<!-- Copy (action only) -->
<button class="tool-btn" id="copyBtn" title="Copy selection (Ctrl/Cmd+C)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="#333"/>
  </svg>
</button>
<!-- Paste (action only) -->
<button class="tool-btn" id="pasteBtn" title="Paste (Ctrl/Cmd+V)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <!-- clipboard + plus -->
    <path d="M16 2h-2.18C13.4.84 12.3 0 11 0S8.6.84 8.18 2H6c-1.1 0-2 .9-2 2v16c0 1.11.9 2 2 2h10c1.1 0 2-.89 2-2V4c0-1.1-.9-2-2-2zM11 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1z" fill="#333"/>
    <path d="M12 8v3H9v2h3v3h2v-3h3v-2h-3V8h-2z" fill="#333"/>
  </svg>
</button>
<!-- Eyedropper/Pipette Tool -->
<button class="tool-btn" id="eyedropperTool" style="width: 40px; height: 40px; background-color: #f1f1f1; border: 2px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px; position: relative;" title="Color Picker (E)">
<svg style="width: 100%; height: 100%;" viewbox="0 0 24 24">
<path d="M20.71,5.63l-2.34-2.34c-0.39-0.39-1.02-0.39-1.41,0l-3.12,3.12l-1.93-1.91l-1.41,1.41l1.42,1.42L3,16.25V21h4.75l8.92-8.92 l1.42,1.42l1.41-1.41l-1.92-1.92l3.12-3.12C21.1,6.65,21.1,6.02,20.71,5.63z M6.92,19L5,17.08l8.06-8.06l1.92,1.92L6.92,19z" fill="#333"></path>
</svg>
</button>
<!-- Text Tool -->
<button class="tool-btn" id="textTool" style="width: 40px; height: 40px; background-color: #f1f1f1; border: 2px solid #ccc; border-radius: 4px; cursor: pointer; padding: 2px; position: relative;" title="Text Tool (T)">
<svg style="width: 100%; height: 100%;" viewbox="0 0 24 24">
<rect fill="none" height="20" stroke="#333" stroke-width="2" width="20" x="2" y="2"></rect>
<text dominant-baseline="alphabetic" fill="#333" font-family="Arial" font-size="12" text-anchor="middle" x="12" y="16">T</text>
</svg>
</button>
<button class="tool-btn" id="undoBtn" style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Undo (Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5v-3L7 7l5 5V9c3.31 0 6 2.69 6 6 0 .34-.03.67-.08 1h2.02c.04-.33.06-.66.06-1 0-4.42-3.58-8-8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="redoBtn" style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Redo (Ctrl/Cmd+Y, Shift+Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5V2l5 5-5 5V9c-3.31 0-6 2.69-6 6 0 .34.03.67.08 1H4.06A7.98 7.98 0 0 1 4 15c0-4.42 3.58-8 8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="gridBtn" style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Toggle Grid (G)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M3 3h18v18H3V3zm6 0v18M15 3v18M3 9h18M3 15h18" fill="none" stroke="#333" stroke-width="2"></path>
</svg>
</button>
<!-- Lasso Tool -->
<button class="tool-btn" id="lassoTool" title="Lasso (L)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M4,12c0-4,4-7,8-7s8,3,8,7-4,7-8,7c-1.6,0-3.1-.4-4.4-1.1l-2.6,1 1.2-2.4C4.7,15.2,4,13.7,4,12z" fill="#333"/>
  </svg>
</button>

<!-- Rotate Right 90¬∞ -->
<button class="tool-btn" id="rotateRightBtn" title="Rotate +90¬∞ (R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M15.55 5.55L11 1v3.07C6.05 4.56 2.5 8.54 2.5 13.5 2.5 18.47 6.53 22.5 11.5 22.5S20.5 18.47 20.5 13.5h-2
             c0 3.86-3.14 7-7 7s-7-3.14-7-7c0-3.58 2.65-6.53 6.1-6.96V9l4.45-3.45z" fill="#333"></path>
  </svg>
</button>

<!-- Rotate Left 90¬∞ -->
<button class="tool-btn" id="rotateLeftBtn" title="Rotate -90¬∞ (Shift+R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M8.45 5.55L13 1v3.07C17.95 4.56 21.5 8.54 21.5 13.5c0 4.97-4.03 9-9 9s-9-4.03-9-9h2
             c0 3.86 3.14 7 7 7s7-3.14 7-7c0-3.58-2.65-6.53-6.1-6.96V9L8.45 5.55z" fill="#333"></path>
  </svg>
</button>

<!-- Flip Horizontal -->
<button class="tool-btn" id="flipHBtn" title="Flip Horizontal (H)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M3 4h8v16H3zM13 4h8v16h-8z" fill="#333"/>
    <path d="M12 4v16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Flip Vertical -->
<button class="tool-btn" id="flipVBtn" title="Flip Vertical (V)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M4 3h16v8H4zM4 13h16v8H4z" fill="#333"/>
    <path d="M4 12h16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Free Rotate -->
<button class="tool-btn" id="rotateFreeBtn" title="Rotate Free‚Ä¶ (Ctrl+R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M12 2a10 10 0 100 20 10 10 0 000-20z" fill="none" stroke="#333" stroke-width="2"/>
    <path d="M12 6v6l4 2" stroke="#333" stroke-width="2" fill="none"/>
  </svg>
</button>




</div>
<!-- Zoom centered in toolbar -->
<div class="zoom-container">
<label for="zoomSlider" id="zoomLabel">Zoom: 100%</label><br/>
<input id="zoomSlider" max="5000" min="10" style="width: 200px;" type="range" value="100"/><br/>
<label for="brushSizeSlider" id="brushSizeLabel">Brush Size: 1px</label><br/>
<input id="brushSizeSlider" max="10" min="1" step="1" style="width: 200px;" type="range" value="1"/>
</div>
<div class="color-palette" style="position: absolute; top: 50px; right: 20px; transform: translateY(-50%); z-index: 100; text-align: center;">
<div class="color-row">
<div class="color-swatch" data-color="black" style="background-color: black; border: 2px solid #fff;"></div>
<div class="color-swatch" data-color="red" style="background-color: red;"></div>
<div class="color-swatch" data-color="blue" style="background-color: blue;"></div>
<div class="color-swatch" data-color="green" style="background-color: green;"></div>
<div class="color-swatch" data-color="yellow" style="background-color: yellow;"></div>
</div>
<div class="color-row">
<div class="color-swatch" data-color="white" style="background-color: white;"></div>
<div class="color-swatch" data-color="purple" style="background-color: purple;"></div>
<div class="color-swatch" data-color="orange" style="background-color: orange;"></div>
<div class="color-swatch" data-color="brown" style="background-color: brown;"></div>
<div class="color-swatch" data-color="cyan" style="background-color: cyan;"></div>

<button id="edit-color-btn" class="tool-btn" type="button" title="Redigera f√§rg üé®">üé®</button>

<div id="color-editor" class="color-pop hidden" role="dialog" aria-modal="true" aria-label="Redigera f√§rg">
  <div class="color-pop-inner">
    <div class="row">
      <canvas id="rainbowCanvas" width="256" height="128"></canvas>
    </div>

    <label class="row" style="gap:.5rem;align-items:center">
      Ljushet
      <input id="lightnessSlider" type="range" min="0" max="100" value="100" />
      <span id="lightnessVal">100%</span>
    </label>

    <div class="row" style="gap:1rem;align-items:center;margin-top:.5rem">
      <div id="colorPreview" class="preview"></div>
      <code id="hexOut" style="font-size:.9rem;opacity:.85">#FFFFFF</code>
      <div style="flex:1"></div>
      <button id="colorCancel" class="btn-secondary" type="button">Avbryt</button>
      <button id="colorApply" class="btn-primary"   type="button">Spara</button>
    </div>
  </div>
</div>

</div>
<!-- NEW: Third row added for checkerboards color swatch -->
<div class="color-row">
<div class="color-swatch" data-color="checkerboard" style="background: repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%);"></div>
<div class="color-swatch" data-color="#c71585" style="background-color: #c71585;"></div>
<div class="color-swatch" data-color="#FF4433" style="background-color: #FF4433;"></div>
<div class="color-swatch" data-color="#9ACD32" style="background-color: #9ACD32;"></div>
<div class="color-swatch" data-color="gray" style="background-color: gray;"></div>
</div>



</div>










<canvas height="10" id="myCanvas" style="border:0px solid black" width="10"></canvas>
<!-- Resize Modal Dialog -->
<div class="modal" id="resizeModal">
<div class="modal-content">
<h3>Resize Canvas</h3>
<div class="form-group">
<label for="canvasWidth">Width (pixels):</label>
<input id="canvasWidth" min="10" type="number"/>
</div>
<div class="form-group">
<label for="canvasHeight">Height (pixels):</label>
<input id="canvasHeight" min="10" type="number"/>
</div>
<div class="button-row">
<button id="cancelResizeBtn">Cancel</button>
<button id="confirmResizeBtn">Resize</button>
</div>
</div>
</div>

<script>
(function(){
  // === Hj√§lpare: f√§rgkonvertering ===
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  function hsv2rgb(h, s, v){
    h = ((h%360)+360)%360; s=clamp(s,0,1); v=clamp(v,0,1);
    const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
    let r=0,g=0,b=0;
    if (h<60){r=c;g=x;} else if (h<120){r=x;g=c;}
    else if (h<180){g=c;b=x;} else if (h<240){g=x;b=c;}
    else if (h<300){r=x;b=c;} else {r=c;b=x;}
    return {r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255)};
  }
  function rgb2hex(r,g,b){
    return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('').toUpperCase();
  }
  function hex2rgb(hex){
    hex = hex.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const num = parseInt(hex,16);
    if (Number.isNaN(num) || hex.length!==6) return null;
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }
  function cssColorToRGB(str){
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.fillStyle = str; // l√•ter browsern parsa
    const d = ctx.fillStyle;
    // d blir i formatet #RRGGBB om det √§r giltigt
    return hex2rgb(d);
  }

  // === DOM-hj√§lpare: hitta aktiv palettknapp ===
  function getActiveSwatch(){
    // Anpassa vid behov: byt selektor om du anv√§nder andra klassnamn/attribut
    const btn = document.querySelector('.color-swatch.active');
    if (!btn) return null;
    // transparensdetekt
    const isTrans = btn.dataset.transparent === '1' ||
                    (btn.dataset.color || '').toLowerCase()==='transparent' ||
                    (getComputedStyle(btn).backgroundColor.includes('rgba(0, 0, 0, 0)'));
    return { el: btn, isTransparent: isTrans };
  }
  
  
  
  function getButtonColor(btn){
    // Prioritera data-color (hex), annars ber√§kna fr√•n computed style
    const data = btn.dataset.color;
    if (data && data !== 'transparent') {
      const rgb = hex2rgb(data) || cssColorToRGB(data);
      if (rgb) return rgb2hex(rgb.r,rgb.g,rgb.b);
    }
    const rgb = cssColorToRGB(getComputedStyle(btn).backgroundColor) || {r:255,g:255,b:255};
    return rgb2hex(rgb.r,rgb.g,rgb.b);
  }
  function setButtonColor(btn, hex){
    btn.dataset.color = hex;
    btn.style.background = hex;
    // ping till din app om du har central f√§rg:
    if (window.setCurrentColor) window.setCurrentColor(hex);
    document.dispatchEvent(new CustomEvent('palette:colorUpdated', {
      detail: { button: btn, color: hex }
    }));
  }

  // === UI-element ===
  const editBtn   = document.getElementById('edit-color-btn');
  const pop       = document.getElementById('color-editor');
  const canvas    = document.getElementById('rainbowCanvas');
  const ctx       = canvas.getContext('2d', { willReadFrequently:true });
  const slider    = document.getElementById('lightnessSlider');
  const sliderVal = document.getElementById('lightnessVal');
  const prevEl    = document.getElementById('colorPreview');
  const hexOut    = document.getElementById('hexOut');
  const btnCancel = document.getElementById('colorCancel');
  const btnApply  = document.getElementById('colorApply');

  // State f√∂r editorn
  let H = 0, S = 1, V = 1;      // Hue [0..360), Sat [0..1], Val [0..1]
  let startHex = '#FFFFFF';
  let targetBtn = null;

  function drawRainbow(){
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    let i = 0;
    for (let y=0;y<h;y++){
      const s = y/(h-1);
      for (let x=0;x<w;x++){
        const hdeg = (x/(w-1))*360;
        const {r,g,b} = hsv2rgb(hdeg, s, V);
        img.data[i++] = r;
        img.data[i++] = g;
        img.data[i++] = b;
        img.data[i++] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    // rita mark√∂r
    const mx = Math.round((H/360) * (w-1));
    const my = Math.round(S * (h-1));
    ctx.beginPath();
    ctx.arc(mx+0.5, my+0.5, 6, 0, Math.PI*2);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.stroke();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
  }

  function updatePreview(){
    const {r,g,b} = hsv2rgb(H, S, V);
    const hex = rgb2hex(r,g,b);
    prevEl.style.background = hex;
    hexOut.textContent = hex;
  }

  function openEditor(){
    const active = getActiveSwatch();
    targetBtn = active ? active.el : null;

    // Hantera transparens: disabla knapp och visa tooltip
    if (!targetBtn || (active && active.isTransparent)) {
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
      return;
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }

    startHex = getButtonColor(targetBtn);

    // Initiera HSV fr√•n startHex (approx: g√• via canvas parse)
    const rgb = hex2rgb(startHex);
    // snabb rgb->hsv:
    (function toHSV(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0, s=max===0?0:d/max, v=max;
      if (d!==0){
        switch(max){
          case r: h=((g-b)/d)+(g<b?6:0); break;
          case g: h=((b-r)/d)+2; break;
          case b: h=((r-g)/d)+4; break;
        }
        h*=60;
      }
      H=h; S=s; V=v;
    })(rgb.r,rgb.g,rgb.b);

    slider.value = Math.round(V*100);
    sliderVal.textContent = slider.value + '%';

    pop.classList.remove('hidden');
    drawRainbow();
    updatePreview();
  }

  function closeEditor(){
    pop.classList.add('hidden');
  }

  // === Events ===
  editBtn?.addEventListener('click', openEditor);
  btnCancel?.addEventListener('click', closeEditor);

  btnApply?.addEventListener('click', ()=>{
    if (!targetBtn) return closeEditor();
    const {r,g,b} = hsv2rgb(H,S,V);
    const hex = rgb2hex(r,g,b);
    setButtonColor(targetBtn, hex);
    closeEditor();
  });

  // V (ljushet)
  slider?.addEventListener('input', ()=>{
    V = Number(slider.value)/100;
    sliderVal.textContent = slider.value + '%';
    drawRainbow();
    updatePreview();
  });

  // Pick i regnb√•gsrutan (H,S)
  function pickAt(evt){
    const rect = canvas.getBoundingClientRect();
    const x = clamp((evt.clientX || (evt.touches?.[0]?.clientX||0)) - rect.left, 0, rect.width-1);
    const y = clamp((evt.clientY || (evt.touches?.[0]?.clientY||0)) - rect.top, 0, rect.height-1);
    const rx = x/rect.width, ry = y/rect.height;
    H = rx * 360;
    S = ry;
    updatePreview();
    drawRainbow();
  }
  let dragging=false;
  canvas?.addEventListener('pointerdown', (e)=>{ dragging=true; canvas.setPointerCapture(e.pointerId); pickAt(e); });
  canvas?.addEventListener('pointermove', (e)=>{ if (dragging) pickAt(e); });
  window.addEventListener('pointerup', ()=>{ dragging=false; });

  // St√§ng p√• Escape/klick utanf√∂r
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeEditor(); });
  document.addEventListener('click', (e)=>{
    if (!pop.classList.contains('hidden') && !pop.contains(e.target) && e.target!==editBtn){
      closeEditor();
    }
  });

  // H√•ll edit-knappen i sync med aktiv palett
  document.addEventListener('click', ()=>{
    const active = getActiveSwatch();
    if (!active || active.isTransparent){
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }
  });

})();
</script>


<script>
            
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
    
            // Create an in-memory canvas to store our drawing
            const drawingCanvas = document.createElement('canvas');
            const drawingCtx = drawingCanvas.getContext('2d');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const eyedropperCanvas = document.createElement('canvas');
            const eyedropperCtx = eyedropperCanvas.getContext('2d');
            
            function updateEyedropperBuffer() {
                eyedropperCanvas.width = Math.floor(drawareax / zoom);
                eyedropperCanvas.height = Math.floor(drawareay / zoom);
                eyedropperCtx.drawImage(drawingCanvas, 0, 0);
            }
            
                        
                        
            const projectImages = [null, null, null];
            let currentproject=0;
            
            
            let undoMap = new Map();
            let redoMap = new Map();


            let undoStack = [];
            let redoStack = [];
       
            let lastPinchDistance = null;
            let canvasPools = new Map();
            
            
            // Function to save the current drawing to the selected project
            function saveCurrentProject(index) {
                
                projectdrawareax[index]=drawareax;
                projectdrawareay[index]=drawareay;
                projectdrawstartx[index]=drawstartx;
                projectdrawstarty[index]=drawstarty;
                projectzoom[index]=zoom;
                
                
                
                const dataURL = drawingCanvas.toDataURL('image/png');
                projectImages[index] = dataURL; // Save the image data URL to the array
                console.log(`Project ${index + 1} saved.`);
            }
            
            // Function to load the selected project image into the drawing canvas
            function loadProject(index) {
                
                
                // Spara stackar f√∂r f√∂reg√•ende bild
    undoMap.set(currentproject, undoStack);
    redoMap.set(currentproject, redoStack);

undoStack = [];
redoStack = [];


    // H√§mta stackar f√∂r nya bilden (eller tomma)
    undoStack = undoMap.get(index) || [];
    redoStack = redoMap.get(index) || [];


                
                
                
                
                
                
                
                
                saveCurrentProject(currentproject);
                currentproject=index;
                
                drawareax=projectdrawareax[index];
                drawareay=projectdrawareay[index];
                drawstartx=projectdrawstartx[index];
                drawstarty=projectdrawstarty[index];
                zoom=projectzoom[index];
                zoomvalue=zoom*100;
                document.getElementById("zoomSlider").value = zoomvalue;
                document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
                
              
                
                if (projectImages[index]) {
                    const img = new Image();
                    img.onload = function() {
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height); // Clear the canvas
                        drawingCtx.drawImage(img, 0, 0); // Draw the saved image
                    };
                    img.src = projectImages[index]; // Set the image source to the saved data URL
                    console.log(`Project ${index + 1} loaded.`);
                } else {
                    console.log(`No project ${index + 1} found.`);
                }
                
            }
            document.getElementById('project1Btn').addEventListener('click', () => loadProject(0));
            document.getElementById('project2Btn').addEventListener('click', () => loadProject(1));
            document.getElementById('project3Btn').addEventListener('click', () => loadProject(2));
            
            document.getElementById('ResizeBtn').addEventListener('click', () => resizecanvas());
            
            
            const resizeModal = document.getElementById('resizeModal');
            const widthInput = document.getElementById('canvasWidth');
            const heightInput = document.getElementById('canvasHeight');
            const confirmResizeBtn = document.getElementById('confirmResizeBtn');
            const cancelResizeBtn = document.getElementById('cancelResizeBtn');
            
            function resizecanvas(){
                
                
                widthInput.value = Math.round(drawareax/zoom) ;
               heightInput.value = Math.round(drawareay/zoom);
               
        
            // Show the modal
             resizeModal.style.display = 'block';
                
            }
            cancelResizeBtn.addEventListener('click', function() {
                resizeModal.style.display = 'none';
            });
      
            // Confirm resize button event
confirmResizeBtn.addEventListener('click', async function() {
    let newWidth = parseInt(widthInput.value);
    let newHeight = parseInt(heightInput.value);

    // Validate dimensions
    
    if (isNaN(newWidth) || newWidth < 1 || isNaN(newHeight) || newHeight < 1 || newWidth>drawingCanvas.width||newHeight>drawingCanvas.height) {
        alert('Invalid dimensions');
        return;
    }

    // Create a snapshot of the current canvas content
    const snapshot = createCanvasSnapshot(drawingCanvas.width, drawingCanvas.height);

    // Create an offscreen canvas for resizing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = newWidth;
    offscreenCanvas.height = newHeight;

    // Draw the snapshot onto the offscreen canvas
    offscreenCtx.drawImage(snapshot, 0, 0, drawareax/zoom,drawareay/zoom, 0, 0, newWidth, newHeight);

    // Clear the drawing context
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    disableSmoothing(drawingCtx);

    // Draw the resized image onto the main canvas
    drawingCtx.drawImage(offscreenCanvas, 0, 0);

    // Update drawing area dimensions
     

                    // Reset zoom to 1 after resizing
                    let newZoom = zoom; // Start with current zoom
                    if (newWidth * newZoom > window.innerWidth * 0.8 || 
                        newHeight * newZoom > (window.innerHeight - 100) * 0.8) {
                        // Image is too large at current zoom, recalculate
                        const zoomX = Math.round(((window.innerWidth * 0.8) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.8) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                    }
                    else if(((newWidth * newZoom < window.innerWidth * 0.5 ||newHeight * newZoom < (window.innerHeight - 100) * 0.5 ))){
                        
     
                        const zoomX = Math.round(((window.innerWidth * 0.5) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.5) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                        
                        
                        
                    }
                    
                    
                    zoom = newZoom;
                    zoomvalue = Math.round(newZoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";

    // Center the drawing area
    drawareax = newWidth*zoom; 
    drawareay = newHeight*zoom;
    
    drawstartx = (canvas.width / devicePixelRatio - drawareax) / 2;
    drawstarty = (canvas.height / devicePixelRatio - drawareay) / 2;

    // Close the modal
    resizeModal.style.display = 'none';
});
            function createCanvasSnapshot(width,height) {
                const offscreen = document.createElement('canvas');
                offscreen.width = width;
                offscreen.height = height;
                const offCtx = offscreen.getContext('2d');
                disableSmoothing(offCtx);
                
                offCtx.drawImage(drawingCanvas, 0, 0,width,height);
                return offscreen;
            }

            
            
            
            
              document.addEventListener('DOMContentLoaded', function() {
            // Get all color swatches
            const swatches = document.querySelectorAll('.color-swatch');

            // Add click event handlers
            swatches.forEach(swatch => {
            swatch.addEventListener('click', function() {
              swatches.forEach(s => s.classList.remove('active'));
              this.classList.add('active');
              brushColor = this.getAttribute('data-color');
              isTransparentBrush = brushColor === "checkerboard";
            });
          });

            // Set black as the initial active color
            const blackSwatch = document.querySelector('[data-color="black"]');
            if (blackSwatch) {
              blackSwatch.classList.add('active');
            }
          });
            document.addEventListener('DOMContentLoaded', function() {
                // Adjust color palette position for mobile
                function adjustColorPalettePosition() {
                  const colorPalette = document.querySelector('.color-palette');
                  if (colorPalette) {
                    if (mobileAndTabletCheck()) {
                      colorPalette.style.top = '0px'; // 8px lower for mobile
                      colorPalette.style.transform = 'none'; // Remove vertical centering transform
                    } else {
                      colorPalette.style.top = '50px'; // Original position for desktop
                      colorPalette.style.transform = 'translateY(-50%)'; // Original transform
                    }
                  }
                }

                // Call initially
                adjustColorPalettePosition();

                // Also call when window is resized
                window.addEventListener('resize', adjustColorPalettePosition);
              });
            
            function mobileAndTabletCheck() {
               const isMobile = {
                    Android: function() {
                        return navigator.userAgent.match(/Android/i);
                    },
                    BlackBerry: function() {
                        return navigator.userAgent.match(/BlackBerry/i);
                    },
                    iOS: function() {
                        return navigator.userAgent.match(/iPhone|iPod/i);
                    },
                    Opera: function() {
                        return navigator.userAgent.match(/Opera Mini/i);
                    },
                    Windows: function() {
                        return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
                    },
                    any: function() {
                        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));
                    }
                };
           
                return isMobile.any();
            }
            function quantizeValue(value, quantum) {
    return Math.round(value / quantum) * quantum;
}
            // Function to return scrollbar thickness based on mobile status
            function getScrollbarThickness() {
                return mobileAndTabletCheck() ? 60 : 30;
            }
            
            if(mobileAndTabletCheck()){
 
                drawingCanvas.width = 4000;
                drawingCanvas.height = 4000;
                tempCanvas.width = 4000;
                tempCanvas.height = 4000;
                
                
            }
            else{
                drawingCanvas.width = 10000;
                drawingCanvas.height = 10000;
                tempCanvas.width = 10000;
                tempCanvas.height = 10000;
            }
            
            // Fill the drawing canvas with white initially
            drawingCtx.fillStyle = "white";
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // Disable image smoothing for crisp pixels
            function disableSmoothing(context) {
                context.imageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.msImageSmoothingEnabled = false;
            }
            
            disableSmoothing(ctx);
            disableSmoothing(drawingCtx);
            disableSmoothing(tempCtx);
    
            let drawareax = 640;
            let drawareay = 640;
            let drawstartx = 1000;
            let drawstarty = 1000;
            let startan = false;
            
            let movecorners1 = false;
            let movecorners2 = false;
            let movecorners3 = false;
            let movecorners4 = false;
            let movescrollx = false;
            let movescrollxvalue = 0;
            let savescrollxvalue = 0;
            let isposetive = false;
            let isdirposetive = 0;
            let x = 0;
            let y = 0;
            let zoomvalue = 100;
            let zoom = 1;
            let scrollx = 0;
            let scrolly = 0;
            let movescrollyvalue = 0;
            let movescrolly = false;
            let savescrollyvalue = 0;
            
            let isposetivey = false;
            let isdirposetivey = 0;
            
            // Variables for drawing
            let isDrawing = false;
            let brushSize = 1; // Default brush size
            let brushColor = "black"; // Default brush color
            
            // Function to draw at a specific point with pixel perfect precision
            let lastX = 0;
            let lastY = 0;
            
            // Variables to track drag start position
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Original content area in pixel units (not screen units)
            let originalContentX = 0;
            let originalContentY = 0;
            let originalContentWidth = drawareax;
            let originalContentHeight = drawareay;
            
            // Constants to address the edge pixel issue
            const EDGE_BUFFER = 2; // Add 2 extra pixels for drawing
            
            // Flag to track if an image has already been loaded
            let firstImageLoaded1 = false;
            let firstImageLoaded2 = false;
            let firstImageLoaded3 = false;
            
            // Track content dimensions for the first image
            let firstImageWidth = 0;
            let firstImageHeight = 0;
            let isImageWaiting = false;   // Image is loaded, waiting for first click
            let isMovingImage = false; 
            
            // **************** NEW VARIABLES FOR IMAGE LAYER ****************
            let currentImage = null;
            let currentImageX = 0;
            let currentImageY = 0;
            let currentImageWidth = 0;
            let currentImageHeight = 0;
            let currentImageOriginalWidth = 0;
            let currentImageOriginalHeight = 0;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            // ******************************************************************
            let lastTapTime = 0;
            let lastTapCorner = 0; 
            const doubleTapThreshold = 300; 
            let isTransparentBrush = false;
            let prevDrawAreaX, prevDrawAreaY, prevDrawStartX, prevDrawStartY, prevZoom;
            let currentTool = 'pen';      // Default tool
            let isSelecting = false;      // Track selection state
            let selectionStartX = 0;      // Selection coordinates
            let selectionStartY = 0;
            let selectionEndX = 0;
            let selectionEndY = 0;
            let selectionNeedsClick = false; 
            let isInteractingWithToolbar = false;
            
            let projectdrawareax = [drawareax, drawareax, drawareax];
            let projectdrawareay = [drawareay, drawareay, drawareay];
            let projectdrawstartx = [drawstartx, drawstartx, drawstartx];
            let projectdrawstarty = [drawstarty, drawstarty, drawstarty];
            let projectzoom = [zoomvalue, zoomvalue, zoomvalue];
            
            
            let prevzoom=1;
            let selLeft = 0;
            let selTop =0;
            let selWidth = 0;
            let selHeight =0;
            let isTextToolActive = false;
            let currentImagecanvas=currentproject;
            let showGrid = false;
            // Event listener for zoom slider
            document.getElementById("zoomSlider").addEventListener("input", (e) => {
                e.preventDefault();
                zoomvalue = Number(e.target.value);
                document.getElementById("zoomLabel").innerText = "Zoom: " + e.target.value + "%";
            });
            
            // Event listener for brush size slider
            document.getElementById("brushSizeSlider").addEventListener("input", (e) => {
                e.preventDefault();
                const sliderVal = Number(e.target.value);
                brushSize = sliderVal * sliderVal;
                document.getElementById("brushSizeLabel").innerText = "Brush Size: " + brushSize + "px";
            });
            
            const toolButtons = document.querySelectorAll('.tool-btn');

// Add pointer event listeners to each tool button
toolButtons.forEach(button => {
    button.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});

// Get the save and open buttons
const saveBtn = document.getElementById('saveImageBtn');
const openLabel = document.querySelector('label[for="directFileInput"]');

// Add pointer event listeners to the save and open buttons
if (saveBtn) {
    saveBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

if (openLabel) {
    openLabel.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

// Get all color swatches
const colorSwatches = document.querySelectorAll('.color-swatch');

// Add pointer event listeners to each color swatch
colorSwatches.forEach(swatch => {
    swatch.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});
            
            
            
            function applyCanvasTransform(shouldRound) {
                // Create stable integer positions for drawing
                let renderX = Math.floor(drawstartx);
                let renderY = Math.floor(drawstarty);
                let renderW = Math.ceil(drawareax);
                let renderH = Math.ceil(drawareay);

                // Calculate display dimensions precisely
                const displayWidth = Math.floor(renderW / zoom);
                const displayHeight = Math.floor(renderH / zoom);

                // Draw using transformation matrix
                ctx.save();
                ctx.translate(renderX, renderY);
                ctx.scale(zoom, zoom);
                ctx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0, 0, displayWidth, displayHeight);
                ctx.restore();

                return { displayWidth, displayHeight, renderX, renderY, renderW, renderH };
            }
function floodFill(startX, startY) {
    console.log("Filling at", startX, startY);

    if (startX < 0 || startY < 0 ||
        startX >= drawingCanvas.width ||
        startY >= drawingCanvas.height) {
        return;
    }

    const targetData = drawingCtx.getImageData(startX, startY, 1, 1).data;
    const targetR = targetData[0];
    const targetG = targetData[1];
    const targetB = targetData[2];
    const targetA = targetData[3];

    let fillR = 0, fillG = 0, fillB = 0, fillA = 255;
    if (brushColor === "checkerboard") {
        fillR = fillG = fillB = 0;
        fillA = 1;
    } else if (brushColor.startsWith('#')) {
        fillR = parseInt(brushColor.slice(1, 3), 16);
        fillG = parseInt(brushColor.slice(3, 5), 16);
        fillB = parseInt(brushColor.slice(5, 7), 16);
    } else {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = brushColor;
        tempCtx.fillRect(0, 0, 1, 1);
        const fillData = tempCtx.getImageData(0, 0, 1, 1).data;
        fillR = fillData[0];
        fillG = fillData[1];
        fillB = fillData[2];
        fillA = fillData[3];
    }

    // Undvik att fylla om f√§rgen redan √§r samma
    const tolerance = 10;
    if (Math.abs(targetR - fillR) <= 2 &&
        Math.abs(targetG - fillG) <= 2 &&
        Math.abs(targetB - fillB) <= 2 &&
        Math.abs(targetA - fillA) <= 2) {
        return;
    }

    const chunkSize = 1024;
    const chunkX = Math.max(0, startX - chunkSize / 2);
    const chunkY = Math.max(0, startY - chunkSize / 2);
    const chunkWidth = Math.min(chunkSize, drawingCanvas.width - chunkX);
    const chunkHeight = Math.min(chunkSize, drawingCanvas.height - chunkY);

    const imageData = drawingCtx.getImageData(chunkX, chunkY, chunkWidth, chunkHeight);
    const data = imageData.data;

    const visited = new Uint8Array(chunkWidth * chunkHeight);
    const maxStack = chunkWidth * chunkHeight * 2;
    const stack = new Uint32Array(maxStack);
    let stackLen = 0;

    const localX = startX - chunkX;
    const localY = startY - chunkY;

    stack[stackLen++] = localX;
    stack[stackLen++] = localY;

    function matchesTarget(x, y) {
        const idx = (y * chunkWidth + x) * 4;
        return (
            Math.abs(data[idx]     - targetR) <= tolerance &&
            Math.abs(data[idx + 1] - targetG) <= tolerance &&
            Math.abs(data[idx + 2] - targetB) <= tolerance &&
            Math.abs(data[idx + 3] - targetA) <= tolerance
        );
    }

    function setPixel(x, y) {
        const idx = (y * chunkWidth + x) * 4;
        data[idx]     = fillR;
        data[idx + 1] = fillG;
        data[idx + 2] = fillB;
        data[idx + 3] = fillA;
        visited[y * chunkWidth + x] = 1;
    }

    console.time("Fill");

    while (stackLen > 0) {
        const y = stack[--stackLen];
        const x = stack[--stackLen];

        if (x < 0 || y < 0 || x >= chunkWidth || y >= chunkHeight) continue;
        if (visited[y * chunkWidth + x]) continue;
        if (!matchesTarget(x, y)) continue;

        setPixel(x, y);

        stack[stackLen++] = x - 1; stack[stackLen++] = y;
        stack[stackLen++] = x + 1; stack[stackLen++] = y;
        stack[stackLen++] = x;     stack[stackLen++] = y - 1;
        stack[stackLen++] = x;     stack[stackLen++] = y + 1;
    }

    console.timeEnd("Fill");

    const offscreen = document.createElement('canvas');
    offscreen.width = chunkWidth;
    offscreen.height = chunkHeight;
    const offCtx = offscreen.getContext('2d');
    offCtx.putImageData(imageData, 0, 0);

    drawingCtx.clearRect(chunkX, chunkY, chunkWidth, chunkHeight);
    drawingCtx.drawImage(offscreen, chunkX, chunkY);
}

// Helper function to get pixel color
function getPixelColor(x, y) {
    if (x < 0 || y < 0 || x >= drawingCanvas.width || y >= drawingCanvas.height) {
        return 'rgba(0,0,0,0)';
    }
    
    const data = drawingCtx.getImageData(x, y, 1, 1).data;
    return `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;
}
function drawText(x, y, text) {
    
    const relativeX = Math.floor((x - drawstartx) / zoom );
    const relativeY = Math.floor((y - drawstarty) / zoom );
    
    const fontSize = brushSize*5 + 10; // Brush size + 10 for font size
    drawingCtx.font = `${fontSize}px Arial`;
    drawingCtx.fillStyle = brushColor; // Use the current brush color
    drawingCtx.fillText(text, relativeX, relativeY); // Draw the text at the specified coordinates
}


function roundToFullPixels(value) {
    return Math.round(value);
}

// Helper to check if two colors match
function colorsMatch(colorData, cssColor) {
    // Parse CSS color
    let targetR, targetG, targetB, targetA;
    
    if (cssColor.startsWith('rgba')) {
        const parts = cssColor.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = Math.round(parseFloat(parts[4]) * 255);
    } else if (cssColor.startsWith('rgb')) {
        const parts = cssColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = 255;
    } else {
        // For other formats, we need a different approach
        return false;
    }
    
    // Compare with small tolerance for floating point errors
    return Math.abs(colorData[0] - targetR) <= 2 && 
           Math.abs(colorData[1] - targetG) <= 2 && 
           Math.abs(colorData[2] - targetB) <= 2 && 
           Math.abs(colorData[3] - targetA) <= 2;
}

// Helper to set pixel color in ImageData
function setPixelInImageData(imageData, x, y, color) {
    const idx = (y * imageData.width + x) * 4;
    
    // Handle different color formats
    if (color.startsWith('#')) {
        // Hex color
        imageData.data[idx] = parseInt(color.substring(1, 3), 16);
        imageData.data[idx + 1] = parseInt(color.substring(3, 5), 16);
        imageData.data[idx + 2] = parseInt(color.substring(5, 7), 16);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else if (color.startsWith('rgba')) {
        // RGBA color
        const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = Math.round(parseFloat(parts[4]) * 255);
    } else if (color.startsWith('rgb')) {
        // RGB color
        const parts = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else {
        // Named colors or other formats
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = color;
        tempCtx.fillRect(0, 0, 1, 1);
        const colorData = tempCtx.getImageData(0, 0, 1, 1).data;
        
        imageData.data[idx] = colorData[0];
        imageData.data[idx + 1] = colorData[1];
        imageData.data[idx + 2] = colorData[2];
        imageData.data[idx + 3] = colorData[3];
    }
}
function switchTool(newTool, opts = {}) {
  // 1) S√§tt aktivt verktyg
  const prevTool = window.currentTool;
  window.currentTool = newTool;

  // 2) UI-knappar (l√§gg till lasso h√§r!)
  const toolButtons = {
    pen:        document.getElementById('penTool'),
    fill:       document.getElementById('fillTool'),
    select:     document.getElementById('selectTool'),
    eyedropper: document.getElementById('eyedropperTool'),
    text:       document.getElementById('textTool'),
    lasso:      document.getElementById('lassoTool') // ‚Üê NY
  };

  Object.keys(toolButtons).forEach(tool => {
    const btn = toolButtons[tool];
    if (!btn) return;
    if (tool === window.currentTool) {
      btn.style.backgroundColor = '#d4ffd4';
      btn.style.borderColor = '#4CAF50';
    } else {
      btn.style.backgroundColor = '#f1f1f1';
      btn.style.borderColor = '#ccc';
    }
  });

  // 3) Avsluta p√•g√•ende lasso-drag n√§r vi l√§mnar lasso-verktyget
  if (newTool !== 'lasso') {
    if (typeof isLassoActive !== 'undefined') isLassoActive = false;
    // Rensa markering helt bara om man vill
    if (opts.clearSelection === true && typeof clearSelection === 'function') {
      clearSelection();
    }
  }

  // (valfritt) logg
  // console.log("Switched to tool:", newTool, "from", prevTool);
}        
            // Ensure the drawing canvas is big enough for the image
            function ensureCanvasSize(width, height) {
                // Resize the drawing canvas if the new dimensions are larger
                if (width > drawingCanvas.width || height > drawingCanvas.height) {
                    // Save current content
                    const oldContent = document.createElement('canvas');
                    oldContent.width = drawingCanvas.width;
                    oldContent.height = drawingCanvas.height;
                    const oldCtx = oldContent.getContext('2d');
                    oldCtx.drawImage(drawingCanvas, 0, 0);

                    // Resize the canvas
                    drawingCanvas.width = Math.max(width, drawingCanvas.width);
                    drawingCanvas.height = Math.max(height, drawingCanvas.height);

                    // Fill with white and restore content
                    drawingCtx.fillStyle = "white";
                    drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    drawingCtx.drawImage(oldContent, 0, 0);

                    // Ensure smooth rendering is disabled
                    disableSmoothing(drawingCtx);

                    // Also resize temp canvas
                    tempCanvas.width = drawingCanvas.width;
                    tempCanvas.height = drawingCanvas.height;
                    disableSmoothing(tempCtx);

                    console.log(`Canvas resized to ${drawingCanvas.width}x${drawingCanvas.height}`);
                }
            }
            
            // Event listener for image open button
     
     
            function drawBresenhamLine(x0, y0, x1, y1, size) {
                x0 = Math.floor(x0);
                y0 = Math.floor(y0);
                x1 = Math.floor(x1);
                y1 = Math.floor(y1);

                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = (x0 < x1) ? 1 : -1;
                const sy = (y0 < y1) ? 1 : -1;
                let err = dx - dy;

                const halfSize = Math.floor(size / 2);

                while (true) {
                    // Simplified: just draw one rectangle at each point
                    if (isTransparentBrush) {
                        drawingCtx.clearRect(x0 - halfSize, y0 - halfSize, size, size);
                    } else {
                        drawingCtx.fillRect(x0 - halfSize, y0 - halfSize, size, size);
                    }

                    if (x0 === x1 && y0 === y1) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x0 += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }
            function ensureIntDimension(value) {
                // Add a tiny bias (0.001) to prevent rounding down due to floating point errors
                return Math.round(value + 0.001);
            }
            
            
            // IMPROVED: Make sure we have accurate mouse coordinates
            function getCanvasMousePosition(event) {
                const rect = canvas.getBoundingClientRect();
               // const devicePixelRatio = window.devicePixelRatio || 1;
                
                // Calculate scales including the device pixel ratio
              //  const scaleX = canvas.width / (rect.width * devicePixelRatio);
             //   const scaleY = canvas.height / (rect.height * devicePixelRatio);
                
                // Get mouse coordinates relative to the canvas
               // const clientX = event.clientX - rect.left;
              //  const clientY = event.clientY - rect.top;
               
                return {
                 //   x: clientX * (canvas.width / rect.width),
                 //   y: clientY * (canvas.height / rect.height)
                    
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }
            
            
         
    
            
            
            // IMPROVED: More accurate pixel drawing
            function drawPixel(x, y) {
                const relativeX = Math.floor((x - drawstartx) / zoom );
                const relativeY = Math.floor((y - drawstarty) / zoom );

                // Set the brush color
                if (!isTransparentBrush) {
                    drawingCtx.fillStyle = brushColor;
                }

                if (x >= drawstartx && x < drawstartx + drawareax &&
                    y >= drawstarty && y < drawstarty + drawareay) {

                    if(lastX === 0 && lastY === 0) {
                        lastX = relativeX; 
                        lastY = relativeY;

                        const halfSize = Math.floor(brushSize / 2);
                        if (isTransparentBrush) {
                            drawingCtx.clearRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        } else {
                            drawingCtx.fillRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        }
                    } else {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                        lastX = relativeX;
                        lastY = relativeY;
                    }
                } else {
                    if(lastX !== 0 && lastY !== 0) {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                    }
                    lastX = relativeX;
                    lastY = relativeY;
                }
            }
            
            // Initialize canvas size properly
            function resizeCanvas() {
                const devicePixelRatio = window.devicePixelRatio || 1;
                
                // Set the canvas size to match the display size
                canvas.width = window.innerWidth * devicePixelRatio;
                canvas.height = window.innerHeight * devicePixelRatio;
                
                // Scale the canvas CSS size to match the window
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                
                // Ensure the canvas renders crisply on high DPI displays
                ctx.scale(devicePixelRatio, devicePixelRatio);
                
                disableSmoothing(ctx);
            }
            
            window.addEventListener('resize', (event) => {
                // Store current state before resize
                prevDrawAreaX = drawareax;
                prevDrawAreaY = drawareay;
                prevDrawStartX = drawstartx;
                prevDrawStartY = drawstarty;
                prevZoom = zoom;

                // Update canvas size
                const oldDevicePixelRatio = window.devicePixelRatio || 1;
                resizeCanvas();

                // Preserve drawing content by copying to temporary canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(drawingCanvas, 0, 0);

                // CRITICAL: Do not change the drawing area dimensions during resize!
                // Just maintain position based on window size change
                const deltaWidth = window.innerWidth - (canvas.width / oldDevicePixelRatio);
                const deltaHeight = window.innerHeight - (canvas.height / oldDevicePixelRatio);

                // Maintain the same relative position
                if (drawareax > canvas.width|| drawareay > canvas.height) { // If zoomed in
                    // Do nothing to the dimensions - keep them exactly as they were
                    drawareax = prevDrawAreaX;
                    drawareay = prevDrawAreaY;

                    // Keep the canvas in the same relative position
                    drawstartx = prevDrawStartX;
                    drawstarty = prevDrawStartY;
                } else {
                    // Not zoomed in - center the canvas
                    const toolbarHeight = 155;
                    drawstartx = (window.innerWidth / 2) - (drawareax / 2);
                    drawstarty = Math.max(toolbarHeight, (window.innerHeight / 2) - (drawareay / 2));
                    movescrollxvalue = 0;
                    scrollx = 0;
                    movescrollyvalue = 0;
                    scrolly = 0;
                }

                // Restore drawing content
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.fillStyle = "white";
                drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.drawImage(tempCanvas, 0, 0);

                // Reset background
                ctx.fillStyle = "lightgray";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);

                startan = true;
            });
            //NYTT----------------------------------------------------------------------------------
            // ======== LASSO + TRANSFORM STATE ========
let lassoPoints = [];
let isLassoActive = false;
let hasSelection = false;
let selectionBBox = null;         // {x,y,w,h} i canvas-pixelkoordinater (inte sk√§rm)
let selectionPath = null;         // Path2D f√∂r klippning
let selectionMaskCanvas = null;   // mask av markerat omr√•de
let selectionImageCanvas = null;  // utdraget pixelinneh√•ll f√∂r transform
let selectionPathCanvas = null; // overlay-path i sk√§rm-koordinater
let selectionPathImg = null; 
let selectionOrigBBox = null;
let selSessionActive = false;
let selectionSrcCanvas = null;   // immutabel k√§lla (originalpixlar)
let selectionHoleBBox = null;    // var originalet satt (rekt eller lasso-bbox)
let selectionHoleCut  = false;   // har vi skurit h√•let i basen √§n?


function clearSelection() {
  hasSelection = false;
  isLassoActive = false;
  selectionBBox = null;
  selectionPathCanvas = null;  // om du anv√§nder den
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
  selectionOrigBBox = null;
}

function _effectiveZoom(){ return (zoom > 10) ? (zoom/100) : zoom; }
function _canvasXYtoImageXY(cx, cy){
  const z=_effectiveZoom();
  return { x: Math.floor((cx - drawstartx)/z), y: Math.floor((cy - drawstarty)/z) };
}
function _eraseSelectionAt(ix, iy){
  if (!selectionMaskCanvas) return;
  drawingCtx.save();
  drawingCtx.translate(ix, iy);
  drawingCtx.globalCompositeOperation = 'destination-out';
  drawingCtx.drawImage(selectionMaskCanvas, 0, 0);
  drawingCtx.restore();
  drawingCtx.globalCompositeOperation = 'source-over';
}

// Bygg en mask (svart) fr√•n alphat i selectionImageCanvas
function _rebuildMaskFromImageCanvas(){
  if (!selectionImageCanvas) return;
  const w = selectionImageCanvas.width;
  const h = selectionImageCanvas.height;
  const m = document.createElement('canvas');
  m.width = w; m.height = h;
  const mctx = m.getContext('2d'); disableSmoothing(mctx);

  // L√§gg in bilden, l√•t alpha styra var masken finns
  mctx.drawImage(selectionImageCanvas, 0, 0);
  mctx.globalCompositeOperation = 'source-in';
  mctx.fillStyle = '#000';           // mask = svart d√§r alpha > 0
  mctx.fillRect(0,0,w,h);
  mctx.globalCompositeOperation = 'source-over';
  _binarizeAndDilateMask(m, 1); // ‚Üê NYTT
  selectionMaskCanvas = m;
}

function _imageXYtoCanvasXY(ix, iy) {
  const z = _effectiveZoom();
  const x = drawstartx + ix * z;
  const y = drawstarty + iy * z;
  return {x, y};
}

function _mkPathFromPoints(pts) {
  const p = new Path2D();
  if (!pts.length) return p;
  p.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<pts.length;i++) p.lineTo(pts[i].x, pts[i].y);
  p.closePath();
  return p;
}

function _computeBBoxFromImagePts(ptsImg) {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const p of ptsImg) {
    if (p.x<minX) minX=p.x;
    if (p.y<minY) minY=p.y;
    if (p.x>maxX) maxX=p.x;
    if (p.y>maxY) maxY=p.y;
  }
  const x=minX, y=minY, w=Math.max(1, maxX-minX+1), h=Math.max(1, maxY-minY+1);
  return {x, y, w, h};
}

// Ritar lasso-overlay (p√• huvud-ctx)
function _drawLassoOverlay() {
  if (!isLassoActive || lassoPoints.length < 2) return;
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4,3]);
  ctx.beginPath();
  const p0 = lassoPoints[0];
  ctx.moveTo(p0.cx, p0.cy);
  for (let i = 1; i < lassoPoints.length; i++) ctx.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  ctx.stroke();
  ctx.restore();
}

// Ta ut markerat omr√•de till selectionImageCanvas + skapa mask
function _extractSelection() {
  if (!selectionBBox || !selectionPathImg) return;
  const { x, y, w, h } = selectionBBox;

  selectionImageCanvas = document.createElement('canvas');
  selectionImageCanvas.width = w;
  selectionImageCanvas.height = h;
  const sctx = selectionImageCanvas.getContext('2d');
  disableSmoothing(sctx);

  selectionMaskCanvas = document.createElement('canvas');
  selectionMaskCanvas.width = w;
  selectionMaskCanvas.height = h;
  const mctx = selectionMaskCanvas.getContext('2d');
  disableSmoothing(mctx);
  

  // Rita mask i bild-koordinater, translaterad s√• (x,y) blir (0,0)
  mctx.save();
  mctx.translate(-x, -y);
  mctx.fillStyle = '#000';
  mctx.fill(selectionPathImg);
  mctx.restore();
  _binarizeAndDilateMask(selectionMaskCanvas, 1);
  // Klipp originalbilden till masken
  sctx.drawImage(drawingCanvas, -x, -y);
  sctx.globalCompositeOperation = 'destination-in';
  sctx.drawImage(selectionMaskCanvas, 0, 0);
  sctx.globalCompositeOperation = 'source-over';
}

// Rensa originalpixlar endast inom masken
function _eraseSelectionFromDrawing() {
  const {x,y,w,h} = selectionBBox;
  drawingCtx.save();
  drawingCtx.translate(x, y);
  // skapa clip fr√•n mask
  const t = drawingCtx;
  t.globalCompositeOperation = 'destination-out';
  t.drawImage(selectionMaskCanvas, 0, 0);
  t.globalCompositeOperation = 'source-over';
  drawingCtx.restore();
}

// Klistra tillbaka (utan transform)
function _pasteSelectionAt(x, y) {
  drawingCtx.drawImage(selectionImageCanvas, x, y);
}

// === TRANSFORMER ===
function rotateSelection(deg) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg * Math.PI) / 180;
    let outW = w, outH = h;
    if (Math.abs(deg % 180) === 90) { outW = h; outH = w; }

    const out = document.createElement('canvas');
    out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();

    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    return; // (commit sker n√§r sessionen avslutas)
  }

  // --- HELA BILDEN ---
  beginAction();  // <-- SAKNADES
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  // rotera dokumentytan (0..w,0..h) till out-canvas
  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  // rita endast dokumentytan (inte hela drawingCanvas)
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  // rensa gamla dokumentytan och skriv in roterade resultatet
  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);

  // uppdatera dokumentm√•tt + centrera vy om storleken √§ndrades
  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    // centrera
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }

  endAction();
}

function flipSelection(axis /* 'h'|'v' */) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox;
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const out = document.createElement('canvas');
    out.width = w; out.height = h;
    const octx = out.getContext('2d'); disableSmoothing(octx);

    const ax = (axis || 'h').toLowerCase();  // <-- normalisera
    octx.save();
    if (ax === 'h') { octx.translate(w, 0); octx.scale(-1, 1); }
    else            { octx.translate(0, h); octx.scale(1, -1); }
    octx.drawImage(selectionImageCanvas, 0, 0);
    octx.restore();

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();
    // bbox of√∂r√§ndrad
    return;
  }

  // --- HELA BILDEN ---
  beginAction(); // <-- SAKNADES
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);

  const ax = (axis || 'h').toLowerCase();
  tctx.save();
  if (ax === 'h') { tctx.translate(w, 0); tctx.scale(-1, 1); }
  else            { tctx.translate(0, h); tctx.scale(1, -1); }
  // rita endast dokumentytan
  tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  tctx.restore();

  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);
  endAction();
}

// Fri rotation med grad-dialog
function rotateSelectionFree() {
  const val = prompt('Rotate degrees (e.g. 20 or -30):', '20');
  const deg = Number(val);
  if (!isFinite(deg)) return;

  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg*Math.PI)/180;
    const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
    const outW = Math.ceil(w*cos + h*sin);
    const outH = Math.ceil(h*cos + w*sin);

    const out = document.createElement('canvas'); out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();

    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    return;
  }

  // --- HELA BILDEN ---
  beginAction(); // <-- SAKNADES
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  // rita endast dokumentytan
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  // rensa gamla dokumentytan och skriv in roterade
  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);

  // uppdatera dokumentm√•tt + centrera vy (viktigt f√∂r fri vinkel)
  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }

  endAction();
}

// ======== TOOL SWITCH HOOKS ========
document.getElementById('lassoTool')?.addEventListener('click', ()=> switchTool('lasso'));
document.getElementById('rotateRightBtn')?.addEventListener('click', ()=> rotateSelection(90));
document.getElementById('rotateLeftBtn')?.addEventListener('click', ()=> rotateSelection(-90));
document.getElementById('flipHBtn')?.addEventListener('click', ()=> flipSelection('h'));
document.getElementById('flipVBtn')?.addEventListener('click', ()=> flipSelection('v'));
document.getElementById('rotateFreeBtn')?.addEventListener('click', ()=> rotateSelectionFree());
const _byId = (id) => document.getElementById(id);

const _copyEl  = _byId('copyBtn');
if (_copyEl) _copyEl.addEventListener('click', () => { copySelectionMobileFriendly(); });

const _pasteEl = _byId('pasteBtn');
if (_pasteEl) _pasteEl.addEventListener('click', () => { pasteFromClipboard(); });

// tangentbordsgenv√§gar: R=+90, Shift+R=-90, H=flipH, V=flipV, L=lasso, Ctrl+R=free
document.addEventListener('keydown', (e)=>{
   const mod = e.ctrlKey || e.metaKey;
   if (mod && e.key.toLowerCase() === 'c') { copySelection(); return; }  
   if (mod && e.key.toLowerCase() === 'v') {pasteFromClipboard();return;}
   if (e.ctrlKey && (e.key==='r' || e.key==='R')) { e.preventDefault(); rotateSelectionFree(); return; }
   if (e.key==='r' || e.key==='R') { e.preventDefault(); rotateSelection( e.shiftKey? -90 : +90 ); return; }
   if (e.key==='h' || e.key==='H') { e.preventDefault(); flipSelection('h'); return; }
   if (e.key==='v' || e.key==='V') { e.preventDefault(); flipSelection('v'); return; }
   if (e.key==='l' || e.key==='L') { e.preventDefault(); switchTool('lasso'); return; }
  
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') {
    if (selSessionActive) {
      commitSelectionSession();  // skriver in urklippet och avslutar
    } else {
      // ingen session: st√§ng bara ev. lasso-skiss/markering
      isLassoActive = false;
      hasSelection = false;
      selectionBBox = null;
      selectionPathCanvas = null;
      selectionPathImg = null;
      selectionImageCanvas = null;
      selectionMaskCanvas = null;
    }
  }
});


// G√∂r switchTool medveten om lasso/selection
const _origSwitchTool = switchTool;
switchTool = function(newTool){
  _origSwitchTool(newTool);
  if (newTool !== 'lasso') {
    isLassoActive = false;
  }
};

let isDraggingSelection = false;
let dragSelX = 0,  dragSelY  = 0;       // aktuell ‚Äúoverlay‚Äù-position i bildpixlar
let dragOffsetIX = 0, dragOffsetIY = 0; // pekarens offset i bbox

let selErasedOnce    = false;           // originalplatsen raderad (en g√•ng)

function startSelectionSession() {
  if (!selSessionActive) {
    if (typeof beginAction === 'function') beginAction(); // snapshot f√∂r undo
    selSessionActive = true;
    selErasedOnce = false;
  }
}

function commitSelectionSession(){
  if (!selSessionActive || !selectionSrcCanvas || !selectionBBox) return;

  // 1) Se till att bara originalh√•let finns:
  if (!selectionHoleCut && selectionHoleBBox){
    _eraseSelectionAt(selectionHoleBBox.x, selectionHoleBBox.y); // lasso-masken styr redan vad som suddas
    selectionHoleCut = true;
  }

  // 2) Baka in *originalpixlarna* i slutl√§get (ingen kvalitetstapp)
  drawingCtx.save();
  if (typeof disableSmoothing==='function') disableSmoothing(drawingCtx);
  drawingCtx.drawImage(
    selectionSrcCanvas,
    0,0, selectionSrcCanvas.width, selectionSrcCanvas.height,
    selectionBBox.x, selectionBBox.y, selectionBBox.w, selectionBBox.h
  );
  drawingCtx.restore();

  // 3) St√§da
  selSessionActive   = false;
  selectionSrcCanvas = null;
  selectionHoleBBox  = null;
  selectionHoleCut   = false;
  // (Beh√•ll selectionBBox/selectionImageCanvas om du vill forts√§tta flytta direkt efter ‚Äì annars clearSelection().)
}

function cancelSelectionSession() {
  if (!selSessionActive) return;
  // √Öterst√§ll canvas om vi raderat original
  if (selErasedOnce && typeof undo === 'function') undo();
  // √•terst√§ll UI-state till startl√§get
  selSessionActive = false;
  selErasedOnce = false;
  isDraggingSelection = false;
  // hoppa tillbaka markeringen till startpunkt
  if (selectionBBox) { selectionBBox.x = dragStartX; selectionBBox.y = dragStartY; }
}
// ======== POINTER-HANTERING F√ñR LASSO ========

let isdragdrag=false;

canvas.addEventListener('pointerdown', (ev)=>{
    isdragdrag=true;
  if (currentTool !== 'lasso') return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig markering ‚Üí starta/mata p√• en flytt-session
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {

    startSelectionSession();

    // Radera originalomr√•det bara f√∂rsta g√•ngen
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);  // g√∂r h√•l en g√•ng
      selErasedOnce = true;
    }

    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }

if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }


  // Annars: b√∂rja NY lasso-kurva
  
  commitSelectionSession();  
    isLassoActive = true;
    hasSelection = false;
    selectionBBox = null;
    selectionPathCanvas = null;
    selectionPathImg = null;
    selectionImageCanvas = null;
    selectionMaskCanvas = null;

    lassoPoints = [];
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  
});

canvas.addEventListener('pointermove', (ev)=>{
  if (currentTool !== 'lasso') return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    let nx = pImg.x - dragOffsetIX;
    let ny = pImg.y - dragOffsetIY;
    //nx = Math.max(0, Math.min(nx, drawingCanvas.width  - selectionBBox.w));
   // ny = Math.max(0, Math.min(ny, drawingCanvas.height - selectionBBox.h));
    dragSelX = nx; dragSelY = ny;
    return;
  }

  if (!isLassoActive) return;
  const last = lassoPoints[lassoPoints.length-1];
  if (!last || last.ix !== pImg.x || last.iy !== pImg.y) {
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  }
});

function _finalizeLasso() {
  if (lassoPoints.length < 3) { isLassoActive = false; return; }

  // 1) Overlay-path i sk√§rm-koordinater (f√∂r att rita ‚Äúmarching ants‚Äù)
  const pCanvas = new Path2D();
  pCanvas.moveTo(lassoPoints[0].cx, lassoPoints[0].cy);
  for (let i = 1; i < lassoPoints.length; i++) pCanvas.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  pCanvas.closePath();
  selectionPathCanvas = pCanvas;

  // 2) Mask-path i bildens pixelkoordinater (detta anv√§nds n√§r vi extraherar pixlar)
  const pImg = new Path2D();
  pImg.moveTo(lassoPoints[0].ix, lassoPoints[0].iy);
  for (let i = 1; i < lassoPoints.length; i++) pImg.lineTo(lassoPoints[i].ix, lassoPoints[i].iy);
  pImg.closePath();
  selectionPathImg = pImg;

  // 3) BBox i bildens pixelkoordinater
  const ptsImg = lassoPoints.map(p => ({ x: p.ix, y: p.iy }));
  const bbox = _computeBBoxFromImagePts(ptsImg);
  selectionBBox = { x: bbox.x, y: bbox.y, w: bbox.w, h: bbox.h };
  selectionOrigBBox = { ...selectionBBox };
  _extractSelection();
  hasSelection = true;
  isLassoActive = false;
    selSessionActive   = true;
    selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
    selectionHoleBBox  = { ...selectionBBox };
    selectionHoleCut   = false;
}

canvas.addEventListener('pointerup', (ev)=>{
    isdragdrag=false;
  if (currentTool !== 'lasso') return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  
  if (typeof isResizingSelection !== 'undefined' && isResizingSelection) return;
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    // flytten ‚Äúg√§ller‚Äù visuellt: uppdatera bbox men skriv inte till canvas √§nnu
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }

  // f√§rdigritad lasso ‚Üí skapa markering + extrakt
  if (lassoPoints.length > 6) _finalizeLasso();
});

// H√∂gerklick = √•ngra drag (√•terst√§ll snapshot)
canvas.addEventListener('contextmenu', (e)=>{
  if (selSessionActive) {
    e.preventDefault();
    cancelSelectionSession();    // √•terst√§ll h√•let och positionen
  }
});

// √§ven dubbelklick ‚Üí st√§ng/avsluta
canvas.addEventListener('dblclick', (ev)=>{
  
  if (currentTool!=='lasso') return;
  commitSelectionSession();      
  clearSelection();
});

canvas.addEventListener("touchstart", tapHandler);

var tapedTwice = false;

function tapHandler(event) {
    if(!tapedTwice) {
        tapedTwice = true;
        setTimeout( function() { tapedTwice = false; }, 300 );
        return false;
    }
    event.preventDefault();
    commitSelectionSession();      
    clearSelection();
 }



canvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  isLassoActive = false;
  if (isDraggingSelection) {
    // Avbryt flytt: bara l√§mna allt som innan drag-start
    isDraggingSelection = false;
    
    // (vi har inte skrivit till drawingCanvas under drag, s√• inget mer beh√∂vs)
  }
}); 
canvas.addEventListener('pointercancel', (ev)=>{
  if (currentTool !== 'lasso') return;
  // Avbryt drag, men rulla inte tillbaka (sessionen lever kvar)
  isDraggingSelection = false;
});
// Tr√∂ska bort halv-alfa ‚Üí 0/255
function _binarizeAlpha(canvas, threshold = 128) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const img = ctx.getImageData(0, 0, w, h);
  const data = img.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i+3] = (data[i+3] >= threshold ? 255 : 0);
  }
  ctx.putImageData(img, 0, 0);
}

// V√§x masken 1 px (mycket enkel 3√ó3-dilation p√• alfa)
// iterationer=1 r√§cker oftast; √∂ka om du fortfarande ser glipor.
function _dilateAlpha(canvas, iterations = 1) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h || iterations <= 0) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  for (let it=0; it<iterations; it++) {
    const src = ctx.getImageData(0, 0, w, h);
    const s = src.data;
    const dst = ctx.createImageData(w, h);
    const d = dst.data;

    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        let on = 0;
        // 8-grannar
        for (let dy=-1; dy<=1; dy++) {
          const yy = y+dy; if (yy<0 || yy>=h) continue;
          for (let dx=-1; dx<=1; dx++) {
            const xx = x+dx; if (xx<0 || xx>=w) continue;
            const ai = ((yy*w + xx) << 2) + 3;
            if (s[ai] >= 128) { on = 1; break; }
          }
          if (on) break;
        }
        const i = ((y*w + x) << 2);
        d[i]   = s[i];
        d[i+1] = s[i+1];
        d[i+2] = s[i+2];
        d[i+3] = on ? 255 : 0; // bara alfa spelar roll f√∂r masken
      }
    }
    ctx.putImageData(dst, 0, 0);
  }
}

// Kombinerad
function _binarizeAndDilateMask(maskCanvas, dilatePx = 1) {
  _binarizeAlpha(maskCanvas, 128);
  if (dilatePx > 0) _dilateAlpha(maskCanvas, dilatePx);
}
let resizeOccurred = false;
// === NYTT: helpers ===
function _effZ(){ return (zoom > 10 ? zoom/100 : zoom); }

// snapshot av dokumentytan (0..docW √ó 0..docH) ‚Äî inte hela drawingCanvas
function _snapshotDocArea(docW, docH){
  const c = document.createElement('canvas');
  c.width = docW; c.height = docH;
  const cctx = c.getContext('2d'); disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0,0, docW,docH, 0,0, docW,docH);
  return c;
}

// rita tillbaka utan f√∂rlust (oavsett riktning)
function blitNoLoss(tempCanvas, newW, newH, dx, dy, bgColor = 'transparent'){
  const oldW = tempCanvas.width, oldH = tempCanvas.height;

  const dstX = (dx>0 ? dx : 0) | 0;
  const dstY = (dy>0 ? dy : 0) | 0;
  const srcX = (dx<0 ? -dx : 0) | 0;
  const srcY = (dy<0 ? -dy : 0) | 0;

  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // 1) clearRect g√∂r ytan helt transparent
  drawingCtx.clearRect(0, 0, Math.max(oldW,newW), Math.max(oldH,newH));

  // 2) Fyll endast om du VILL ha en bakgrundsf√§rg
  if (bgColor && bgColor !== 'transparent') {
    drawingCtx.save();
    drawingCtx.fillStyle = bgColor; // t.ex. '#ffffff'
    drawingCtx.fillRect(0, 0, newW, newH);
    drawingCtx.restore();
  }

  // 3) Kopiera overlap (f√∂rlustfritt)
  if (copyW>0 && copyH>0){
    drawingCtx.drawImage(
      tempCanvas,
      srcX, srcY, copyW, copyH,
      dstX, dstY, copyW, copyH
    );
  }
}

// dx,dy beroende p√• vilket h√∂rn som dras ‚Äî bevara motsatt h√∂rn
function offsetForCorner(corner, oldW, oldH, newW, newH){
  switch((corner||'SE').toUpperCase()){
    case 'NW': return { dx: newW - oldW, dy: newH - oldH }; // botten-h√∂ger fast
    case 'NE': return { dx: 0,            dy: newH - oldH }; // botten-v√§nster fast
    case 'SW': return { dx: newW - oldW,  dy: 0            }; // toppen-h√∂ger fast
    case 'SE':
    default:   return { dx: 0,            dy: 0            }; // toppen-v√§nster fast
  }
}
// === NYTT: resize-session ===
// === state f√∂r resize ===
let rc_active = false;
let rc_corner = 'SE';
let rc_oldW = 0, rc_oldH = 0;     // dokumentm√•tt i bildpixlar
let rc_prevW = 0, rc_prevH = 0;   // preview-m√•tt i bildpixlar
let rc_baseStartX = 0, rc_baseStartY = 0; // drawstart vid start (sk√§rmpixlar)
let rc_snap = null;
let rc_anchorX=0, rc_anchorY=0, rc_anchorSet=false;
let rc_lastSW=0, rc_lastSH=0;

function _effZ(){ return (zoom > 10 ? zoom/100 : zoom); }
function sx2ix(sx){ const z=_effZ(); return Math.round((sx - rc_baseStartX) / z); }
function sy2iy(sy){ const z=_effZ(); return Math.round((sy - rc_baseStartY) / z); }

function _snapshotDocArea(w,h){
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const cctx = c.getContext('2d'); cctx.imageSmoothingEnabled = false;
  cctx.drawImage(drawingCanvas, 0,0, w,h, 0,0, w,h);
  return c;
}

function resizeStart(corner){
  if (rc_active) return;
  const z = _effZ();
  rc_corner = corner.toUpperCase();
  rc_oldW = Math.floor(drawareax / z);
  rc_oldH = Math.floor(drawareay / z);
  rc_prevW = rc_oldW;
  rc_prevH = rc_oldH;
  rc_baseStartX = Math.round(drawstartx);   // <- BASEL√ÑGE
  rc_baseStartY = Math.round(drawstarty);   // <- BASEL√ÑGE
  rc_snap = _snapshotDocArea(rc_oldW, rc_oldH);
  beginAction?.(); // ett undo-steg
  rc_active = true;
}

// Anropar du med canvas-sk√§rmkoordinater (dina x,y):
function resizePreviewFromCanvasXY(sx, sy){
  if (!rc_active) return;
  const W = rc_oldW, H = rc_oldH;
  const imgX = sx2ix(sx);
  const imgY = sy2iy(sy);

  switch(rc_corner){
    case 'SE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, imgY);     break;
    case 'NE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, H - imgY); break;
    case 'SW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, imgY);     break;
    case 'NW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, H - imgY); break;
  }
}

function resizeCommit(){
  if (!rc_active) return;
  const newW = rc_prevW|0, newH = rc_prevH|0;
  const {dx,dy} = offsetForCorner(rc_corner, rc_oldW, rc_oldH, newW, newH);

  blitNoLoss(rc_snap, newW, newH, dx, dy, /* bgColor */ null);

  // uppdatera drawarea (sk√§rmpixlar)
  const z = _effZ();
  drawareax = newW * z;
  drawareay = newH * z;

  // H√•ll valfritt h√∂rn visuellt "fast" genom att flytta drawstart* (f√∂r NW/NE/SW)
  // SE: top-left fast ‚Üí inget att g√∂ra
  if (rc_corner === 'NW' || rc_corner === 'NE') drawstarty += (rc_oldH - newH) * z;
  if (rc_corner === 'NW' || rc_corner === 'SW') drawstartx += (rc_oldW - newW) * z;

  if (typeof endAction === 'function') endAction();
  rc_active = false; rc_snap = null;
}

function resizeCancel(){
  if (!rc_active) return;
  if (typeof undo === 'function') undo(); // backa snapshot-start
  rc_active = false; rc_snap = null;
}
function quantizeToZoomGrid(screenValue, z) {
  // Sn√§pper till n√§rmaste multipel av z (s√• 1 doc-pixel = exakt z sk√§rmpixlar)
  return Math.round(screenValue / z) * z;
}
//funkar lite
function drawResizeOverlay() {
  if (!rc_active) return;

  const z = (zoom > 10 ? zoom/100 : zoom);
  const oldW = rc_oldW, oldH = rc_oldH;
  const newW = rc_prevW|0, newH = rc_prevH|0;

  // ... (beh√•ll din offsetForCorner etc)

  const { dx, dy } = offsetForCorner(rc_corner, oldW, oldH, newW, newH);

  const dstX = (dx > 0 ? dx : 0) | 0;
  const dstY = (dy > 0 ? dy : 0) | 0;
  const srcX = (dx < 0 ? -dx : 0) | 0;
  const srcY = (dy < 0 ? -dy : 0) | 0;
  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // F√∂rhandsvisningens topp-v√§nster i SK√ÑRMpixlar (h√•ll motsatt h√∂rn "fast")
  let previewTLx = drawstartx + ((rc_corner==='NW' || rc_corner==='SW') ? (oldW - newW) * z : 0);
  let previewTLy = drawstarty + ((rc_corner==='NW' || rc_corner==='NE') ? (oldH - newH) * z : 0);

  // === VIKTIGT: kvantisera sk√§rmpixlar till zoom-rutn√§tet ===
  previewTLx = quantizeToZoomGrid(previewTLx, z);
  previewTLy = quantizeToZoomGrid(previewTLy, z);

  // Sk√§rm-rektar (kvantisera √§ven storleken)
  const prevW = quantizeToZoomGrid(newW * z, z);
  const prevH = quantizeToZoomGrid(newH * z, z);

  const docX0 = drawstartx,             docY0 = drawstarty;
  const docX1 = docX0 + quantizeToZoomGrid(oldW * z, z);
  const docY1 = docY0 + quantizeToZoomGrid(oldH * z, z);

  const prevX0 = Math.floor(previewTLx), prevY0 = Math.floor(previewTLy);
  const prevX1 = prevX0 + prevW,         prevY1 = prevY0 + prevH;

  // Destinationspunkt f√∂r snapshot i SK√ÑRMpixlar ‚Üí kvantisera
  const dstXs = quantizeToZoomGrid(prevX0 + dstX * z, z);
  const dstYs = quantizeToZoomGrid(prevY0 + dstY * z, z);
  const drawW = quantizeToZoomGrid(copyW * z, z);
  const drawH = quantizeToZoomGrid(copyH * z, z);

  ctx.save();
  disableSmoothing(ctx);

  // 1) Bakgrund i nya ytan
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(prevX0, prevY0, prevW, prevH);

  // 2) Rita snapshot (endast overlap) p√• kvantiserad plats
  if (rc_snap && copyW > 0 && copyH > 0) {
      ctx.drawImage(
      rc_snap,
      srcX, srcY, copyW, copyH,        // K√ÑLLA: or√∂rd i doc-pixlar
      dstXs,dstYs, drawW, drawH // M√ÖL: kvantiserade sk√§rmpixlar
    );
  }

  // 3) Skugga UTANF√ñR nya ytan
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(docX0, docY0, Math.max(0, prevX0 - docX0), docY1 - docY0);
  ctx.fillRect(Math.min(docX1, prevX1), docY0, Math.max(0, docX1 - prevX1), docY1 - docY0);
  ctx.fillRect(prevX0, docY0, Math.max(0, prevX1 - prevX0), Math.max(0, prevY0 - docY0));
  ctx.fillRect(prevX0, Math.min(docY1, prevY1), Math.max(0, prevX1 - prevX0), Math.max(0, docY1 - prevY1));

  // 4) Ram
  ctx.setLineDash([6,4]);
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.strokeRect(prevX0 + 0.5, prevY0 + 0.5, prevW, prevH);

  ctx.restore();
}
let isRectSelecting = false;

canvas.addEventListener('pointerdown', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig rektangelmarkering ‚Üí b√∂rja flytta (som lasso)
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {

    startSelectionSession();
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);
      selErasedOnce = true;
    }
    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }







if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }






  // Ny rektangel
  commitSelectionSession();
  isRectSelecting = true;
  selectionStartX = selectionEndX = pImg.x;
  selectionStartY = selectionEndY = pImg.y;
  // nolla gamla
  hasSelection = false;
  selectionBBox = null;
  selectionPathCanvas = null;
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
});

canvas.addEventListener('pointermove', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    dragSelX = pImg.x - dragOffsetIX;
    dragSelY = pImg.y - dragOffsetIY;
    return;
  }
  if (isRectSelecting) {
    selectionEndX = pImg.x;
    selectionEndY = pImg.y;
  }
});

function _finalizeRectSelection() {
  const x0 = Math.min(selectionStartX, selectionEndX);
  const y0 = Math.min(selectionStartY, selectionEndY);
  const w  = Math.max(1, Math.abs(selectionEndX - selectionStartX));
  const h  = Math.max(1, Math.abs(selectionEndY - selectionStartY));
  if (w <= 0 || h <= 0) return;

  // Canvas-path (sk√§rm) f√∂r ‚Äúmarching ants‚Äù
  const p0 = _imageXYtoCanvasXY(x0, y0);
  const z  = _effectiveZoom();
  const pCanvas = new Path2D();
  pCanvas.rect(p0.x, p0.y, w*z, h*z);
  selectionPathCanvas = pCanvas;

  // Mask-path i bildkoordinater
  const pImg = new Path2D();
  pImg.rect(x0, y0, w, h);
  selectionPathImg = pImg;

  selectionBBox = { x: x0, y: y0, w, h };
  _extractSelection(); // bygger selectionImageCanvas + mask fr√•n pathen
  hasSelection = true;
  selSessionActive   = true;
  selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
  selectionHoleBBox  = { ...selectionBBox };
  selectionHoleCut   = false;
  
}

canvas.addEventListener('pointerup', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }
  if (isRectSelecting) {
    isRectSelecting = false;
    _finalizeRectSelection();
  }
});

canvas.addEventListener('pointercancel', ()=>{ if (currentTool==='select') { isDraggingSelection=false; isRectSelecting=false; }});
async function copySelection() {
  // V√§lj k√§lla: aktiv selection ‚Üí annars hela dokumentytan
  let srcCanvas = null;

  if (hasSelection && selectionImageCanvas) {
    srcCanvas = selectionImageCanvas;
  } else {
    // Kopiera hela dokumentytan (origo-bilden, inte zoomad)
    const z = _effectiveZoom();
    const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
    tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
    srcCanvas = tmp;
  }

  // F√∂rs√∂k Clipboard API (bild)
  try {
    const blob = await new Promise(res => srcCanvas.toBlob(res, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    console.log('Selection copied to clipboard (image/png).');
  } catch (err) {
    // Fallback: Base64-text
    try {
      await navigator.clipboard.writeText(srcCanvas.toDataURL('image/png'));
      alert('Kopierade som data-URL (fallback).');
    } catch (err2) {
      console.warn('Clipboard copy failed:', err2);
      alert('Kunde inte kopiera till urklipp i den h√§r webbl√§saren.');
    }
  }
}
function _drawSelectOverlay() {
  // Visa bara medan man drar en rektangel i select/copy-l√§ge
  if (!isSelecting || (currentTool !== 'select' && currentTool !== 'copy')) return;

  const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : zoom;

  const left   = drawstartx + Math.min(selectionStartX, selectionEndX) * z;
  const top    = drawstarty + Math.min(selectionStartY, selectionEndY) * z;
  const width  = Math.abs(selectionEndX - selectionStartX) * z;
  const height = Math.abs(selectionEndY - selectionStartY) * z;

  if (width <= 0 || height <= 0) return;

  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4, 3]);          // samma ‚Äúants‚Äù-stil som lasso
  ctx.strokeRect(left, top, width, height);
  ctx.restore();
}
// === Double-click f√∂r SELECT: f√§rdigst√§ll eller commit+clear ===
canvas.addEventListener('dblclick', (ev) => {
  if (currentTool !== 'select') return;
  ev.preventDefault();

  // 1) Om vi h√•ller p√• att rita rektangel ‚Üí f√§rdigst√§ll rutan
  if ((typeof isRectSelecting !== 'undefined' && isRectSelecting) ||
      (typeof isSelecting !== 'undefined' && isSelecting)) {
    if (typeof isRectSelecting !== 'undefined') isRectSelecting = false;
    if (typeof isSelecting !== 'undefined')     isSelecting = false;
    if (typeof _finalizeRectSelection === 'function') _finalizeRectSelection(); // skapar selectionPath/Mask/BBox
    return;
  }

  // 2) Om vi har en aktiv markering/drag-session ‚Üí commit & clear (samma som lasso)
  if ((typeof isDraggingSelection !== 'undefined' && isDraggingSelection) ||
      (typeof selSessionActive !== 'undefined' && selSessionActive) ||
      (typeof hasSelection !== 'undefined' && hasSelection)) {

    // Om vi draggar, baka in drag-positionen i BBox f√∂rst
    if (typeof isDraggingSelection !== 'undefined' && isDraggingSelection) {
      if (typeof selectionBBox !== 'undefined' && selectionBBox) {
        selectionBBox.x = dragSelX;
        selectionBBox.y = dragSelY;
      }
      isDraggingSelection = false;
    }

    if (typeof commitSelectionSession === 'function') commitSelectionSession(); // skriv tillbaka
    if (typeof clearSelection === 'function') clearSelection();                 // rensa ants/overlay
  }
});






async function pasteFromClipboard() {
  try {
    // 1) F√∂rs√∂k modern Clipboard API (bilder)
    if (navigator.clipboard && navigator.clipboard.read) {
      const items = await navigator.clipboard.read();
      for (const item of items) {
        const type = item.types.find(t => t.startsWith('image/'));
        if (type) {
          const blob = await item.getType(type);
          const bmp  = await createImageBitmap(blob);
          _activatePastedBitmap(bmp);
          return;
        }
      }
      // Ingen bild? prova text-dataURL
      const txt = await navigator.clipboard.readText();
      if (txt && txt.startsWith('data:image/')) {
        const bmp = await _bitmapFromDataURL(txt);
        _activatePastedBitmap(bmp);
        return;
      }
      alert('Urklipp inneh√•ller ingen bild.');
      return;
    }

    // 2) Fallback: endast text (data-URL) till√•ts
    if (navigator.clipboard && navigator.clipboard.readText) {
      const txt = await navigator.clipboard.readText();
      if (txt && txt.startsWith('data:image/')) {
        const bmp = await _bitmapFromDataURL(txt);
        _activatePastedBitmap(bmp);
        return;
      }
    }

    alert('Kunde inte l√§sa urklipp (webbl√§sarbegr√§nsning). Prova klistra in via Ctrl/Cmd+V direkt i appen.');
  } catch (err) {
    console.warn('pasteFromClipboard failed:', err);
    alert('Kunde inte l√§sa urklipp. Webbl√§saren kan kr√§va HTTPS/beh√∂righet.');
  }
}

// Hj√§lpare: dataURL -> ImageBitmap
async function _bitmapFromDataURL(dataURL) {
  const res = await fetch(dataURL);
  const blob = await res.blob();
  return await createImageBitmap(blob);
}

// Aktivera som flyttbar markering (ingen direkt m√•lning p√• ritytan)
function _activatePastedBitmap(imgBitmap) {
  // 1) Bygg en canvas av den inklistrade bilden
  const w = imgBitmap.width | 0, h = imgBitmap.height | 0;
  if (!w || !h) return;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);
  cctx.drawImage(imgBitmap, 0, 0);

    // 2) Placera i mitten av vyn (bildkoordinater)
    const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : (window.zoom || 1);

    // R√§tt s√§tt: konvertera canvas-mitten ‚Üí bildkoordinater
    let centerImg;
    if (typeof _canvasXYtoImageXY === 'function') {
      centerImg = _canvasXYtoImageXY(drawareax/2, drawareay/2);
    } else {
      // Fallback om helper saknas: (canvasX - drawstart) / zoom
      centerImg = {
        x: ((drawareax/2) - drawstartx) / z,
        y: ((drawareay/2) - drawstarty) / z
      };
    }

    // Centera bilden kring vymitten
    const cx = Math.max(0, (centerImg.x - w/2) | 0);
    const cy = Math.max(0, (centerImg.y - h/2) | 0);

  // 3) Mata in i selection-systemet
  selectionImageCanvas = c;
  selectionBBox = { x: cx, y: cy, w, h };



  // Bygg mask fr√•n bilden (anv√§nds av transform/erase)
  if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

  // 4) Flagga markering + ‚Äúp√•g√•ende session‚Äù s√• commit ritar in bilden
  hasSelection = true;
  isDraggingSelection = false;
  selSessionActive = true;   // ‚Üê viktigt
  selErasedOnce    = true;   // ‚Üê g√∂r att commitSelectionSession() ritar in bilden

  // 5) Byt till select s√• anv√§ndaren kan dra direkt
  if (typeof currentTool !== 'undefined') currentTool = 'select';

  // 6) Be om en redraw
  if (typeof requestAnimationFrame === 'function') requestAnimationFrame(()=>{});
}
window.addEventListener('paste', async (e) => {
  // F√∂rs√∂k hitta bild
  const cd = e.clipboardData;
  if (!cd) return;
  // 1) Filer (png/jpg/webp) direkt
  if (cd.files && cd.files.length) {
    const file = Array.from(cd.files).find(f => f.type.startsWith('image/'));
    if (file) {
      e.preventDefault();
      const bmp = await createImageBitmap(file);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 2) Items (t.ex. fr√•n Photoshop etc.)
  if (cd.items && cd.items.length) {
    const it = Array.from(cd.items).find(i => i.type && i.type.startsWith('image/'));
    if (it) {
      e.preventDefault();
      const blob = it.getAsFile();
      const bmp = await createImageBitmap(blob);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 3) Text-dataURL
  const txt = cd.getData('text/plain');
  if (txt && txt.startsWith('data:image/')) {
    e.preventDefault();
    const bmp = await _bitmapFromDataURL(txt);
    _activatePastedBitmap(bmp);
  }
});
// === COPY: skriv data-URL till urklipp via copy-event (funkar utan HTTPS) ===
function _buildCopyDataURL() {
  // 1) Direkt fr√•n en redan beskuren canvas
  if (hasSelection && selectionImageCanvas) {
    const c = selectionImageCanvas;
    if (!c || !c.width || !c.height) return ''; // undvik 'data:,'
    return c.toDataURL('image/png');
  }

  // 2) Fr√•n en markeringsruta p√• huvud-canvas
  if (hasSelection && selectionBBox) {
    const { x, y, w, h } = selectionBBox;

    // Klipp till giltigt omr√•de inom drawingCanvas
    const srcW = drawingCanvas.width  | 0;
    const srcH = drawingCanvas.height | 0;
    let sx = Math.max(0, Math.round(x));
    let sy = Math.max(0, Math.round(y));
    let sw = Math.max(0, Math.round(w));
    let sh = Math.max(0, Math.round(h));
    if (sx + sw > srcW) sw = Math.max(0, srcW - sx);
    if (sy + sh > srcH) sh = Math.max(0, srcH - sy);
    // Se till att m√•let inte blir 0√ó0
    const outW = Math.max(1, sw);
    const outH = Math.max(1, sh);

    const c = document.createElement('canvas');
    c.width = outW; c.height = outH;
    const cctx = c.getContext('2d');
    if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

    if (sw > 0 && sh > 0) {
      cctx.drawImage(drawingCanvas, sx, sy, sw, sh, 0, 0, outW, outH);
    } // annars l√§mna transparent

    // OBS: om canvas √§r tainted kan iOS returnera 'data:,'
    return c.toDataURL('image/png');
  }

  // 3) Hela ritytan (justerat f√∂r din zoommodell)
  const z = (!Number.isFinite(zoom) || zoom <= 0)
    ? 1
    : (zoom > 10 ? zoom / 100 : zoom);

  // Anv√§nd round + min 1
  const outW = Math.max(1, Math.round((drawareax || drawingCanvas.width)  / z));
  const outH = Math.max(1, Math.round((drawareay || drawingCanvas.height) / z));

  // Klipp k√§llrektangel inom drawingCanvas
  const srcW = Math.min(outW, drawingCanvas.width);
  const srcH = Math.min(outH, drawingCanvas.height);

  const c = document.createElement('canvas');
  c.width = outW; c.height = outH;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

  cctx.drawImage(drawingCanvas, 0, 0, srcW, srcH, 0, 0, outW, outH);
  return c.toDataURL('image/png');
}

async function _dataURLToBlob(dataURL) {
  const res = await fetch(dataURL);
  return await res.blob();
}

function _fallbackTextareaCopy(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.setAttribute('readonly', '');
  ta.style.position = 'fixed';
  ta.style.top = '0';
  ta.style.left = '0';
  ta.style.opacity = '0';
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  ta.setSelectionRange(0, ta.value.length);
  let ok = false;
  try { ok = document.execCommand('copy'); } catch (_) {}
  document.body.removeChild(ta);
  return ok;
}

function _toast(msg) {
  let box = document.getElementById('toast-box');
  if (!box) {
    box = document.createElement('div');
    box.id = 'toast-box';
    box.style.cssText = `
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:#111; color:#fff; padding:8px 12px; border-radius:10px;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      box-shadow:0 6px 24px rgba(0,0,0,.25); z-index:999999; opacity:0; transition:opacity .2s;
      pointer-events:none;
    `;
    document.body.appendChild(box);
  }
  box.textContent = msg;
  requestAnimationFrame(() => {
    box.style.opacity = '1';
    clearTimeout(box._t);
    box._t = setTimeout(() => { box.style.opacity = '0'; }, 1400);
  });
}

// Huvudfunktionen du anropar fr√•n knappen (m√•ste k√∂ras i user gesture)
function _buildCopyCanvas() {
  // 1) If a floating selection image exists, use that
  if (window.hasSelection && window.selectionImageCanvas) {
    return window.selectionImageCanvas;
  }
  // 2) If we only have a selection bbox, extract that region
  if (window.hasSelection && window.selectionBBox) {
    const { x, y, w, h } = window.selectionBBox;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
    cctx.drawImage(drawingCanvas, x, y, w, h, 0, 0, w, h);
    return c;
  }
  // 3) Fallback: copy the whole visible document area
  const z = (window.zoom > 10 ? window.zoom/100 : window.zoom || 1);
  const w = Math.floor(window.drawareax / z);
  const h = Math.floor(window.drawareay / z);
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  return c;
}

// Replace this function with the version below
function _isCanvasTainted(c) {
  try {
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.getImageData(0, 0, 1, 1); // kastar SecurityError vid taint
    return false;
  } catch (e) {
    return true;
  }
}



// iOS-fallback: kopiera genom att v√§lja ett IMG i en contenteditable
function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.position = 'fixed';
  host.style.left = '-99999px';
  host.style.top = '0';
  host.style.opacity = '0';
  // Viktigt: IMG som faktiskt renderas
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const img = host.firstChild;
  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(img);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch(_) {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.cssText = 'position:fixed;left:-99999px;top:0;opacity:0;';
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(host.firstChild);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

async function copySelectionMobileFriendly() {
  const url = _buildCopyDataURL();
  if (!url || url === 'data:,') { _toast('Inget att kopiera.'); return; }

  // 1) Riktig bild till urklipp ‚Äî iOS/Safari vill ha PROMISE direkt i ClipboardItem
  try {
    if (navigator.clipboard && window.ClipboardItem) {
      const blobPromise = (async () => (await fetch(url)).blob())(); // <- Promise, inte f√§rdig blob
      const item = new ClipboardItem({ 'image/png': blobPromise });
      await navigator.clipboard.write([item]);
      _toast('Kopierat (bild).');
      return;
    }
  } catch (e) {
    console.warn('clipboard.write image failed:', e);
  }

  // 2) iOS-fallback: contenteditable + IMG + execCommand('copy')
  try {
    if (_copyViaEditableIMG(url)) {
      _toast('Kopierat (iOS-fallback).');
      return;
    }
  } catch (e2) {
    console.warn('editable IMG copy failed:', e2);
  }

  // 3) writeText(dataURL)
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(url);
      _toast('Kopierat (text-dataURL).');
      return;
    }
  } catch {}

  // 4) execCommand (textarea)
  if (_fallbackTextareaCopy(url)) { _toast('Kopierat.'); return; }

  // 5) prompt (sista utv√§gen)
  try { window.prompt('Tryck Kopiera:', url); } catch {}
}
//-----NYTT
// ===== BEGIN PATCH: resize-corners state =====
let isResizingSelection = false;
let activeResizeCorner = null;   // 'tl','tr','bl','br'
let resizeAnchorImg = null;      // {x,y} i bild-koordinater (motsatt h√∂rn)
let resizeStartBBox = null;      // snapshot av bbox vid pointerdown
const HANDLE_SIZE_SCR = 12;      // storlek p√• h√∂rn-handtag i sk√§rm-px

// Tr√§ffa h√∂rn i SK√ÑRM-koordinater (mx,my i canvas.getBoundingClientRect()-space)
function _hitTestResizeHandleScreen(mx, my, bbox){
  if (!bbox) return null;
  const tl = _imageXYtoCanvasXY(bbox.x,             bbox.y);
  const tr = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y);
  const bl = _imageXYtoCanvasXY(bbox.x,             bbox.y + bbox.h);
  const br = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y + bbox.h);
  const S  = HANDLE_SIZE_SCR;

  const hits = (p) => (mx >= p.x - S && mx <= p.x + S && my >= p.y - S && my <= p.y + S);
  if (hits(tl)) return 'tl';
  if (hits(tr)) return 'tr';
  if (hits(bl)) return 'bl';
  if (hits(br)) return 'br';
  return null;
}

// Ber√§kna ny bbox fr√•n muspunkt (bild-koordinater) + l√•st ankare
function _bboxFromDragAnchor(currImg, anchorImg){
  const x = Math.min(currImg.x, anchorImg.x);
  const y = Math.min(currImg.y, anchorImg.y);
  const w = Math.max(1, Math.abs(currImg.x - anchorImg.x));
  const h = Math.max(1, Math.abs(currImg.y - anchorImg.y));
  return { x, y, w, h };
}

// Hj√§lp: h√•l i gamla omr√•det och inritning av skalad bild i nya
function _commitSelectionResize(oldBBox, newBBox){
  if (!selSessionActive || !selectionSrcCanvas || !newBBox) return;

  // 1) Uppdatera aktuell bbox
  selectionBBox = { ...newBBox };

  // 2) (valfritt) Bygg om en f√∂rhandsbuffer fr√•n *originalk√§llan*, inte fr√•n basen
  const c = document.createElement('canvas');
  c.width  = Math.max(1, Math.round(newBBox.w));
  c.height = Math.max(1, Math.round(newBBox.h));
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(
    selectionSrcCanvas,
    0,0, selectionSrcCanvas.width, selectionSrcCanvas.height,
    0,0, c.width, c.height
  );
  selectionImageCanvas = c; // f√∂rhandsvisning / overlay
}
// ===== END PATCH: resize-corners state =====
// ===== BEGIN PATCH: pointer listeners for corner resize =====
canvas.addEventListener('pointerdown', (ev) => {
  if (!selectionImageCanvas || !selectionBBox) return;

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (!corner) return;

  ev.preventDefault();
  ev.stopPropagation();

  // Om du har drag-l√§ge f√∂r selection, st√§ng av s√• de inte krockar:
  if (typeof isDraggingSelection !== 'undefined') isDraggingSelection = false;

  activeResizeCorner = corner;
  isResizingSelection = true;
  resizeStartBBox = { ...selectionBBox };

  // Motsatt h√∂rn = ankare (i bild-koordinater)
  let ax, ay;
  if (corner === 'tl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'tr') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'bl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y;                       }
  if (corner === 'br') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y;                       }
  resizeAnchorImg = { x: ax, y: ay };
});

canvas.addEventListener('pointermove', (ev) => {
  // Hover-cursor n√§r inte resizing
  if (!isResizingSelection) {
    if (selectionBBox) {
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
      let cur = 'default';
      if (corner === 'tl' || corner === 'br') cur = 'nwse-resize';
      if (corner === 'tr' || corner === 'bl') cur = 'nesw-resize';
      canvas.style.cursor = cur;
    }
    return;
  }

  // N√§r resizing: uppdatera selectionBBox live (preview)
  if (!resizeAnchorImg) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const mImg = _canvasXYtoImageXY(mx, my); // mus i bild-koordinater

  // (valfritt) beh√•ll aspektf√∂rh√•llande om Shift h√•lls:
  // if (ev.shiftKey) { ...justera mImg.x/mImg.y f√∂r ratio... }

  let newBBox = _bboxFromDragAnchor(mImg, resizeAnchorImg);

  // Kl√§m inom canvas-gr√§nser
  newBBox.x = Math.max(0, Math.min(newBBox.x, drawingCanvas.width  - 1));
  newBBox.y = Math.max(0, Math.min(newBBox.y, drawingCanvas.height - 1));
  newBBox.w = Math.max(1, Math.min(newBBox.w, drawingCanvas.width  - newBBox.x));
  newBBox.h = Math.max(1, Math.min(newBBox.h, drawingCanvas.height - newBBox.y));

  selectionBBox = newBBox; // detta r√§cker f√∂r live-preview eftersom din overlay ritar selectionImageCanvas skalad
  ev.preventDefault();
});

function _endResizeCommit(){
  if (!isResizingSelection) return;
  _commitSelectionResize(resizeStartBBox, selectionBBox);

  isResizingSelection = false;
  activeResizeCorner = null;
  resizeAnchorImg = null;
  resizeStartBBox = null;
}

canvas.addEventListener('pointerup',    _endResizeCommit);
canvas.addEventListener('pointercancel',_endResizeCommit);
canvas.addEventListener('pointerleave', () => {
  // valfritt: commit √§ven n√§r man drar utanf√∂r canvas
  if (isResizingSelection) _endResizeCommit();
});
// ===== END PATCH: pointer listeners for corner resize =====

            //check---------------------------------------------------------------------------------------
            var check = function() {
                
                if(document.querySelector('.color-swatch.active')&&document.querySelector('.color-swatch.active').dataset.color!== brushColor)brushColor=document.querySelector('.color-swatch.active').dataset.color;
                
                // Update canvas size
                if (canvas.width !== window.innerWidth * (window.devicePixelRatio || 1) ||
                    canvas.height !== window.innerHeight * (window.devicePixelRatio || 1)) {
                    resizeCanvas();
                }
                
                let centerX = drawstartx + drawareax / 2;
                let centerY = drawstarty + drawareay / 2;
                drawareax = (drawareax / zoom * (zoomvalue / 100));
                drawareay = (drawareay / zoom * (zoomvalue / 100));
                drawstartx = centerX - drawareax / 2;
                drawstarty = centerY - drawareay / 2;
                zoom = zoomvalue / 100;
                
                if((document.body.clientWidth > 100 && startan == false)) {
                    startan = true;  
                    drawstartx = (canvas.width/devicePixelRatio)/2 - drawareax/2;
                    drawstarty = (canvas.height/devicePixelRatio)/2 - drawareay/2;
                    prevDrawAreaX = drawareax;
                    prevDrawAreaY = drawareay;
                    prevDrawStartX = drawstartx;
                    prevDrawStartY = drawstarty;
                    saveCurrentProject(0);saveCurrentProject(1);saveCurrentProject(2);
                    projectdrawareax = [drawareax, drawareax, drawareax];
                    projectdrawareay = [drawareay, drawareay, drawareay];
                    projectdrawstartx = [drawstartx, drawstartx, drawstartx];
                    projectdrawstarty = [drawstarty, drawstarty, drawstarty];
                    projectzoom = [zoom, zoom, zoom];
                    
                }
                
                
   
                
                // Store the old dimensions before any changes
                const oldDrawStartX = drawstartx;
                const oldDrawStartY = drawstarty;
                const oldDrawAreaX = drawareax;
                const oldDrawAreaY = drawareay;
                
                
                
                
                if (movescrollx == true) {
                    movescrollxvalue = -savescrollxvalue + x + scrollx;
                    if (canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue < 0 && !isposetive) {
                        scrollx = scrollx - movescrollxvalue + canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 - (canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01));
                        movescrollxvalue = canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 - (canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01));
                    }
                    if (canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue > canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) && isposetive) {
                        scrollx = scrollx - movescrollxvalue + canvas.width/devicePixelRatio - ((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01 - (canvas.width/devicePixelRatio/2 - ((((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2));
                        movescrollxvalue = canvas.width/devicePixelRatio - ((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01 - (canvas.width/devicePixelRatio/2 - ((((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2));
                    }
                    drawstartx = -(drawareax/2) - (movescrollxvalue * ((drawareax)/(canvas.width/devicePixelRatio)+(100/drawareax)*canvas.width/devicePixelRatio/20)*1.08) + canvas.width/devicePixelRatio/2;
                }
                
                if (movescrolly == true) {
                    movescrollyvalue = -savescrollyvalue + y + scrolly;
                    if (-50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue < 0 && !isposetivey) {
                        scrolly = 50 + scrolly - movescrollyvalue + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 - (canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                        movescrollyvalue = 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 - (canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                    }
                    if (50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue > canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
                        scrolly = scrolly - movescrollyvalue - 50 + canvas.height/devicePixelRatio - ((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01) - (canvas.height/devicePixelRatio/2 - ((((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01))/2));
                        movescrollyvalue = -50 + canvas.height/devicePixelRatio - ((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01) - (canvas.height/devicePixelRatio/2 - ((((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01))/2));
                    }
                    drawstarty = 50 - (drawareay/2) - (movescrollyvalue * ((drawareay)/(canvas.height/devicePixelRatio)+(100/drawareay)*canvas.height/devicePixelRatio/20)*1.08) + canvas.height/devicePixelRatio/2;
                }
                
                // Draw the document background
                ctx.fillStyle = "lightgray";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
                
 

                const checkerPattern = (function createCheckerPattern() {
                const patternCanvas = document.createElement('canvas');
                const size = 16; // Small pattern size (8px per square)
                patternCanvas.width = size;
                patternCanvas.height = size;
                const patternCtx = patternCanvas.getContext('2d');

                // Create the pattern
                patternCtx.fillStyle = "white";
                patternCtx.fillRect(0, 0, size, size);
                patternCtx.fillStyle = "#cccccc";
                patternCtx.fillRect(0, 0, size/2, size/2);
                patternCtx.fillRect(size/2, size/2, size/2, size/2);

                return patternCanvas;
            })();
                const pattern = ctx.createPattern(checkerPattern, 'repeat');
                ctx.fillStyle = pattern;
                // Use integer coordinates and add 1px buffer to prevent edge artifacts
                const patternX = Math.floor(drawstartx+1);
                const patternY = Math.floor(drawstarty+1);
                const patternWidth = (Math.ceil(drawareax + (drawstartx - patternX)) - 3);
                const patternHeight = (Math.ceil(drawareay + (drawstarty - patternY)) - 3);
                ctx.fillRect(patternX, patternY, patternWidth, patternHeight);


                
                // Calculate how much of the drawing area to display
                //const displayWidth = Math.ceil(drawareax / zoom) + EDGE_BUFFER;
              //  const displayHeight = Math.ceil(drawareay / zoom) + EDGE_BUFFER;

  
                // Draw the content from the drawing canvas to the visible canvas
           
                
                    ctx.save(); // Save the current state
                    ctx.translate(drawstartx, drawstarty); // Move to the top-left corner
                    ctx.scale(zoom, zoom); // Apply zoom scaling
                    const displayWidth = ensureIntDimension(drawareax / zoom);
                    const displayHeight = ensureIntDimension(drawareay / zoom);
                    ctx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0,0,displayWidth, displayHeight);
                    ctx.restore();
            
            
            if (showGrid) {
                    ctx.save();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';

                    for (let gx = 0; gx <= displayWidth; gx++) {
                        const xPix = drawstartx-0.5 + gx * zoom;
                        ctx.beginPath();
                        ctx.moveTo(xPix + 0.5, drawstarty-0.5);
                        ctx.lineTo(xPix + 0.5, drawstarty-0.5 + displayHeight * zoom);
                        ctx.stroke();
                    }

                    for (let gy = 0; gy <= displayHeight; gy++) {
                        const yPix = drawstarty-0.5 + gy * zoom;
                        ctx.beginPath();
                        ctx.moveTo(drawstartx-0.5, yPix + 0.5);
                        ctx.lineTo(drawstartx-0.5 + displayWidth * zoom, yPix + 0.5);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            
            
            
            
            
            
            
            
                // ********** NEW: Draw the image layer overlay if an image is loaded **********
                if(currentImage){
                    // Draw the image
                    
                    currentImageWidth = currentImageOriginalWidth*zoom;;
                    currentImageHeight = currentImageOriginalHeight*zoom;
                    
                    
                    if(prevzoom!=zoom){
                    
                      
                        prevzoom=zoom;
                        currentImageX = (drawstartx + selLeft * zoom);
                        currentImageY = (drawstarty + selTop * zoom);
                         
                    }
                    if(currentImagecanvas!=currentproject){
                        
                        
                        
                        if(currentproject==0&&firstImageLoaded1==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}
                        if(currentproject==1&&firstImageLoaded2==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}
                        if(currentproject==2&&firstImageLoaded3==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}

                        drawstartx = canvas.width/devicePixelRatio/2 - drawareax/2;
                        movescrollxvalue = 0;
                        scrollx = 0;
                        drawstarty = canvas.height/devicePixelRatio/2 - drawareay/2;
                        movescrollyvalue = 0;
                        scrolly = 0;
                        
                        
                        currentImageX = (drawstartx );
                        currentImageY = (drawstarty );
                        
                        currentImagecanvas=currentproject;
                    }
                    
                    
                        
                        
             
                        
                        
                       

                    
                    
                    
                 
           
                    
                    
                    ctx.drawImage(currentImage, currentImageX, currentImageY, currentImageWidth, currentImageHeight);



                    





                    // Draw a green border around the image to indicate it's movable
                    ctx.strokeStyle = "#4CAF50"; // Green color matching the UI
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]); // Dashed line for better visibility
                    ctx.strokeRect(currentImageX, currentImageY, currentImageWidth, currentImageHeight);

                    // Add corner handles for visual clarity
                    const handleSize = 8;
                    ctx.fillStyle = "#4CAF50";
                    // Draw corner handles
                    ctx.fillRect(currentImageX - handleSize/2, currentImageY - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX + currentImageWidth - handleSize/2, currentImageY - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX - handleSize/2, currentImageY + currentImageHeight - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX + currentImageWidth - handleSize/2, currentImageY + currentImageHeight - handleSize/2, handleSize, handleSize);

                    // Reset dash pattern for other drawings
                    ctx.setLineDash([]);
                }
                // ****************************************************************************
                
                // Draw the UI elements
                ctx.fillStyle = "rgb(241, 241, 241)";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, 155);
                // Draw corner handles
                
                
                if(!movecorners1&&!movecorners2&&!movecorners3&&!movecorners4){
                    ctx.fillStyle = "black";
                    ctx.fillRect(drawstartx-10, drawstarty-10, 10, 10);
                    ctx.fillRect(drawstartx+drawareax, drawstarty-10, 10, 10);
                    ctx.fillRect(drawstartx-10, drawstarty+drawareay, 10, 10);
                    ctx.fillRect(drawstartx+drawareax, drawstarty+drawareay, 10, 10);
                }
                // Draw scrollbars
                ctx.fillStyle = "rgb(100, 100, 100)";
                let sbThickness = getScrollbarThickness();
    
                if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
                    ctx.fillRect(
                        canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue, 
                        canvas.height/devicePixelRatio - sbThickness, 
                        (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01), 
                        sbThickness
                    );
                }
                
                if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
                   ctx.fillRect(canvas.width/devicePixelRatio - sbThickness, 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue, sbThickness, (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                }
              
                const isCanvasTooSmallForScrollingX = !(drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50);
                const isCanvasTooSmallForScrollingY = !(drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50);

                // Center horizontally if needed
                if (isCanvasTooSmallForScrollingX && 
                    (drawstartx < 0 || drawstartx + drawareax > canvas.width/devicePixelRatio)) {
                    // Center horizontally
                    drawstartx = canvas.width/devicePixelRatio/2 - drawareax/2;
                    movescrollxvalue = 0;
                    scrollx = 0;
                }

                // Center vertically if needed
                if (isCanvasTooSmallForScrollingY && 
                    (drawstarty < 0 || drawstarty + drawareay > canvas.height/devicePixelRatio)) {
                    // Center vertically
                    drawstarty = canvas.height/devicePixelRatio/2 - drawareay/2;
                    movescrollyvalue = 0;
                    scrolly = 0;
                }
                            // ======== RITA LOOPEN/SELECTION-OVERLAY I DIN huvud-loop ========
               // i din render/overlay-del
               
               if(currentTool!=="lasso"&&currentTool !== 'select'){isDraggingSelection = false;if (selSessionActive) commitSelectionSession();clearSelection();}
               
               
                  // visa urklippet i overlay p√• nuvarande (ev. drag) position
                if (selectionImageCanvas &&selectionBBox) {
                  const showX = isDraggingSelection ? dragSelX : selectionBBox.x;
                  const showY = isDraggingSelection ? dragSelY : selectionBBox.y;

                  const { w, h } = selectionBBox;
                  const p = _imageXYtoCanvasXY(showX, showY);
                  const z = _effectiveZoom();
                  ctx.drawImage(selectionImageCanvas, p.x, p.y, w*z, h*z);

                  // ‚Äúmarching ants‚Äù
                  const p0 = _imageXYtoCanvasXY(showX, showY);
                  const p1 = _imageXYtoCanvasXY(showX + w, showY + h);
                  ctx.save();
                  ctx.setLineDash([4,3]);
                  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                  ctx.strokeRect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y);
                    const curX = (isDraggingSelection && typeof dragSelX === 'number') ? dragSelX : selectionBBox.x;
                    const curY = (isDraggingSelection && typeof dragSelY === 'number') ? dragSelY : selectionBBox.y;

                    // Om du har ‚Äúpreviews‚Äù f√∂r resize, anv√§nd dem ‚Äì annars fall tillbaka till selectionBBox
                    const curW = (isResizingSelection && typeof rc_prevW === 'number') ? rc_prevW : selectionBBox.w;
                    const curH = (isResizingSelection && typeof rc_prevH === 'number') ? rc_prevH : selectionBBox.h;

                    if (selectionPathImg && selectionOrigBBox && currentTool === 'lasso') {
                      const z = _effectiveZoom();
                      ctx.save();

                      // bild‚Üísk√§rm
                      ctx.translate(drawstartx, drawstarty);
                      ctx.scale(z, z);

                      // Mappa originalkonturen (selectionPathImg i bildkoordinater)
                      // fr√•n selectionOrigBBox ‚Üí till nuvarande bbox (curX/curY/curW/curH)
                      ctx.translate(curX, curY);
                      ctx.scale(curW / selectionOrigBBox.w, curH / selectionOrigBBox.h);
                      ctx.translate(-selectionOrigBBox.x, -selectionOrigBBox.y);

                      ctx.setLineDash([4,3]);
                      // (valfritt: animera "marching" om du vill)
                      // ctx.lineDashOffset = -(performance.now() / 50) % 7;

                      ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                      ctx.stroke(selectionPathImg);
                      ctx.restore();
                    }
                  ctx.restore();
                  //corners ---NYTT
                    ctx.save();
                    ctx.strokeStyle = 'black';
                    ctx.fillStyle = 'white';
                    ctx.lineWidth = 1;
                    const size = 8; // storlek p√• handtaget
                    const corners = [
                      {x: p0.x, y: p0.y}, // top-left
                      {x: p1.x, y: p0.y}, // top-right
                      {x: p0.x, y: p1.y}, // bottom-left
                      {x: p1.x, y: p1.y} // bottom-right
                    ];
                    for (const c of corners) {
                      ctx.fillRect(c.x - size/2, c.y - size/2, size, size);
                      ctx.strokeRect(c.x - size/2, c.y - size/2, size, size);
                    }
                    ctx.restore();
                }

                if(isdragdrag&&currentTool === 'lasso')_drawLassoOverlay();
                if(isdragdrag&&isRectSelecting&&currentTool === 'select')_drawSelectOverlay();
                drawResizeOverlay();
            
            
            
                window.requestAnimationFrame(check);   
            }; 
            
            check();
            
            // Process mouse events
            window.addEventListener("mousemove", (e) => {
                
                
            if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
              
        resizePreviewFromCanvasXY(x, y);  // <<<<<<<<<< NYTT
        // (rita overlay i din render-loop via drawResizeOverlay())
        
      }    
                
                
           if (e.target === canvas){      
                
    const mousePos = getCanvasMousePosition(e);
    x = mousePos.x;
    y = mousePos.y;
    
    isposetive = false;
    if (isdirposetive < x) {
        isposetive = true;
    }
    isdirposetive = x;
    
    isposetivey = false;
    if (isdirposetivey < y) {
        isposetivey = true;
    }
    isdirposetivey = y;
    
    // Handle image dragging
    if(isMovingImage && currentImage&&!selectionNeedsClick){
        currentImageX = (x - dragOffsetX);
        currentImageY = (y - dragOffsetY);
    }
    
    // Handle selection tool
    if (isSelecting && (currentTool === 'select')) {
        selectionEndX = Math.floor((x - drawstartx) / zoom);
        selectionEndY = Math.floor((y - drawstarty) / zoom);
        
        
        
    }
    
    // Handle drawing when mousemove with pen tool
    const heightCheck = 155;
    if (isDrawing && y > heightCheck && currentTool === 'pen'&&!movescrolly&&!movescrollx) {
        drawPixel(x, y);
    }
    
    
    
}});
            
            window.addEventListener("mousedown", (e) => {
                if (e.target === canvas){ 
    const mousePos = getCanvasMousePosition(e);
    x = mousePos.x;
    y = mousePos.y;
    

    
    
    // Check if clicking on the image overlay first
 if(currentImage && x >= currentImageX && x <= currentImageX + currentImageWidth &&
                   y >= currentImageY && y <= currentImageY + currentImageHeight){
                    if(!isMovingImage){
                        // Begin dragging the image
                        isMovingImage = true;
                        dragOffsetX = x - (currentImageX);;
                        dragOffsetY = y - (currentImageY);
                        selectionNeedsClick=false;
                    }
                   
                    else {
                        // If already dragging, finalize by drawing the image permanently onto the drawing canvas
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                    }
                    
                    
                    return;
                }
                else if((currentTool === 'select')&&currentImage!=null){
                        
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                        
                        
                    }
    
    
    // Handle UI interaction with corners and scrollbars
    if (x >= drawstartx-15 && x < drawstartx && y >= drawstarty-15 && y < drawstarty+5) {
        movecorners1 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('NW'); 
        return;
    }
    if (x >= drawstartx+drawareax-5 && x < drawstartx+drawareax+15 && y >= drawstarty-15 && y < drawstarty+5) {
        movecorners2 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('NE');   
        return;
    }
    if (x >= drawstartx-15 && x < drawstartx && y >= drawstarty+drawareay && y < drawstarty-5+drawareay+15) {
        movecorners3 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('SW');    
        return;
    }
    if (x >= drawstartx+drawareax-5 && x < drawstartx+drawareax+15 && y >= drawstarty+drawareay-5 && y < drawstarty+drawareay+15) {
        movecorners4 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('SE');
        return;
    }
    
    // Handle scrollbar interactions
    let sbThickness = getScrollbarThickness();
    if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
        if (x <= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue + (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) &&
           x >= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue &&
           y >= canvas.height/devicePixelRatio - sbThickness && y <= canvas.height/devicePixelRatio) {
            movescrollx = true;
            savescrollxvalue = x;
            return;
        }
    }
    if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
        if (x <= canvas.width/devicePixelRatio && x >= canvas.width/devicePixelRatio - sbThickness &&
           y >= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue &&
           y <= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue + (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
            movescrolly = true;
            savescrollyvalue = y;
            return;
        }
    }
    // Process tool actions if inside the drawing area and below the toolbar
    if (x >= drawstartx && x < drawstartx + drawareax &&
        y >= drawstarty && y < drawstarty + drawareay && y > 100) {
        
        const canvasX = Math.floor((x - drawstartx) / zoom);
        const canvasY = Math.floor((y - drawstarty) / zoom);
        
    if (currentTool === 'eyedropper') {
        updateEyedropperBuffer();
        const data = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
        const hexColor = `#${data[0].toString(16).padStart(2, '0')}${data[1].toString(16).padStart(2, '0')}${data[2].toString(16).padStart(2, '0')}`;

        brushColor = hexColor;
        isTransparentBrush = false;
        switchTool('pen');
        return;
    }
        else if (currentTool === 'fill') {
            // Fill tool
            beginAction();
            floodFill(canvasX, canvasY);
            endAction();
            
        }
        else if ((currentTool === 'select')) {
            // Selection tool
            beginAction();
            isSelecting = true;
            selectionStartX = canvasX;
            selectionStartY = canvasY;
            selectionEndX = canvasX;
            selectionEndY = canvasY;
            
            
        }
        else if(currentTool === 'text'){
             
            const text = prompt("Enter your text:"); // Prompt user for text input
            if (text) {
                beginAction();
                drawText(x, y, text); // Draw the text on the canvas
                endAction();
            }
        }
        
        
        
        else if (currentTool === 'pen') {
            // Draw with pen
             beginAction();
            isDrawing = true;
            lastX = 0;
            lastY = 0;
            drawPixel(x, y);
            
           
        }
    }
                } });    
            
            window.addEventListener('mouseup', (e) => {
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
  resizeCommit();                   // <<<<<<<<<< NYTT
  movecorners1 = movecorners2 = movecorners3 = movecorners4 = false;
}
    movescrollx = false;
    movescrolly = false;
    isposetive = false;
    scrollx = movescrollxvalue;
    scrolly = movescrollyvalue;
    
    if(isDrawing==true)endAction();
    // Stop drawing
    isDrawing = false;
    lastX = 0;
    lastY = 0;




    
    

    
    
// i mouseup/touchend f√∂r select:
isSelecting = false;
selLeft = Math.min(selectionStartX, selectionEndX); // om du anv√§nder dessa lokalt
selTop  = Math.min(selectionStartY, selectionEndY);
// ... men slutligen:
//if(currentTool === 'select')_finalizeRectSelection();
});
            
            // Stop drawing if the mouse leaves the canvas
            window.addEventListener('mouseout', () => {
                isDrawing = false;
                lastX = 0;
                lastY = 0;
            });
           // ===== MOBILE DEVICE SUPPORT =====
           
           
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false}); 
            let touchTimer = null;
            let delatare=false;
            function handleTouchStart(e) {
        e.preventDefault();
        
        if (e.touches.length === 2) {
            clearTimeout(touchTimer);
            if(delatare==true){delatare=false;undo();}
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastPinchDistance = Math.hypot(dx, dy);
            return;
        }
        if (e.touches.length === 1){
            
            touchTimer = setTimeout(() => {
                delatare=false;
            
        }, 80);}
        
        
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();

        const touchX = Math.round((touch.clientX - rect.left) * (canvas.width / rect.width / devicePixelRatio));
        const touchY = Math.round((touch.clientY - rect.top) * (canvas.height / rect.height / devicePixelRatio));

        // Update global position variables
        x = touchX;
        y = touchY;
                // Handle image interaction
    if (currentImage) {
    // Check if touch is on the image
    if (touchX >= currentImageX && touchX <= currentImageX + currentImageWidth &&
        touchY >= currentImageY && touchY <= currentImageY + currentImageHeight) {
        
       if(!isMovingImage){
                        // Begin dragging the image
                        isMovingImage = true;
                        dragOffsetX = x - currentImageX;
                        dragOffsetY = y - currentImageY;
                        selectionNeedsClick=false;
                    } else {
                        // If already dragging, finalize by drawing the image permanently onto the drawing canvas
                        let unzoomedX = Math.floor((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.floor((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                    }
                    return;
    }
    else if((currentTool === 'select')&&currentImage!=null){
                        
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                        
                        
                    }
    
    
    
}



                    
                 
                







        let cornerTouched = 0;
        // Check each corner with a slightly larger touch area for mobile
        const cornerSize = 30; // Larger touch target for corners on mobile

        // Top-left corner
        if (touchX >= drawstartx-cornerSize && touchX < drawstartx+cornerSize && 
            touchY >= drawstarty-cornerSize && touchY < drawstarty+cornerSize) {
            cornerTouched = 1;
            
        }
        // Top-right corner
        else if (touchX >= drawstartx+drawareax-cornerSize && touchX < drawstartx+drawareax+cornerSize && 
                 touchY >= drawstarty-cornerSize && touchY < drawstarty+cornerSize) {
            cornerTouched = 2;
           
        }
        // Bottom-left corner
        else if (touchX >= drawstartx-cornerSize && touchX < drawstartx+cornerSize && 
                 touchY >= drawstarty+drawareay-cornerSize && touchY < drawstarty+drawareay+cornerSize) {
            cornerTouched = 3;
           
        }
        // Bottom-right corner
        else if (touchX >= drawstartx+drawareax-cornerSize && touchX < drawstartx+drawareax+cornerSize && 
                 touchY >= drawstarty+drawareay-cornerSize && touchY < drawstarty+drawareay+cornerSize) {
            cornerTouched = 4;
            
        }

        // Check if it's a double tap on a corner
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;

        if (cornerTouched > 0 && tapLength < doubleTapThreshold && cornerTouched === lastTapCorner) {
            // Double tap detected on the same corner!
            console.log("Double tap on corner " + cornerTouched);

            // Enable dragging for the corresponding corner
            if (cornerTouched === 1) {
                movecorners1 = true;
                resizeStart('NW');  
                return;
            } else if (cornerTouched === 2) {
                movecorners2 = true;
                resizeStart('NE');
                return;
            } else if (cornerTouched === 3) {
                movecorners3 = true;
                resizeStart('SW');
                return;
            } else if (cornerTouched === 4) {
                movecorners4 = true;
                resizeStart('SE');  
                return;
            }

            dragStartX = touchX;
            dragStartY = touchY;
        }

        // Update the last tap info for next time
        if (cornerTouched > 0) {
            lastTapTime = currentTime;
            lastTapCorner = cornerTouched;

            // Return early to prevent other interactions from happening
            // when touching a corner but not double-tapping yet
            if (!movecorners1 && !movecorners2 && !movecorners3 && !movecorners4) {
                return;
                
            }
        }
        
        
        
        
        
        
        // Check for scrollbar interaction on touch devices
        let sbThickness = getScrollbarThickness();
        if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
            if(touchX <= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue + (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) &&
               touchX >= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue &&
               touchY >= canvas.height/devicePixelRatio - sbThickness && touchY <= canvas.height/devicePixelRatio) {
                movescrollx = true;
                savescrollxvalue = touchX - movescrollxvalue ;
                return;
                
            }
        }
        if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
            if(touchX <= canvas.width/devicePixelRatio && touchX >= canvas.width/devicePixelRatio - sbThickness &&
               touchY >= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue &&
               touchY <= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue + (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
                movescrolly = true;
                savescrollyvalue = touchY- movescrollyvalue ;;
                return;
                
            }
        }
                    // Check for tool actions inside the drawing area
        if (touchX >= drawstartx && touchX < drawstartx + drawareax &&
           touchY >= drawstarty && touchY < drawstarty + drawareay && touchY > 155) {

            const canvasX = Math.floor((touchX - drawstartx) / zoom);
            const canvasY = Math.floor((touchY - drawstarty) / zoom);

            if (currentTool === 'eyedropper') {
                updateEyedropperBuffer();
                const data = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
                const hexColor = `#${data[0].toString(16).padStart(2, '0')}${data[1].toString(16).padStart(2, '0')}${data[2].toString(16).padStart(2, '0')}`;

                brushColor = hexColor;
                isTransparentBrush = false;
                switchTool('pen');
                return;
            }
             else if (currentTool === 'fill') {
                // Fill tool
                beginAction();
                floodFill(canvasX, canvasY);
                endAction();
            }
             else if ((currentTool === 'select')) {
                // Selection tool
                beginAction();
                isSelecting = true;
                selectionStartX = canvasX;
                selectionStartY = canvasY;
                selectionEndX = canvasX;
                selectionEndY = canvasY;

           }
           else if(currentTool === 'text'){
                const text = prompt("Enter your text:"); // Prompt user for text input
                if (text) {
                    beginAction();
                    drawText(touchX, touchY, text); // Draw the text on the canvas
                    endAction();
                }
           }
           
             else if (currentTool === 'pen') {
                // Rest of your existing touch handling code for drawing
                isDrawing = true;
                lastX = 0;
                lastY = 0;
                beginAction();
                delatare=true;
                drawPixel(touchX, touchY);
                
                
                

           }
        }
    }

function handleTouchMove(e) {
    e.preventDefault();
    
    
    if (e.touches.length === 2 && lastPinchDistance !== null) {

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.hypot(dx, dy);

        const delta = newDistance - lastPinchDistance;

        // üîç Zooma in/ut beroende p√• distans√§ndring
        let newzoom =zoom;
        
        if (Math.abs(delta) > 5) {
            if (delta > 0) newzoom *= 1.05;
            else newzoom *= 0.95;

            newzoom = Math.max(0.10, Math.min(newzoom, 50)); // begr√§nsa zoomniv√•
            
                    zoomvalue = Math.round(newzoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
            
            
            lastPinchDistance = newDistance;
        }
        return;
    }
    
    
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();

    // Convert to canvas coordinates
    const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width / devicePixelRatio);
    const touchY = (touch.clientY - rect.top) * (canvas.height / rect.height / devicePixelRatio);

    // Update directions
    isposetive = isdirposetive < touchX;
    isdirposetive = touchX;
    
    isposetivey = isdirposetivey < touchY;
    isdirposetivey = touchY;

    // Update current position
    x = touchX;
    y = touchY;

    // Handle selection tool
    if (isSelecting && (currentTool === 'select')) {
        selectionEndX = Math.floor((x - drawstartx) / zoom);
        selectionEndY = Math.floor((y - drawstarty) / zoom);
    }


   // Move the image if it's in moving state
    if (isMovingImage && currentImage&&!selectionNeedsClick) {
        currentImageX = touchX - dragOffsetX;
        currentImageY = touchY - dragOffsetY;
    }

    // Handle drawing with pen tool
    if (isDrawing && touchY > 155 && currentTool === 'pen'&&!movescrolly&&!movescrollx) {
        beginAction();
        drawPixel(touchX, touchY);
     
    }
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
        resizePreviewFromCanvasXY(x, y);  // <<<<<<<<<< NYTT
        // (rita overlay i din render-loop via drawResizeOverlay())
        return;
      }
    
 
}

   function handleTouchEnd(e) {
    e.preventDefault();
    clearTimeout(touchTimer);
    if (e.touches.length < 2) {
        lastPinchDistance = null;
    }
    movescrollx = false;
    movescrolly = false;
    if(isDrawing==true){endAction();}
    // Stop drawing
    isDrawing = false;
    lastX = 0;
    lastY = 0;
    
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
        resizeCommit();                   // <<<<<<<<<< NYTT
        movecorners1 = movecorners2 = movecorners3 = movecorners4 = false;
        
      }
    

    
    
    // i mouseup/touchend f√∂r select:
isSelecting = false;
selLeft = Math.min(selectionStartX, selectionEndX); // om du anv√§nder dessa lokalt
selTop  = Math.min(selectionStartY, selectionEndY);
// ... men slutligen:
//if(currentTool === 'select')_finalizeRectSelection();
    

}
           
     //==========LOAD IMAGES MOBILE===========
                
document.addEventListener('DOMContentLoaded', function() {
    // Get direct file input
    const directInput = document.getElementById('directFileInput');

    // Add proper event listener
    directInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(evt) {
            const img = new Image();
img.onload = function() {
                    // Make sure the drawing canvas is big enough
                    ensureCanvasSize(img.width, img.height);

                    // **************** FIXED: Load image into separate overlay layer ****************
                    currentImage = img;
                    currentImageOriginalWidth = img.width;
                    currentImageOriginalHeight = img.height;
                    currentImagecanvas=currentproject;
                    
                    
                    // Determine appropriate zoom based on image size compared to window
                    // Always check if we need to adjust zoom for the new image regardless if it's the first
                    let newZoom = zoom; // Start with current zoom
                    if (img.width * newZoom > window.innerWidth * 0.8 || 
                        img.height * newZoom > (window.innerHeight - 100) * 0.8) {
                        // Image is too large at current zoom, recalculate
                        const zoomX = Math.round(((window.innerWidth * 0.8) / img.width)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.8) / img.height)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                    }
                    else if((((firstImageLoaded1===false&&currentproject===0))||(firstImageLoaded2===false&&currentproject===1)||(firstImageLoaded3===false&&currentproject===2) )&&((img.width * newZoom < window.innerWidth * 0.5 ||img.height * newZoom < (window.innerHeight - 100) * 0.5 ))){
                        
     
                        const zoomX = Math.round(((window.innerWidth * 0.5) / img.width)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.5) / img.height)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                        
                        
                        
                    }
                    
                    
                    zoom = newZoom;
                    zoomvalue = Math.round(newZoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
                    
                    // Update canvas dimensions if this is the first image or if the new image is larger
                    if (((firstImageLoaded1==false&&currentproject==0)||(firstImageLoaded2==false&&currentproject==1)||(firstImageLoaded3==false&&currentproject==2) ) || (img.width > firstImageWidth || img.height > firstImageHeight)) {
                        firstImageWidth = Math.max(img.width);
                        firstImageHeight = Math.max(img.height);
                    }
                    
                    drawareax = Math.floor(firstImageWidth * zoom);
                    drawareay = Math.floor(firstImageHeight * zoom);
                    
                    // Set display dimensions for the overlay image
                    currentImageWidth = currentImageOriginalWidth * zoom;
                    currentImageHeight = currentImageOriginalHeight * zoom;
                    
                    // Position the image initially centered in the viewport
                    currentImageX = Math.floor((canvas.width/devicePixelRatio - currentImageWidth) / 2);
                    currentImageY = Math.max(120, Math.floor((canvas.height/devicePixelRatio - currentImageHeight) / 2));
                    
                    // Center drawing area
                    drawstartx = Math.floor((canvas.width/devicePixelRatio - drawareax) / 2);
                    drawstarty = Math.max(100, Math.floor((canvas.height/devicePixelRatio - drawareay) / 2));

                    // Update previous dimensions
                    prevDrawAreaX = drawareax;
                    prevDrawAreaY = drawareay;
                    prevDrawStartX = drawstartx;
                    prevDrawStartY = drawstarty;
                    prevzoom = zoom;
                    
                    
                    let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                    let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                    if(((firstImageLoaded1==false&&currentproject==0)||(firstImageLoaded2==false&&currentproject==1)||(firstImageLoaded3==false&&currentproject==2) ))drawingCtx.clearRect(unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight); 
                    
                    
                    
                    // Mark image as loaded, but NOT moving yet (wait for click)
                    
                    if(currentproject==0)firstImageLoaded1=true;
                    if(currentproject==1)firstImageLoaded2=true;
                    if(currentproject==2)firstImageLoaded3=true;
                    canvasPools = new Map();
                   
                    isImageWaiting = true;
                    isMovingImage = false; // Don't move until clicked
                };
            img.src = evt.target.result;
        };
        reader.readAsDataURL(file);
        this.value = ''; // Reset input for reuse
    });
});
    document.addEventListener('DOMContentLoaded', function() {
    // Get the save button
    const saveBtn = document.getElementById('saveImageBtn');
    
    // Add click event handler for save button
    if (saveBtn) {
        saveBtn.addEventListener('click', function() {
            // Create a temporary canvas for the final image
            const saveCanvas = document.createElement('canvas');
            const saveCtx = saveCanvas.getContext('2d', {alpha: true});
            
            // Set dimensions to match the current drawing area
            const displayWidth = Math.floor(drawareax / zoom);
            const displayHeight = Math.floor(drawareay / zoom);
            saveCanvas.width = displayWidth;
            saveCanvas.height = displayHeight;
            
            // Draw the content WITHOUT filling white background first
            disableSmoothing(saveCtx);
            
            // Just draw the drawing canvas directly   
            saveCtx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0, 0, displayWidth, displayHeight);
            
            try {
                // Convert to data URL with PNG format to support transparency
                const dataURL = saveCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'maxpaint-image.png';
                link.href = dataURL;
                link.click();
                console.log("Image saved successfully with transparency");
            } catch (e) {
                console.error("Error saving image:", e);
                alert("Could not save the image. Error: " + e.message);
            }
        });
    }
    
    // Mobile-specific adjustments for the save button
    function adjustButtonsForMobile() {
        const saveBtn = document.getElementById('saveImageBtn');
        const openLabel = document.querySelector('label[for="directFileInput"]');
        
        if (mobileAndTabletCheck()) {
            // Mobile styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "15px 25px";
                saveBtn.style.fontSize = "22px";
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "120px";
            }
            if (openLabel) {
                openLabel.style.padding = "15px 25px";
                openLabel.style.fontSize = "22px"; // Exact same font size
                openLabel.style.top = "15px";
                openLabel.style.minWidth = "120px";
            }
        } else {
            // Desktop styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "8px 15px";
                saveBtn.style.fontSize = "16px"; // Exact same font size
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "90px";
            }
            if (openLabel) {
                openLabel.style.padding = "8px 15px";
                openLabel.style.fontSize = "16px"; // Exact same font size
                openLabel.style.top = "10px";
                openLabel.style.minWidth = "90px";
            }
        }
    }
    
    // Call initially
    adjustButtonsForMobile();
    
    // Also adjust when window is resized
    window.addEventListener('resize', adjustButtonsForMobile);
});
    document.addEventListener('DOMContentLoaded', function() {
    // Tool button setup
    const toolButtons = {
        pen: document.getElementById('penTool'),
        fill: document.getElementById('fillTool'),
        select: document.getElementById('selectTool'),
        eyedropper: document.getElementById('eyedropperTool'),
        text: document.getElementById('textTool'),
        lasso: document.getElementById('lassoTool')
        
    };
    
    // Function to update tool button appearance
    function updateToolButtons() {
        Object.keys(toolButtons).forEach(tool => {
            if (toolButtons[tool]) {
                if (tool === currentTool) {
                    toolButtons[tool].style.backgroundColor = '#d4ffd4';
                    toolButtons[tool].style.borderColor = '#4CAF50';
                } else {
                    toolButtons[tool].style.backgroundColor = '#f1f1f1';
                    toolButtons[tool].style.borderColor = '#ccc';
                }
            }
        });
    }
    
    // Add click handlers for tool buttons
    Object.keys(toolButtons).forEach(tool => {
        if (toolButtons[tool]) {
            toolButtons[tool].addEventListener('click', function() {
                currentTool = tool;
                console.log("Selected tool:", tool);
                updateToolButtons();
            });
        }
    });
    
    // Keyboard shortcuts for tools
    window.addEventListener('keydown', function(e) {
        if (document.activeElement.tagName !== 'INPUT') {
            switch(e.key.toLowerCase()) {
                case 'p': currentTool = 'pen'; break;
                case 'f': currentTool = 'fill'; break;
                case 's': currentTool = 'select'; break;
                case 'e': currentTool = 'eyedropper'; break;
                case 't': currentTool = 'text'; break; 
                case 'l': currentTool = 'lasso'; break;
                
            }
            updateToolButtons();
        }
    });
    
    // Initialize tool buttons appearance
    updateToolButtons();
    
   const toolsContainer = document.querySelector('.tool-buttons');
    
    function adjustToolsForDeviceType() {
        if (mobileAndTabletCheck() ) {
            // Mobile layout - position under other controls
            toolsContainer.style.top = '70px';
          
            toolsContainer.style.left = '180px';
            toolsContainer.style.transform = 'translateY(-50%)';
            
            // Make buttons bigger on mobile
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.style.width = '45px';
                btn.style.height = '45px';
            });
        } else {
            
            
            // Desktop layout - use right positioning to stay next to zoom
            toolsContainer.style.top = '70px';
             toolsContainer.style.left = '600px';
            toolsContainer.style.transform = 'translateY(-50%)';
         
            
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.style.width = '40px';
                btn.style.height = '40px';
            });
        }
    }
    
    // Call initially and on window resize
    adjustToolsForDeviceType();
    window.addEventListener('resize', adjustToolsForDeviceType);
    // Call initially and on resize

});


    
           // ===== END MOBILE DEVICE SUPPORT =====
            resizeCanvas();
            
        </script>
<script>
// Assuming drawingCanvas, drawingCtx, undoStack, redoStack are defined globally or accessible.
// Also assuming drawareax, drawareay, zoom, showGrid, gridBtn, lastSaveTime, actionInProgress are defined.



let actionInProgress = false;
let lastSaveTime = 0;



///1
const MAX_UNDO = 20;
// The canvasPool holds all pre-allocated canvas elements.
// These elements are reused to avoid creating/destroying DOM nodes frequently.
// The memory for these elements themselves (not just pixel data) will persist.


 // Map<imageIndex, { pool: Canvas[], index: number }>
// Gets the next available canvas element from the pool.
// It does NOT clear the canvas's content; the caller is responsible for that.
function getNextCanvasFromPoolFor(index) {
    let entry = canvasPools.get(index);
    if (!entry) {
        // Skapa ny pool f√∂r bilden
        const pool = Array.from({ length: MAX_UNDO * 2 }, () => {
            const c = document.createElement('canvas');
            c.width = Math.floor(drawareax / zoom);
            c.height = Math.floor(drawareay / zoom);
            return c;
        });
        entry = { pool, index: 0 };
        canvasPools.set(index, entry);
    }

    const canvas = entry.pool[entry.index % entry.pool.length];
    entry.index++;
    return canvas;
}

// Helper function to explicitly clear a canvas's pixel data.
// This is the primary mechanism to release GPU/CPU memory associated with the canvas content.
// This should be called when a canvas is no longer needed for display or history.
function clearCanvasMemory(canvas) {
    if (canvas) {
        // Store current dimensions to restore them after clearing.
        // This is crucial because the canvas element itself remains in the pool
        // and needs to be ready for future use with its original dimensions.
        const currentWidth = Math.floor(drawareax / zoom);
        const currentHeight = Math.floor(drawareay / zoom);

        // Setting width/height to 0 then back to original size is a common
        // trick to force the browser to release the pixel buffer memory.
        canvas.width = 0;
        canvas.height = 0;

        // Restore dimensions for future use in the pool.
        canvas.width = Math.floor(drawareax / zoom);
        canvas.height = Math.floor(drawareay / zoom);

        // Optional: Explicitly clear the context as well, though width/height reset usually handles this.
        // canvas.getContext('2d').clearRect(0, 0, currentWidth, currentHeight);
    }
}

function saveState() {
    const now = Date.now();
    if (now - lastSaveTime < 100) return; // Debounce saves
    lastSaveTime = now;

    // When a new state is saved, the redo stack becomes invalid.
    // All canvases in the redoStack are no longer needed, so clear their pixel data.
    while (redoStack.length > 0) {
        const oldRedoCanvas = redoStack.pop();
        clearCanvasMemory(oldRedoCanvas); // Release pixel memory
    }

    // Get a canvas from the pool for the new snapshot.
   const snapshot = getNextCanvasFromPoolFor(currentproject);
    // Clear its content before drawing the current state onto it.
    snapshot.getContext('2d').clearRect(0, 0, snapshot.width, snapshot.height);
    snapshot.getContext('2d').drawImage(drawingCanvas, 0, 0);
    undoStack.push(snapshot);

    // If the undoStack exceeds MAX_UNDO, remove the oldest state.
    // This oldest canvas is no longer needed for undo, so clear its pixel data.
    if (undoStack.length > MAX_UNDO) {
        const oldestUndoCanvas = undoStack.shift();
        clearCanvasMemory(oldestUndoCanvas); // Release pixel memory
    }
}

function beginActionIfNeeded() { // Original function name
    if (!actionInProgress) {
        saveState();
        actionInProgress = true;
    }
}

function endAction() {
    actionInProgress = false;
}

function undo() {
    if (undoStack.length === 0) return;

    // Save the current state of drawingCanvas to the redoStack
    // so it can be redone later.
    const currentCanvasForRedo = getNextCanvasFromPoolFor(currentproject);;
    currentCanvasForRedo.getContext('2d').clearRect(0, 0, currentCanvasForRedo.width, currentCanvasForRedo.height);
    currentCanvasForRedo.getContext('2d').drawImage(drawingCanvas, 0, 0);
    redoStack.push(currentCanvasForRedo);

    // Get the previous state from undoStack.
    const prevCanvas = undoStack.pop();

    // Apply the previous state to the drawingCanvas.
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    drawingCtx.drawImage(prevCanvas, 0, 0);

    // No explicit clearCanvasMemory here for prevCanvas or currentCanvasForRedo
    // because they are now part of the active undo/redo history (or the current display).
    // Their memory will be managed when they are shifted off the stack or replaced later.
}

function redo() {
    if (redoStack.length === 0) return;

    // Save the current state of drawingCanvas to the undoStack
    // so it can be undone later.
    const currentCanvasForUndo = getNextCanvasFromPoolFor(currentproject);;
    currentCanvasForUndo.getContext('2d').clearRect(0, 0, currentCanvasForUndo.width, currentCanvasForUndo.height);
    currentCanvasForUndo.getContext('2d').drawImage(drawingCanvas, 0, 0);
    undoStack.push(currentCanvasForUndo);

    // If undoStack exceeds MAX_UNDO after pushing the current state,
    // the oldest state is no longer needed for undo, so clear its pixel data.
    if (undoStack.length > MAX_UNDO) {
        const oldestUndoCanvas = undoStack.shift();
        clearCanvasMemory(oldestUndoCanvas); // Release pixel memory
    }

    // Get the next state from redoStack.
    const nextCanvas = redoStack.pop();

    // Apply the next state to the drawingCanvas.
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    drawingCtx.drawImage(nextCanvas, 0, 0);

    // No explicit clearCanvasMemory here for nextCanvas or currentCanvasForUndo
    // because they are now part of the active undo/redo history (or the current display).
}

// Original beginAction function (duplicate of beginActionIfNeeded, but preserving original structure)
function beginAction() {
    if (!actionInProgress) {
        saveState();
        actionInProgress = true;
    }
}

function cloneCurrentCanvas() {
    let c = document.createElement('canvas');
    c.width = drawingCanvas.width;
    c.height = drawingCanvas.height;
    c.getContext('2d').drawImage(drawingCanvas, 0, 0);
    return c;
}

const gridBtn = document.getElementById('gridBtn');
function updateGridButton() {
    if (!gridBtn) return;
    gridBtn.style.backgroundColor = showGrid ? '#d4ffd4' : '#f1f1f1';
    gridBtn.style.borderColor = showGrid ? '#4CAF50' : '#ccc';
}

gridBtn.addEventListener('click', () => { showGrid = !showGrid; updateGridButton(); });
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);
window.addEventListener('keydown', function(e) {
  const z = e.key.toLowerCase() === 'z';
  const y = e.key.toLowerCase() === 'y';
  const mod = e.ctrlKey || e.metaKey;
  if (mod && z && !e.shiftKey) { e.preventDefault(); undo(); }
  else if (mod && (y || (z && e.shiftKey))) { e.preventDefault(); redo(); }
  if (e.key.toLowerCase() === 'g') { showGrid = !showGrid; updateGridButton(); }
});
updateGridButton();</script>
</body>
</html>