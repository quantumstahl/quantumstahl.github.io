<!DOCTYPE html>

<html>
<head>
<title>MaxPaint</title>
<meta charset="utf-8"/>
<meta content="user-scalable=no, shrink-to-fit=yes" name="viewport"/>
<meta content="maxpaint,paint" name="keywords"/>
<link href="loggo.png" rel="icon" type="image/vnd.microsoft.icon"/>
<style>
            
    
    
    /* === Top Bar / Menyer === */
#topBar{
  position: fixed; top: 10px; left: 10px; right: 10px; height: 48px;
  display: flex; align-items: center; gap: 10px;
  z-index: 2000; pointer-events: none; /* bara knappar f√•r events */
}
.topbar-group{ display:flex; gap:10px; pointer-events:auto; }

.topbtn{
  height: 48px; min-width: 48px; padding: 0 12px;
  display:flex; align-items:center; gap:8px; justify-content:center;
  background: rgba(30,30,30,.92); color:#fff; border:1px solid rgba(255,255,255,.12);
  border-radius: 12px; cursor: pointer; user-select: none;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
}
.topbtn:active{ transform: translateY(1px); }

/* Dropdown paneler */
.dropdown, .menu{
  position: absolute; top: 56px;left: 0;
  background: rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12); border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  min-width: 220px; padding: 6px; display:none; z-index: 2200;
}
.menu.open, .dropdown.open{ display:block; }

.menu .item, .dropdown .item{
  width:100%; text-align:left; padding:10px 12px; border-radius: 10px;
  background: transparent; color:#fff; border:none; cursor:pointer;
}
.menu .item:hover, .dropdown .item:hover{ background: rgba(255,255,255,.08); }

/* Ikon f√∂r hamburgern */
.hamburger { font-size: 20px; line-height: 1; }

/* Mobil: lite st√∂rre ytor */
@media (pointer:coarse), (max-width:768px){
  .topbtn{ height: 56px; min-width: 56px; padding: 0 16px; border-radius: 14px; }
  .menu, .dropdown{ min-width: 260px; }
}
/* === Meny-backdrop som f√•ngar tryck utanf√∂r menyn === */
#menuBackdrop{
  position: fixed; inset: 0;
  background: transparent; /* inget m√∂rkt lager ‚Äì bara en ‚Äúclick catcher‚Äù */
  display: none; z-index: 2100; /* mellan topbtn (2000) och dropdown (2200) */
}
#menuBackdrop.show{ display:block; }

/* Se till att dropdowns sitter under knappen (v√§nsterkanten) */
.dropdown, .menu{
  position: absolute; top: 56px; left: 0;   /* <-- viktigt f√∂r placering */
  background: rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12); border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  min-width: 220px; padding: 6px; display:none; z-index: 2200;
}

/* === Mobil / touch: dubbla storlekar === */
@media (pointer:coarse), (max-width: 768px){
  #topBar{ gap: 12px; }
  .topbtn{
    height: 72px; min-width: 72px; padding: 0 22px; border-radius: 18px;
    font-size: 18px; gap: 10px;
  }
  .hamburger{ font-size: 26px; }

  .menu, .dropdown{
    top: 80px;                /* l√§ngre ned under st√∂rre knapp */
    min-width: 300px;         /* lite bredare */
    padding: 10px; border-radius: 16px;
  }
  .menu .item, .dropdown .item{
    padding: 16px 18px;       /* st√∂rre tr√§ffyta */
    font-size: 18px;
    border-radius: 14px;
  }
}    
/* TOP BAR √∂ver backdropen */
#topBar{
  position: fixed; top: 20px; left: 10px; right: 10px; height: 48px;
  display: flex; align-items: center; gap: 10px;
  z-index: 2300;          /* <-- H√ñGRE √§n backdrop */
  pointer-events: none;
}

/* Backdrop f√•ngar utanf√∂r-klick men ligger UNDER dropdown */
#menuBackdrop{
  position: fixed; inset: 0;
  background: transparent;
  display: none;
  z-index: 2200;          /* <-- UNDER topBar och dropdown */
}
#menuBackdrop.show{ display:block; }

/* Menyer direkt under sina knappar (v√§nsterjusterade) */
.dropdown, .menu{
  position: absolute; top: 56px; left: 0;
  background: rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12); border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  min-width: 220px; padding: 6px; display:none;
  z-index: 2400;          /* <-- √ñVER backdrop (2200) och topBar (2300‚Äôs barn) */
}
.menu.open, .dropdown.open{ display:block; }  /* <-- viktigt */    
    
    
/*topbar right    */
    
/* === Right Transform Launcher === */
#transformDock{
  position: absolute; right: 12px; top: 0px;
  z-index: 2300;   /* √∂ver backdrop (2200) */
  pointer-events: none;
}
#transformBtn{
    position: absolute; right: 12px; top: 0px;
  pointer-events: auto;
  width: 56px; height: 56px; border-radius: 9999px;
  display: flex; align-items: center; justify-content: center;
  background: rgba(30,30,30,.92); color: #fff; border: 1px solid rgba(255,255,255,.12);
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
  cursor: pointer; user-select: none;
}
#transformBtn:active{ transform: translateY(1px); }

/* Sj√§lva menyn */
#transformMenu{
  position: absolute; right: 0; top: 68px;
  background: rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12); border-radius: 14px;
  padding: 8px; min-width: 220px; display: none;
  box-shadow: 0 12px 32px rgba(0,0,0,.35);
  z-index: 2400; /* √∂ver backdrop */
}
#transformMenu.open{ display:block; }

#transformMenu .item{
  width: 100%; text-align: left; padding: 12px 14px; border-radius: 12px;
  background: transparent; color: #fff; border: none; cursor: pointer;
}
#transformMenu .item:hover{ background: rgba(255,255,255,.08); }

/* Mobil / touch: dubbla storlekar */
@media (pointer:coarse), (max-width: 768px){
  #transformBtn{ width: 76px; height: 76px; font-size: 20px; }
  #transformMenu{ top: 90px; min-width: 280px; padding: 12px; border-radius: 18px; }
  #transformMenu .item{ padding: 18px 20px; font-size: 18px; border-radius: 16px; }
}    
/* HOVER/FOCUS p√• toppknappar */
.topbtn{
  transition: transform .06s ease, background .12s ease, box-shadow .12s ease;
}
.topbtn:hover, .topbtn:focus-visible{
  background: rgba(45,45,45,.98);
  box-shadow: 0 12px 28px rgba(0,0,0,.38);
}

/* Meny-items har du redan :hover p√•, beh√•ll det. */

/* G√∂r menyer klickbara √§ven om deras f√∂r√§lder (dock) har pointer-events:none */
.menu, .dropdown, #transformMenu{
  pointer-events: auto;   /* <-- viktigt */
}

/* Transform-docken till h√∂ger */
#transformDock{
  position: fixed; right: 12px; top: 10px;
  z-index: 2300;
  pointer-events: none;    /* docken ignorerar klick ... */
}
#transformBtn{             /* ... men knappen f√•ngar dem */
  pointer-events: auto;
}
#transformMenu{            /* ... och menyn ocks√• */
  pointer-events: auto;
}    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
              body {
    overscroll-behavior: none;
    touch-action: none;
    position: fixed;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }       

            
        canvas {
          background-color: #50459b;
          max-width: 100%;
          max-height: 100%;
          image-rendering: pixelated;
          /* Enhanced pixel rendering properties for all browsers */
          image-rendering: -moz-crisp-edges;    /* Firefox */
          image-rendering: -webkit-crisp-edges; /* Webkit */
          image-rendering: pixelated;           /* Chrome, Edge, Opera, Safari */
          image-rendering: crisp-edges;         /* Standard syntax */
          -ms-interpolation-mode: nearest-neighbor;  /* IE */
          display: block;
          margin: auto;
        }
        .btn-open {
          padding: 8px 15px;
          font-size: 16px;
          background-color: #4CAF50;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          position: absolute;
          top: 50px; /* Centered in toolbar height */
          left: 0px;
          transform: translateY(-50%);
          z-index: 100;
          outline: none; /* Remove outline */
          box-shadow: none;
        }
        .btn-open:hover {
          background-color: #45a049;
        }
        .zoom-container {
          position: absolute;
          top: 50px; /* Centered in toolbar height */
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          z-index: 100;
          touch-action: none;
          -webkit-touch-callout: none;
          pointer-events: auto;
          outline: none; /* Remove outline */
          box-shadow: none;
        }
        #zoomLabel, #brushSizeLabel {
            -webkit-user-select: none;  /* Safari */
            -moz-user-select: none;     /* Firefox */
            -ms-user-select: none;      /* IE/Edge */
            user-select: none;          /* Standard syntax */
            cursor: default;            /* Change cursor to default instead of text */
            color: white;
            font-size: 18px;
            font-weight: bold;
            
          }

          /* Make all labels and text in the control area non-selectable */
          .zoom-container, label {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default;
          }
        #zoomSlider, #brushSizeSlider {
            touch-action: none;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
          }
          #zoomSlider, #brushSizeSlider, .zoom-container, #zoomLabel, #brushSizeLabel,.color-palette {
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            -khtml-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            touch-action: none !important;
            outline: none; /* Remove outline */
            box-shadow: none;
            touch-action: none;
        }
          
          
          
        
        @media (max-width: 768px), (pointer: coarse) {
          .btn-open {
            padding: 15px 25px;
            font-size: 22px;
            top: 60px;
            left: 20px;
          }
        .scrollbar-hitbox {
            position: absolute;
            z-index: 99;
          }
          .zoom-container {
            top: 68px;
            left: 390px;
            transform: translateY(-50%);
            padding: 0 80px;
            box-sizing: border-box;
          }

          #zoomSlider {
            width: 100%;
            height: 30px;
            margin-top: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #d3d3d3;
            outline: none;
            border-radius: 15px;
          }

          #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background: #4CAF50;
            border-radius: 50%;
            width: 60px; 
            height: 60px;
            cursor: pointer; 
            
          }

          #zoomSlider::-moz-range-thumb {
            width: 45px; 
            height: 45px;
            background: #4CAF50;
            border-radius: 50%;
            transform: scale(0.8);
          }
          
          /* Brush size slider styling similar to zoomSlider */
          #brushSizeSlider {
            width: 100%;
            height: 30px;
            margin-top: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #d3d3d3;
            outline: none;
            border-radius: 15px;
          }

          #brushSizeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 60px; 
            height: 60px;
            background: #4CAF50;
            border-radius: 50%;
          }

          #brushSizeSlider::-moz-range-thumb {
            width: 35px;
            height: 35px;
            background: #4CAF50;
            border-radius: 50%;
          }

          #zoomLabel, #brushSizeLabel {
            font-size: 18px;
            font-weight: bold;
            
            
          }
        }
          .color-palette {
            border: 1px solid transparent;  
            position: absolute;
            will-change: transform;
            padding: 9px;
            border-radius: 4px;
            left: 50%; margin-left: 120px; margin-top: 0;
            outline: none; /* Remove outline */
            box-shadow: none;
                
          }

          .color-row {
            display: flex;
            margin-bottom: 5px;
            outline: none; /* Remove outline */
            box-shadow: none;
          }

          .color-row:last-child {
            margin-bottom: 0;
          }

          .color-swatch {
            width: 28px;
            height: 28px;
            margin: 0 5px;
            border-radius: 3px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s;
          }

          .color-swatch:hover {
            transform: scale(1.1);
          }

          .color-swatch.active {
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #000;
          }

          @media (max-width: 768px), (pointer: coarse) {
            .color-palette {
              position: absolute;
              border: 1px solid transparent;  
              will-change: transform;
              top: 0px;
              left: 560px;
              outline: none; /* Remove outline */
              box-shadow: none;
              
            
            }

            .color-swatch {
              width: 35px;
              height: 35px;
              margin: 0 3px;
              outline: none; /* Remove outline */
              box-shadow: none;
            }
          }
          /* Modal dialog styling */
      .modal {
        display: none;
        position: fixed;
        z-index: 3000; /* Higher than toolbar */
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4);
      }
      
      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 300px;
        border-radius: 5px;
      }
      
      .modal-content h3 {
        margin-top: 0;
      }
      
      .modal-content .form-group {
        margin-bottom: 15px;
      }
      
      .modal-content label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      
      .modal-content input {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
      }
      
      .modal-content .button-row {
        text-align: right;
        margin-top: 20px;
      }
      
      .modal-content button {
        padding: 8px 15px;
        margin-left: 10px;
        cursor: pointer;
      }
        
.color-pop.hidden{ display:none;}
/* === COLOR EDITOR ‚Äî XL SIZE === */



#color-editor .color-pop-inner{
  width: 500px;
  max-height: min(88vh, 840px);
  padding: 18px;
  display: grid; 
  gap: 16px;
  background: #aaa;
  /* om din pop har max-width/min-height n√•gon annanstans, denna vinner */
}

/* St√∂rre palett-yta (regnb√•ge) */
#rainbowCanvas{
  width: 100%;
  height: clamp(260px, 50vh, 420px); /* rej√§l p√• mobil/desktop */
  display: block;
  border: 0;
  outline: 0;
}

/* St√∂rre rader/typografi */
#color-editor .row{ gap: 16px; align-items: center; flex-wrap: wrap; }
#color-editor label{ font-size: 16px; }
#hexOut{ font-size: 30px; }
#colorPreview{
  width: 100px; height: 100px;
  border-radius: 10px;
  box-shadow: 0 0 0 1px rgba(0,0,0,.12) inset;
}

/* === Rej√§la sliders (cross-browser) === */
#color-editor input[type="range"]{
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 44px;            /* klick/finger-yta */
  background: transparent; /* vi ritar bara tracken/knoppen */
  touch-action: none;      /* undvik scroll-juck p√• mobil */
}
/* WebKit track */
#color-editor input[type="range"]::-webkit-slider-runnable-track{
  height: 50px;
  background: rgba(0,0,0,.1);
  border-radius: 999px;
}
/* WebKit thumb */
#color-editor input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  width: 70px; height:70px;
  border-radius: 50%;
  background: #fff;
  box-shadow: 0 0 0 1px rgba(0,0,0,.25), 0 2px 6px rgba(0,0,0,.15);
  margin-top: calc((12px - 28px) / 2); /* centrera mot track */
}
/* Firefox track */
#color-editor input[type="range"]::-moz-range-track{
  height: 12px;
  background: rgba(0,0,0,.1);
  border-radius: 999px;
}
/* Firefox thumb */
#color-editor input[type="range"]::-moz-range-thumb{
  width: 28px; height: 28px;
  border-radius: 50%;
  background: #fff;
  border: none;
  box-shadow: 0 0 0 1px rgba(0,0,0,.25), 0 2px 6px rgba(0,0,0,.15);
}

/* === Knappar: st√∂rre & l√§ttklickade === */
#color-editor .btn-primary,
#color-editor .btn-secondary{
  min-height: 100px;
  padding: 12px 18px;
  font-size: 22px;
  border-radius: 12px;
  line-height: 1.1;
}

/* Lite extra luft p√• riktigt sm√• sk√§rmar */
@media (max-width: 700px){
  #color-editor .color-pop-inner{ width: min(96vw, 1040px); }
}





/* ===== Bottom Dock (kompakt) ===== */
/* === Centered Bottom Dock (compact) === */
#bottomDock{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: clamp(80px, 1.8vh, 80px);
  z-index: 1200;

  /* storlek och stil */
  max-width: min(760px, 96vw);
  width: max-content;
  background: rgba(30,30,30,.88);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,.09);
  border-radius: 14px;
  padding: 10px 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);

  display: grid;
  grid-template-columns: 1fr auto; /* v√§nster: palett+brush, h√∂ger: üé® */
  gap: 12px;
  pointer-events: auto;
}

.edit-btn{width:69px;height:69px;border-radius: 7px;
  box-shadow: none !important; outline: none !important;  }
.edit-btn:hover {transform: scale(1.1);}
    
    


/* V√§nsterkolumn */
.dock-left{ display: grid; gap: 10px; }

/* Tv√• rader f√§rger, ingen scroll beh√∂vs */
.palette-grid{
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: 70px;
  grid-template-rows: repeat(2, 70px);
  gap: 6px;
}

/* Swatches enhetliga */
.palette-grid .color-swatch{
  width: 69px !important; height: 69px !important;
  border-radius: 7px;
  box-shadow: none !important; outline: none !important;
}

/* Brush under paletten */
.brush-row{ display: grid; grid-template-columns: 1fr; align-items: center; gap: 6px;grid-template-columns: 1fr 1fr; gap:10px; }
#brushSizeSlider{ width: 320px; max-width: 56vw; }
/* H√∂gerkolumn: üé®-knappen */
.dock-right{ display: flex; align-items: center; }
.dock-right .tool-btn{ width: 44px; height: 44px; border-radius: 10px; }

/* Popover ‚Äì ta bort fixed top/right defaulten och kl√§m inom sk√§rmen */
.color-pop.hidden{ display:none }
.color-pop{
  position: fixed !important;
  inset: auto auto auto auto;       /* nollst√§lls ‚Äì vi s√§tter left/top via JS */
  z-index: 3000;
  background:#222; color:#fff; border:1px solid #444; border-radius:12px;
  box-shadow:0 8px 30px rgba(0,0,0,.35);
  max-width:min(420px, calc(100vw - 16px));
}
.color-pop-inner{ padding:12px; }
#rainbowCanvas{ cursor:crosshair; border-radius:8px; outline:0 !important; }


/* === SIDEBAR LAYOUT === */
#mainToolBar{
  position: fixed;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  display: grid;
  gap: 10px;
  padding: 10px;
  background: rgba(30,30,30,.9);
  border-radius: 16px;
  box-shadow: 0 10px 24px rgba(0,0,0,.35);
  z-index: 30;                  /* under color-editor (som kan ligga p√• 50) */
  touch-action: none;           /* undvik o√∂nskad scroll p√• mobil */
  contain: layout paint;        /* isolera layout/repaint */
}

/* Knappar */
#mainToolBar .tool-btn{
  width: 56px; height: 56px;
  display: grid; place-items: center;
  font-size: 26px; line-height: 1;
  background: #444; color: #fff;
  border: none; border-radius: 12px;
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.15);
  cursor: pointer; user-select: none;
  outline: none;
}
#mainToolBar .tool-btn:hover{ filter: brightness(1.1); }
#mainToolBar .tool-btn:active{ transform: scale(.98); }

/* Aktivt verktyg: dubbla ringar s√• det syns p√• m√∂rkt/ljust */
#mainToolBar .tool-btn.is-active{
  box-shadow:
    inset 0 0 0 2px #fff,
    0 0 0 2px rgba(0,0,0,.55);
  background: #555;
}

/* === Center Top Bar === */
#centerTopBar {
  position: fixed;
  top: 12px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 12px;
  background: rgba(30,30,30,.92);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 20px;
  padding: 8px 14px;
  box-shadow: 0 10px 26px rgba(0,0,0,.35);
  z-index: 2300;
  pointer-events: auto;
}

#centerTopBar .barbtn {
  min-width: 48px; height: 48px;
  display: flex; align-items: center; justify-content: center;
  background: transparent; color: #fff;
  border: none; border-radius: 14px;
  font-size: 16px; cursor: pointer;
  transition: background .15s ease, box-shadow .15s ease, transform .06s ease;
}
#centerTopBar .barbtn:hover,
#centerTopBar .barbtn:focus-visible {
  background: rgba(255,255,255,.08);
  box-shadow: 0 6px 16px rgba(0,0,0,.25);
}
#centerTopBar .barbtn:active { transform: translateY(1px); }

/* Mobil / touch: dubbelt s√• stor */
@media (pointer:coarse), (max-width:768px){
  #centerTopBar { padding: 12px 18px; border-radius: 26px; gap: 16px; }
  #centerTopBar .barbtn {
    min-width: 64px; height: 64px; font-size: 68px; border-radius: 18px;
  }
}
#copyBtn,
#pasteBtn,
#undoBtn,
#redoBtn {
  display: none !important;
}

.dropdown .item.active{
  background: rgba(255,255,255,.18);
  font-weight: 600;
}

/* === Mobile XL sizing overrides (sidebar, menyer, center-topbar) === */
@media (pointer:coarse), (max-width: 768px){
  /* Sidebar */
  #mainToolBar{
    gap: 14px;
    padding: 14px;
    border-radius: 20px;
  }
  #mainToolBar .tool-btn{
    width: 84px;
    height: 84px;
    font-size: 36px;         /* st√∂rre ikon/emoji */
    border-radius: 18px;
  }

  /* Top-knappar (hamburger / projects) */
  .topbtn{
    height: 84px;
    min-width: 84px;
    padding: 0 26px;
    border-radius: 20px;
    font-size: 18px;
  }
  .hamburger{ font-size: 34px; }

  /* Menyer / dropdowns (l√§ggs l√§ngre ner pga st√∂rre knappar) */
  .menu, .dropdown{
    top: 104px;             /* var 80px i din mobil-stil ‚Äì flytta ned lite extra */
    min-width: 340px;
    padding: 14px;
    border-radius: 18px;
  }
  .menu .item, .dropdown .item{
    padding: 20px 22px;
    font-size: 20px;
    border-radius: 16px;
  }

  /* Transform-dock (h√∂ger flytknapp + meny) */
  #transformBtn{
    width: 88px;
    height: 88px;
    font-size: 24px;
    border-radius: 9999px;
  }
  #transformMenu{
    top: 112px;             /* matcha st√∂rre knapp ovan */
    min-width: 340px;
    padding: 14px;
    border-radius: 20px;
  }
  #transformMenu .item{
    padding: 20px 22px;
    font-size: 20px;
    border-radius: 16px;
  }

  /* Center-Topbar (Copy/Paste/Undo/Redo) */
  #centerTopBar{
    padding: 14px 20px;
    border-radius: 28px;
    gap: 18px;
    
  }
  #centerTopBar .barbtn{
    min-width: 80px;
    height: 80px;
    font-size: 56px;
    border-radius: 20px;
  }
}
@media (pointer:coarse), (max-width: 768px){
  /* Flytta centerTopBar lite √•t h√∂ger + ge den mer luft */
  #centerTopBar{
    left: 58%;                   /* lite mer √•t h√∂ger */
    transform: translateX(-50%); /* beh√•ll "center" kring nya left */
    padding: 0px 0px;
    gap: 0px;
    border-radius: 28px;
    max-width: 96vw;             /* f√∂rs√§kring mot overflow */
    top:0px;
  }

  /* St√∂rre ikoner/knappar i topbar-center */
  #centerTopBar .barbtn{
    min-width: 106px;
    height: 106px;
    font-size: 102px;             /* st√∂rre emoji/ikon */
    border-radius: 22px;
  }
    #centerTopBar .barbtn{
    -webkit-tap-highlight-color: transparent; /* iOS/Android tap-glow */
    outline: none;
    touch-action: manipulation;               /* snabbare tap, ingen dbl-tap zoom */
  }
  /* √ñverstyr tidigare hover/focus-stilar p√• mobil */
  #centerTopBar .barbtn:hover,
  #centerTopBar .barbtn:focus,
  #centerTopBar .barbtn:focus-visible{
    background: transparent !important;
    box-shadow: none !important;
  }
  
}        

@media (orientation: landscape) and (pointer: coarse) {
  :root { --ls-scale: 0.3; }          /* finjustera 0.70‚Äì0.95 efter behov */

  /* Skala hela UI:t */
  #appWrapper{
    transform: scale(var(--ls-scale));
    transform-origin: top left;
    /* Kompensera s√• att ytan fortfarande fyller sk√§rmen efter skalning */
    width: calc(100% / var(--ls-scale));
    height: calc(100% / var(--ls-scale));
  }
}

/* Extra fallback f√∂r iOS som ibland rapporterar pointer:fine i Safari */
@media (orientation: landscape) and (max-device-width: 1024px) {
  :root { --ls-scale: 0.45; }
  #appWrapper{
    transform: scale(var(--ls-scale));
    transform-origin: top left;
    width: calc(100% / var(--ls-scale));
    height: calc(100% / var(--ls-scale));
  }
  #myCanvas{
    transform: scale(calc(1 / var(--ls-scale)));
    transform-origin: top left;
    width: calc(100vw * var(--ls-scale));
    height: calc(100dvh * var(--ls-scale));
  }
#bottomDock{
  position: absolute;
  left: 98%;
  transform: translateX(-98%);
  top: 25%;

  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto auto;   /* 1: palette, 2: edit-btn, 3: sliders */
  row-gap: 10px;

  max-width: min(260px, 96vw);
}

/* Viktigt: g√∂r barnen till DIREKTA grid-items */
#bottomDock .dock-left,
#bottomDock .dock-right{
  display: contents;
}

/* 1) Paletten √∂verst */
.palette-grid{
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: 70px;
  grid-template-rows: repeat(5, 70px);
  gap: 6px;
}

/* 2) Edit-color-knappen direkt under paletten */
#edit-color-btn{
  grid-row: 2;
  justify-self: stretch;
  height: 48px;
  border-radius: 10px;
}

/* 3) Sliders l√§ngst ned ‚Äì STAPLADE */
#bottomDock .brush-row{
  grid-row: 3;
  display: grid;
  grid-template-columns: 1fr;          /* en kolumn -> under varandra */
  gap: 8px;
}

/* Sliders fyller bredden */
#brushSizeSlider, #zoomSlider{
  width: 100%;
}

  
}

        </style>
</head>
<body>
<div id="appWrapper">    
    
<label for="directFileInput" style="position:absolute; top:10px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; min-width:90px; text-align:center; font-size:16px;">Open Image</label>
<input accept="image/*" id="directFileInput" style="position:absolute; left:-200px;" type="file"/>
<!-- Save Image button, positioned much lower -->
<button id="saveImageBtn" style="position:absolute; top:130px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:90px; text-align:center; font-size:16px;">Save Image</button>
<button id="project1Btn" style="position:absolute; top:150px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 1</button>
<button id="project2Btn" style="position:absolute; top:150px; left:100px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 2</button>
<button id="project3Btn" style="position:absolute; top:150px; left:202px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 3</button>
<button id="ResizeBtn" style="position: absolute;right: 0%; top:150px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Resize</button>
<div class="tool-buttons" style="position: absolute; left:500px; top: 30px; z-index: 110; display: grid; grid-template-columns: repeat(6, 100px); grid-gap: 5px; transform: translateY(-50%);">



<!-- Copy (action only) -->
<button class="tool-btn" id="copyBtn" title="Copy selection (Ctrl/Cmd+C)"
  style="width:60px;height:60px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="#333"/>
  </svg>
</button>
<!-- Paste (action only) -->
<button class="tool-btn" id="pasteBtn" title="Paste (Ctrl/Cmd+V)"
  style="width:60px;height:60px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <!-- clipboard + plus -->
    <path d="M16 2h-2.18C13.4.84 12.3 0 11 0S8.6.84 8.18 2H6c-1.1 0-2 .9-2 2v16c0 1.11.9 2 2 2h10c1.1 0 2-.89 2-2V4c0-1.1-.9-2-2-2zM11 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1z" fill="#333"/>
    <path d="M12 8v3H9v2h3v3h2v-3h3v-2h-3V8h-2z" fill="#333"/>
  </svg>
</button>


<button class="tool-btn" id="undoBtn" style="width:60px;height:60px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Undo (Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5v-3L7 7l5 5V9c3.31 0 6 2.69 6 6 0 .34-.03.67-.08 1h2.02c.04-.33.06-.66.06-1 0-4.42-3.58-8-8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="redoBtn" style="width:60px;height:60px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Redo (Ctrl/Cmd+Y, Shift+Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5V2l5 5-5 5V9c-3.31 0-6 2.69-6 6 0 .34.03.67.08 1H4.06A7.98 7.98 0 0 1 4 15c0-4.42 3.58-8 8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="gridBtn" style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Toggle Grid (G)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M3 3h18v18H3V3zm6 0v18M15 3v18M3 9h18M3 15h18" fill="none" stroke="#333" stroke-width="2"></path>
</svg>
</button>


<!-- Rotate Right 90¬∞ -->
<button class="tool-btn" id="rotateRightBtn" title="Rotate +90¬∞ (R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M15.55 5.55L11 1v3.07C6.05 4.56 2.5 8.54 2.5 13.5 2.5 18.47 6.53 22.5 11.5 22.5S20.5 18.47 20.5 13.5h-2
             c0 3.86-3.14 7-7 7s-7-3.14-7-7c0-3.58 2.65-6.53 6.1-6.96V9l4.45-3.45z" fill="#333"></path>
  </svg>
</button>

<!-- Rotate Left 90¬∞ -->
<button class="tool-btn" id="rotateLeftBtn" title="Rotate -90¬∞ (Shift+R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M8.45 5.55L13 1v3.07C17.95 4.56 21.5 8.54 21.5 13.5c0 4.97-4.03 9-9 9s-9-4.03-9-9h2
             c0 3.86 3.14 7 7 7s7-3.14 7-7c0-3.58-2.65-6.53-6.1-6.96V9L8.45 5.55z" fill="#333"></path>
  </svg>
</button>

<!-- Flip Horizontal -->
<button class="tool-btn" id="flipHBtn" title="Flip Horizontal (H)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M3 4h8v16H3zM13 4h8v16h-8z" fill="#333"/>
    <path d="M12 4v16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Flip Vertical -->
<button class="tool-btn" id="flipVBtn" title="Flip Vertical (V)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M4 3h16v8H4zM4 13h16v8H4z" fill="#333"/>
    <path d="M4 12h16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Free Rotate -->
<button class="tool-btn" id="rotateFreeBtn" title="Rotate Free‚Ä¶ (Ctrl+R)"
  style="width:40px;height:40px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M12 2a10 10 0 100 20 10 10 0 000-20z" fill="none" stroke="#333" stroke-width="2"/>
    <path d="M12 6v6l4 2" stroke="#333" stroke-width="2" fill="none"/>
  </svg>
</button>




</div>




<!-- Bottom Dock -->
<!-- Centered Bottom Dock -->
<div id="bottomDock" aria-label="Bottom dock controls">
  <div class="dock-left">
    <!-- 2 rader f√§rger -->
    <div class="palette-grid" id="dockPalette">
      <!-- Rad 1 -->
      <div class="color-swatch" data-color="black"  style="background:black;"></div>
      <div class="color-swatch" data-color="white"    style="background:white;"></div>
      <div class="color-swatch" data-color="blue"   style="background:blue;"></div>
      <div class="color-swatch" data-color="green"  style="background:green;"></div>
      <div class="color-swatch" data-color="yellow" style="background:yellow;"></div>
      <!-- Rad 2 -->
      <div class="color-swatch" data-color="cyan"   style="background:cyan;"></div>
      <div class="color-swatch" data-color="red"  style="background:red;"></div>
      <div class="color-swatch" data-color="purple" style="background:purple;"></div>
      <div class="color-swatch" data-color="orange" style="background:orange;"></div>
      <div class="color-swatch" data-color="checkerboard" style="background:repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%);"></div>
    </div>

    <!-- Kontroller under paletten: tv√• kolumner = Brush (v√§nster), Zoom (h√∂ger) -->
    <div class="brush-row">
      <div class="control-col" style="display:grid; gap:6px; align-items:center;">
        <label for="brushSizeSlider" id="brushSizeLabel">Brush Size: 1px</label>
        <input id="brushSizeSlider" type="range" min="1" max="10" step="1" value="1"
               style="width:100%;"/>
      </div>
      <div class="control-col" style="display:grid; gap:6px; align-items:center;">
        <label for="zoomSlider" id="zoomLabel">Zoom: 100%</label>
        <input id="zoomSlider" type="range" min="10" max="5000" value="100"
               style="width:100%;"/>
      </div>
    </div>
  </div>
  <!-- üé®-knapp till h√∂ger -->
  <div class="dock-right">
    <button id="edit-color-btn" class="edit-btn" type="button" title="Edit Color üé®"
            style="font-size:52px; width:56px; height:56px;">üé®</button>
  </div>
</div>

<!-- Flyttad/beh√•llen f√§rg-editor (popup) -->
<div id="color-editor" class="color-pop hidden" role="dialog" aria-modal="true" aria-label="Edit Color">
  <div class="color-pop-inner">
    <div class="row">
      <canvas id="rainbowCanvas" width="512" height="300"></canvas>
    </div>
    <label class="row" style="gap:.5rem;align-items:center">
      Ljushet
      <input id="lightnessSlider" type="range" min="0" max="100" value="100"/>
      <span id="lightnessVal">100%</span>
    </label>
    <div class="row" style="gap:1rem;align-items:center;margin-top:.5rem;display:flex;">
      <!-- tom flex-spacer f√∂rst -> allt hamnar h√∂ger -->
      
      <button id="colorCancel" class="btn-secondary" type="button">Cancel</button>
      <button id="colorApply"  class="btn-primary"   type="button">Save</button>
      <div style="flex:1"></div>
      <div id="colorPreview"></div>
      <!-- ta bort inline-styles s√• CSS nedan kan styra storlek/utseende -->
      <code id="hexOut">#FFFFFF</code>
      
    </div>
  </div>
</div>


<!-- === MAIN TOOL SIDEBAR === -->
<nav id="mainToolBar" aria-label="Main tools">
  <button class="tool-btn" id="tool-pen"        data-tool="pen"        title="Pen (B)"         aria-pressed="false" style="font-size:38px;">‚úèÔ∏è</button>
  <button class="tool-btn" id="tool-fill"       data-tool="fill"       title="Fill (G)"        aria-pressed="false" style="font-size:38px;">ü™£</button>
  <button class="tool-btn" id="tool-eyedropper" data-tool="eyedropper" title="Eyedropper (I)"  aria-pressed="false" style="font-size:38px;">üéØ</button>
  <button class="tool-btn" id="tool-text"       data-tool="text"       title="Text (T)"        aria-pressed="false" style="font-size:38px;">üî§</button>
  <button class="tool-btn" id="tool-select"     data-tool="select"     title="Select (V)"      aria-pressed="false" style="font-size:38px;">‚ñ£</button>
  <button class="tool-btn" id="tool-lasso"      data-tool="lasso"      title="Lasso (L)"       aria-pressed="false" style="font-size:38px;">ü™¢</button>
</nav>


<!-- === TOP BAR === -->
<div id="topBar" aria-label="Top toolbar">
  <!-- Hamburger (v√§nster) -->
  <div class="topbar-group" style="position:relative">
    <button id="hamburgerBtn" class="topbtn" aria-haspopup="true" aria-expanded="false" title="Menu">
      <span class="hamburger">‚ò∞</span> <span style="font-weight:600">Menu</span>
    </button>
    <div id="mainMenu" class="menu" role="menu" aria-label="Main menu">
      <button class="item" id="mnuOpen"  role="menuitem">Open image‚Ä¶</button>
      <button class="item" id="mnuSave"  role="menuitem">Save image</button>
      <hr style="border:0;height:1px;background:rgba(255,255,255,.12);margin:6px 2px;">
      <button class="item" id="mnuResize" role="menuitem">Resize canvas‚Ä¶</button>
      <button class="item" id="mnuGrid"   role="menuitem">Toggle grid</button>
    </div>
  </div>

  <!-- Projects direkt till v√§nster (bredvid hamburgern) -->
  <div class="topbar-group" style="position:relative">
    <button id="projectsBtn" class="topbtn" aria-haspopup="true" aria-expanded="false" title="Projects">
      Canvas 1 ‚ñæ
    </button>
    <div id="projectsDrop" class="dropdown" role="menu" aria-label="Projects">
      <button class="item" id="mnuProj1" role="menuitem">Canvas 1</button>
      <button class="item" id="mnuProj2" role="menuitem">Canvas 2</button>
      <button class="item" id="mnuProj3" role="menuitem">Canvas 3</button>
    </div>
  </div>
</div>

<div id="menuBackdrop" aria-hidden="true"></div>


<!-- Right-side Transform menu -->
<div id="transformDock" aria-label="Transform tools">
  <button id="transformBtn" title="Transform">‚ú•</button>
  <div id="transformMenu" role="menu" aria-label="Transform menu">
    <button class="item" id="trFlipH"  role="menuitem">Flip Horizontal</button>
    <button class="item" id="trFlipV"  role="menuitem">Flip Vertical</button>
    <hr style="border:0;height:1px;background:rgba(255,255,255,.12);margin:6px 2px;">
    <button class="item" id="trRotR"   role="menuitem">Rotate +90¬∞</button>
    <button class="item" id="trRotL"   role="menuitem">Rotate ‚àí90¬∞</button>
    <button class="item" id="trRotFree" role="menuitem">Rotate (free)‚Ä¶</button>
  </div>
</div>

<div id="centerTopBar" aria-label="Clipboard & history">
  <button id="barCopy"  class="barbtn" title="Copy" style="font-size:48px;">‚ßâ</button>
  <button id="barPaste" class="barbtn" title="Paste" style="font-size:48px;">üìã</button>
  <button id="barUndo"  class="barbtn" title="Undo" style="font-size:48px;">‚ü≤</button>
  <button id="barRedo"  class="barbtn" title="Redo" style="font-size:48px;">‚ü≥</button>
</div>

<!-- Resize Modal Dialog -->
<div class="modal" id="resizeModal">
<div class="modal-content">
<h3>Resize Canvas</h3>
<div class="form-group">
<label for="canvasWidth">Width (pixels):</label>
<input id="canvasWidth" min="10" type="number"/>
</div>
<div class="form-group">
<label for="canvasHeight">Height (pixels):</label>
<input id="canvasHeight" min="10" type="number"/>
</div>
<div class="button-row">
<button id="cancelResizeBtn">Cancel</button>
<button id="confirmResizeBtn">Resize</button>
</div>
</div>
</div>
<canvas height="10" id="myCanvas" style="border:0px solid black" width="10"></canvas>
</div>
    


 
<script>
(function(){
  // === Hj√§lpare: f√§rgkonvertering ===
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  function hsv2rgb(h, s, v){
    h = ((h%360)+360)%360; s=clamp(s,0,1); v=clamp(v,0,1);
    const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
    let r=0,g=0,b=0;
    if (h<60){r=c;g=x;} else if (h<120){r=x;g=c;}
    else if (h<180){g=c;b=x;} else if (h<240){g=x;b=c;}
    else if (h<300){r=x;b=c;} else {r=c;b=x;}
    return {r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255)};
  }
  function rgb2hex(r,g,b){
    return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('').toUpperCase();
  }
  function hex2rgb(hex){
    hex = hex.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const num = parseInt(hex,16);
    if (Number.isNaN(num) || hex.length!==6) return null;
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }
  function cssColorToRGB(str){
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.fillStyle = str; // l√•ter browsern parsa
    const d = ctx.fillStyle;
    // d blir i formatet #RRGGBB om det √§r giltigt
    return hex2rgb(d);
  }

  // === DOM-hj√§lpare: hitta aktiv palettknapp ===
  function getActiveSwatch(){
    // Anpassa vid behov: byt selektor om du anv√§nder andra klassnamn/attribut
    const btn = document.querySelector('.color-swatch.active');
    if (!btn) return null;
    // transparensdetekt
    const isTrans = btn.dataset.transparent === '1' ||
                    (btn.dataset.color || '').toLowerCase()==='transparent' ||
                    (getComputedStyle(btn).backgroundColor.includes('rgba(0, 0, 0, 0)'));
    return { el: btn, isTransparent: isTrans };
  }
  
  
  
  function getButtonColor(btn){
    // Prioritera data-color (hex), annars ber√§kna fr√•n computed style
    const data = btn.dataset.color;
    if (data && data !== 'transparent') {
      const rgb = hex2rgb(data) || cssColorToRGB(data);
      if (rgb) return rgb2hex(rgb.r,rgb.g,rgb.b);
    }
    const rgb = cssColorToRGB(getComputedStyle(btn).backgroundColor) || {r:255,g:255,b:255};
    return rgb2hex(rgb.r,rgb.g,rgb.b);
  }
  function setButtonColor(btn, hex){
    btn.dataset.color = hex;
    btn.style.background = hex;
    // ping till din app om du har central f√§rg:
    if (window.setCurrentColor) window.setCurrentColor(hex);
    document.dispatchEvent(new CustomEvent('palette:colorUpdated', {
      detail: { button: btn, color: hex }
    }));
  }

  // === UI-element ===
  const editBtn   = document.getElementById('edit-color-btn');
  const pop       = document.getElementById('color-editor');
  const canvas    = document.getElementById('rainbowCanvas');
  const ctx       = canvas.getContext('2d', { willReadFrequently:true });
  const slider    = document.getElementById('lightnessSlider');
  const sliderVal = document.getElementById('lightnessVal');
  const prevEl    = document.getElementById('colorPreview');
  const hexOut    = document.getElementById('hexOut');
  const btnCancel = document.getElementById('colorCancel');
  const btnApply  = document.getElementById('colorApply');
  
  let coloerpickeractive=false;
  
  // State f√∂r editorn
  let H = 0, S = 1, V = 1;      // Hue [0..360), Sat [0..1], Val [0..1]
  let startHex = '#FFFFFF';
  let targetBtn = null;

  function drawRainbow(){
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    let i = 0;
    for (let y=0;y<h;y++){
      const s = y/(h-1);
      for (let x=0;x<w;x++){
        const hdeg = (x/(w-1))*360;
        const {r,g,b} = hsv2rgb(hdeg, s, V);
        img.data[i++] = r;
        img.data[i++] = g;
        img.data[i++] = b;
        img.data[i++] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    // rita mark√∂r
    const mx = Math.round((H/360) * (w-1));
    const my = Math.round(S * (h-1));
    ctx.beginPath();
    ctx.arc(mx+0.5, my+0.5, 6, 0, Math.PI*2);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.stroke();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
  }

  function updatePreview(){
    const {r,g,b} = hsv2rgb(H, S, V);
    const hex = rgb2hex(r,g,b);
    prevEl.style.background = hex;
    hexOut.textContent = hex;
  }

  function openEditor(){
      
      if(coloerpickeractive===true){pop.classList.add('hidden');coloerpickeractive=false;return;}
      
    const active = getActiveSwatch();
    targetBtn = active ? active.el : null;

    // Hantera transparens: disabla knapp och visa tooltip
    if (!targetBtn || (active && active.isTransparent)) {
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
      return;
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }

    startHex = getButtonColor(targetBtn);

    // Initiera HSV fr√•n startHex (approx: g√• via canvas parse)
    const rgb = hex2rgb(startHex);
    // snabb rgb->hsv:
    (function toHSV(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0, s=max===0?0:d/max, v=max;
      if (d!==0){
        switch(max){
          case r: h=((g-b)/d)+(g<b?6:0); break;
          case g: h=((b-r)/d)+2; break;
          case b: h=((r-g)/d)+4; break;
        }
        h*=60;
      }
      H=h; S=s; V=v;
    })(rgb.r,rgb.g,rgb.b);

    slider.value = Math.round(V*100);
    sliderVal.textContent = slider.value + '%';
    
    coloerpickeractive=true;
    pop.classList.remove('hidden');
    drawRainbow();
    updatePreview();
  }

  function closeEditor(){
    coloerpickeractive=false;  
    pop.classList.add('hidden');
  }

  // === Events ===
  editBtn?.addEventListener('click', openEditor   );
  btnCancel?.addEventListener('click', closeEditor);

  btnApply?.addEventListener('click', ()=>{
    if (!targetBtn) return closeEditor();
    const {r,g,b} = hsv2rgb(H,S,V);
    const hex = rgb2hex(r,g,b);
    setButtonColor(targetBtn, hex);
    closeEditor();
  });

  // V (ljushet)
  slider?.addEventListener('input', ()=>{
    V = Number(slider.value)/100;
    sliderVal.textContent = slider.value + '%';
    drawRainbow();
    updatePreview();
  });

  // Pick i regnb√•gsrutan (H,S)
  function pickAt(evt){
    const rect = canvas.getBoundingClientRect();
    const x = clamp((evt.clientX || (evt.touches?.[0]?.clientX||0)) - rect.left, 0, rect.width-1);
    const y = clamp((evt.clientY || (evt.touches?.[0]?.clientY||0)) - rect.top, 0, rect.height-1);
    const rx = x/rect.width, ry = y/rect.height;
    H = rx * 360;
    S = ry;
    updatePreview();
    drawRainbow();
  }
  let dragging=false;
  canvas?.addEventListener('pointerdown', (e)=>{ dragging=true; canvas.setPointerCapture(e.pointerId); pickAt(e); });
  canvas?.addEventListener('pointermove', (e)=>{ if (dragging) pickAt(e); });
  window.addEventListener('pointerup', ()=>{ dragging=false; });

  // St√§ng p√• Escape/klick utanf√∂r
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeEditor(); });
  document.addEventListener('click', (e)=>{
    if (!pop.classList.contains('hidden') && !pop.contains(e.target) && e.target!==editBtn){
      closeEditor();
    }
  });

  // H√•ll edit-knappen i sync med aktiv palett
  document.addEventListener('click', ()=>{
    const active = getActiveSwatch();
    if (!active || active.isTransparent){
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }
  });

})();
</script>


<script>
            
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
    
            // Create an in-memory canvas to store our drawing
            const drawingCanvas = document.createElement('canvas');
            const drawingCtx = drawingCanvas.getContext('2d');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const eyedropperCanvas = document.createElement('canvas');
            const eyedropperCtx = eyedropperCanvas.getContext('2d');
            
            function updateEyedropperBuffer() {
                eyedropperCanvas.width = Math.floor(drawareax / zoom);
                eyedropperCanvas.height = Math.floor(drawareay / zoom);
                eyedropperCtx.drawImage(drawingCanvas, 0, 0);
            }
            
                        
                        
            const projectImages = [null, null, null];
            let currentproject=0;
            
            
            let undoMap = new Map();
            let redoMap = new Map();


            let undoStack = [];
            let redoStack = [];
       
            let lastPinchDistance = null;
            let canvasPools = new Map();
            let projectBitmaps = [null, null, null];     // ImageBitmap per projekt (RAM)
            let projectBlobURLs = [null, null, null];    // Fallback om bitmap inte g√•r
            let projectDirty = [false, false, false]; 
            function markDirty(){ projectDirty[currentproject] = true; }
            // Function to save the current drawing to the selected project
            async function saveCurrentProject(index) {
                // Spara vy/zoom mm som innan
                projectdrawareax[index] = drawareax;
                projectdrawareay[index] = drawareay;
                projectdrawstartx[index] = drawstartx;
                projectdrawstarty[index] = drawstarty;
                projectzoom[index] = zoom;

                if (!projectDirty[index]) return; // ingenting att spara

                // Rensa tidigare cache
                if (projectBitmaps[index] && projectBitmaps[index].close) {
                  projectBitmaps[index].close();
                }
                if (projectBlobURLs[index]) {
                  URL.revokeObjectURL(projectBlobURLs[index]);
                  projectBlobURLs[index] = null;
                }

                try {
                  // Snabbaste v√§gen: ImageBitmap (ingen PNG-encode)
                  projectBitmaps[index] = await createImageBitmap(drawingCanvas);
                } catch (e) {
                  // Fallback: Blob (asynk) + object URL
                  const blob = await new Promise(res => drawingCanvas.toBlob(res, 'image/png'));
                  projectBlobURLs[index] = URL.createObjectURL(blob);
                  projectBitmaps[index] = null;
                }

                projectDirty[index] = false;
              }
            
            // Function to load the selected project image into the drawing canvas
            async function loadProject(index) {
            // Spara undo/redo-mapparna som du redan g√∂r

            // 1) Spara *bara* om nuvarande projekt √§r dirty
            await saveCurrentProject(currentproject);

            // 2) V√§xla aktivt projekt (l√§ge/zoom m.m.)
            currentproject = index;
            drawareax   = projectdrawareax[index] ?? drawareax;
            drawareay   = projectdrawareay[index] ?? drawareay;
            drawstartx  = projectdrawstartx[index] ?? drawstartx;
            drawstarty  = projectdrawstarty[index] ?? drawstarty;
            zoom        = projectzoom[index] ?? zoom;

            const zoomvalue = Math.round(zoom * 100);
            document.getElementById("zoomSlider").value = zoomvalue;
            document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";

            // 3) Rita tillbaka fr√•n snabb-cache (bitmap) eller blob-URL
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            if (projectBitmaps[index]) {
              drawingCtx.drawImage(projectBitmaps[index], 0, 0);
            } else if (projectBlobURLs[index]) {
              const img = new Image();
              img.onload = () => drawingCtx.drawImage(img, 0, 0);
              img.src = projectBlobURLs[index];
            } else {
              // Nytt tomt projekt: fyll vitt (som du g√∂r vid init)
              drawingCtx.fillStyle = "white";
              drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }

            // Nytt projekt startar "clean"
            projectDirty[index] = false;
          }
            document.getElementById('project1Btn').addEventListener('click', () => loadProject(0));
            document.getElementById('project2Btn').addEventListener('click', () => loadProject(1));
            document.getElementById('project3Btn').addEventListener('click', () => loadProject(2));
            
            document.getElementById('ResizeBtn').addEventListener('click', () => resizecanvas());
            
            
            const resizeModal = document.getElementById('resizeModal');
            const widthInput = document.getElementById('canvasWidth');
            const heightInput = document.getElementById('canvasHeight');
            const confirmResizeBtn = document.getElementById('confirmResizeBtn');
            const cancelResizeBtn = document.getElementById('cancelResizeBtn');
            
            function resizecanvas(){
                
                
                widthInput.value = Math.round(drawareax/zoom) ;
               heightInput.value = Math.round(drawareay/zoom);
               
        
            // Show the modal
             resizeModal.style.display = 'block';
                
            }
            cancelResizeBtn.addEventListener('click', function() {
                resizeModal.style.display = 'none';
            });
      
            // Confirm resize button event
confirmResizeBtn.addEventListener('click', async function() {
    let newWidth = parseInt(widthInput.value);
    let newHeight = parseInt(heightInput.value);

    // Validate dimensions
    
    if (isNaN(newWidth) || newWidth < 1 || isNaN(newHeight) || newHeight < 1 || newWidth>drawingCanvas.width||newHeight>drawingCanvas.height) {
        alert('Invalid dimensions');
        return;
    }

    // Create a snapshot of the current canvas content
    const snapshot = createCanvasSnapshot(drawingCanvas.width, drawingCanvas.height);

    // Create an offscreen canvas for resizing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = newWidth;
    offscreenCanvas.height = newHeight;

    // Draw the snapshot onto the offscreen canvas
    offscreenCtx.drawImage(snapshot, 0, 0, drawareax/zoom,drawareay/zoom, 0, 0, newWidth, newHeight);

    // Clear the drawing context
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    disableSmoothing(drawingCtx);

    // Draw the resized image onto the main canvas
    drawingCtx.drawImage(offscreenCanvas, 0, 0);

    // Update drawing area dimensions
     

                    // Reset zoom to 1 after resizing
                    let newZoom = zoom; // Start with current zoom
                    if (newWidth * newZoom > window.innerWidth * 0.8 || 
                        newHeight * newZoom > (window.innerHeight - 100) * 0.8) {
                        // Image is too large at current zoom, recalculate
                        const zoomX = Math.round(((window.innerWidth * 0.8) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.8) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                    }
                    else if(((newWidth * newZoom < window.innerWidth * 0.5 ||newHeight * newZoom < (window.innerHeight - 100) * 0.5 ))){
                        
     
                        const zoomX = Math.round(((window.innerWidth * 0.5) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.5) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                        
                        
                        
                    }
                    
                    
                    zoom = newZoom;
                    zoomvalue = Math.round(newZoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";

    // Center the drawing area
    drawareax = newWidth*zoom; 
    drawareay = newHeight*zoom;
    
    drawstartx = (canvas.width / devicePixelRatio - drawareax) / 2;
    drawstarty = (canvas.height / devicePixelRatio - drawareay) / 2;

    // Close the modal
    resizeModal.style.display = 'none';
});
            function createCanvasSnapshot(width,height) {
                const offscreen = document.createElement('canvas');
                offscreen.width = width;
                offscreen.height = height;
                const offCtx = offscreen.getContext('2d');
                disableSmoothing(offCtx);
                
                offCtx.drawImage(drawingCanvas, 0, 0,width,height);
                return offscreen;
            }

            
            
            
            
              document.addEventListener('DOMContentLoaded', function() {
            // Get all color swatches
            const swatches = document.querySelectorAll('.color-swatch');

            // Add click event handlers
            swatches.forEach(swatch => {
            swatch.addEventListener('click', function() {
              swatches.forEach(s => s.classList.remove('active'));
              this.classList.add('active');
              brushColor = this.getAttribute('data-color');
              isTransparentBrush = brushColor === "checkerboard";
            });
          });

            // Set black as the initial active color
            const blackSwatch = document.querySelector('[data-color="black"]');
            if (blackSwatch) {
              blackSwatch.classList.add('active');
            }
          });
            document.addEventListener('DOMContentLoaded', function() {
                // Adjust color palette position for mobile
                function adjustColorPalettePosition() {
                  const colorPalette = document.querySelector('.color-palette');
                  if (colorPalette) {
                    if (mobileAndTabletCheck()) {
                      colorPalette.style.top = '0px'; // 8px lower for mobile
                      colorPalette.style.transform = 'none'; // Remove vertical centering transform
                    } else {
                      colorPalette.style.top = '50px'; // Original position for desktop
                      colorPalette.style.transform = 'translateY(-50%)'; // Original transform
                    }
                  }
                }

                // Call initially
                adjustColorPalettePosition();

                // Also call when window is resized
                window.addEventListener('resize', adjustColorPalettePosition);
              });
            
            function mobileAndTabletCheck() {
               const isMobile = {
                    Android: function() {
                        return navigator.userAgent.match(/Android/i);
                    },
                    BlackBerry: function() {
                        return navigator.userAgent.match(/BlackBerry/i);
                    },
                    iOS: function() {
                        return navigator.userAgent.match(/iPhone|iPod/i);
                    },
                    Opera: function() {
                        return navigator.userAgent.match(/Opera Mini/i);
                    },
                    Windows: function() {
                        return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
                    },
                    any: function() {
                        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));
                    }
                };
           
                return isMobile.any();
            }
            function quantizeValue(value, quantum) {
    return Math.round(value / quantum) * quantum;
}
            // Function to return scrollbar thickness based on mobile status
            function getScrollbarThickness() {
                return mobileAndTabletCheck() ? 60 : 30;
            }
            
            if(mobileAndTabletCheck()){
 
                drawingCanvas.width = 4000;
                drawingCanvas.height = 4000;
                tempCanvas.width = 4000;
                tempCanvas.height = 4000;
                
                
            }
            else{
                drawingCanvas.width = 10000;
                drawingCanvas.height = 10000;
                tempCanvas.width = 10000;
                tempCanvas.height = 10000;
            }
            
            // Fill the drawing canvas with white initially
            drawingCtx.fillStyle = "white";
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // Disable image smoothing for crisp pixels
            function disableSmoothing(context) {
                context.imageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.msImageSmoothingEnabled = false;
            }
            
            disableSmoothing(ctx);
            disableSmoothing(drawingCtx);
            disableSmoothing(tempCtx);
    
            let drawareax = 640;
            let drawareay = 640;
            let drawstartx = 1000;
            let drawstarty = 1000;
            let startan = false;
            
            let movecorners1 = false;
            let movecorners2 = false;
            let movecorners3 = false;
            let movecorners4 = false;
            let movescrollx = false;
            let movescrollxvalue = 0;
            let savescrollxvalue = 0;
            let isposetive = false;
            let isdirposetive = 0;
            let x = 0;
            let y = 0;
            let zoomvalue = 100;
            let zoom = 1;
            let scrollx = 0;
            let scrolly = 0;
            let movescrollyvalue = 0;
            let movescrolly = false;
            let savescrollyvalue = 0;
            
            let isposetivey = false;
            let isdirposetivey = 0;
            
            // Variables for drawing
            let isDrawing = false;
            let brushSize = 1; // Default brush size
            let brushColor = "black"; // Default brush color
            
            // Function to draw at a specific point with pixel perfect precision
            let lastX = 0;
            let lastY = 0;
            
            // Variables to track drag start position
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Original content area in pixel units (not screen units)
            let originalContentX = 0;
            let originalContentY = 0;
            let originalContentWidth = drawareax;
            let originalContentHeight = drawareay;
            
            // Constants to address the edge pixel issue
            const EDGE_BUFFER = 2; // Add 2 extra pixels for drawing
            
            // Flag to track if an image has already been loaded
            let firstImageLoaded1 = false;
            let firstImageLoaded2 = false;
            let firstImageLoaded3 = false;
            
            // Track content dimensions for the first image
            let firstImageWidth = 0;
            let firstImageHeight = 0;
            let isImageWaiting = false;   // Image is loaded, waiting for first click
            let isMovingImage = false; 
            
            // **************** NEW VARIABLES FOR IMAGE LAYER ****************
            let currentImage = null;
            let currentImageX = 0;
            let currentImageY = 0;
            let currentImageWidth = 0;
            let currentImageHeight = 0;
            let currentImageOriginalWidth = 0;
            let currentImageOriginalHeight = 0;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            // ******************************************************************
            let lastTapTime = 0;
            let lastTapCorner = 0; 
            const doubleTapThreshold = 300; 
            let isTransparentBrush = false;
            let prevDrawAreaX, prevDrawAreaY, prevDrawStartX, prevDrawStartY, prevZoom;
            let currentTool = 'pen';      // Default tool
            let isSelecting = false;      // Track selection state
            let selectionStartX = 0;      // Selection coordinates
            let selectionStartY = 0;
            let selectionEndX = 0;
            let selectionEndY = 0;
            let selectionNeedsClick = false; 
            let isInteractingWithToolbar = false;
            
            let projectdrawareax = [drawareax, drawareax, drawareax];
            let projectdrawareay = [drawareay, drawareay, drawareay];
            let projectdrawstartx = [drawstartx, drawstartx, drawstartx];
            let projectdrawstarty = [drawstarty, drawstarty, drawstarty];
            let projectzoom = [zoomvalue, zoomvalue, zoomvalue];
            
            
            let prevzoom=1;
            let selLeft = 0;
            let selTop =0;
            let selWidth = 0;
            let selHeight =0;
            let isTextToolActive = false;
            let currentImagecanvas=currentproject;
            let showGrid = false;
            // Event listener for zoom slider
            document.getElementById("zoomSlider").addEventListener("input", (e) => {
                e.preventDefault();
                zoomvalue = Number(e.target.value);
                document.getElementById("zoomLabel").innerText = "Zoom: " + e.target.value + "%";
            });
            
            // Event listener for brush size slider
            document.getElementById("brushSizeSlider").addEventListener("input", (e) => {
                e.preventDefault();
                const sliderVal = Number(e.target.value);
                brushSize = sliderVal * sliderVal;
                document.getElementById("brushSizeLabel").innerText = "Brush Size: " + brushSize + "px";
            });
            
            const toolButtons = document.querySelectorAll('.tool-btn');

// Add pointer event listeners to each tool button
toolButtons.forEach(button => {
    button.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});

// Get the save and open buttons
const saveBtn = document.getElementById('saveImageBtn');
const openLabel = document.querySelector('label[for="directFileInput"]');

// Add pointer event listeners to the save and open buttons
if (saveBtn) {
    saveBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

if (openLabel) {
    openLabel.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

// Get all color swatches
const colorSwatches = document.querySelectorAll('.color-swatch');

// Add pointer event listeners to each color swatch
colorSwatches.forEach(swatch => {
    swatch.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});
            
            
            
            function applyCanvasTransform(shouldRound) {
                // Create stable integer positions for drawing
                let renderX = Math.floor(drawstartx);
                let renderY = Math.floor(drawstarty);
                let renderW = Math.ceil(drawareax);
                let renderH = Math.ceil(drawareay);

                // Calculate display dimensions precisely
                const displayWidth = Math.floor(renderW / zoom);
                const displayHeight = Math.floor(renderH / zoom);

                // Draw using transformation matrix
                ctx.save();
                ctx.translate(renderX, renderY);
                ctx.scale(zoom, zoom);
                ctx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0, 0, displayWidth, displayHeight);
                ctx.restore();

                return { displayWidth, displayHeight, renderX, renderY, renderW, renderH };
            }
function floodFill(startX, startY) {
    console.log("Filling at", startX, startY);

    if (startX < 0 || startY < 0 ||
        startX >= drawingCanvas.width ||
        startY >= drawingCanvas.height) {
        return;
    }

    const targetData = drawingCtx.getImageData(startX, startY, 1, 1).data;
    const targetR = targetData[0];
    const targetG = targetData[1];
    const targetB = targetData[2];
    const targetA = targetData[3];

    let fillR = 0, fillG = 0, fillB = 0, fillA = 255;
    if (brushColor === "checkerboard") {
        fillR = fillG = fillB = 0;
        fillA = 1;
    } else if (brushColor.startsWith('#')) {
        fillR = parseInt(brushColor.slice(1, 3), 16);
        fillG = parseInt(brushColor.slice(3, 5), 16);
        fillB = parseInt(brushColor.slice(5, 7), 16);
    } else {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = brushColor;
        tempCtx.fillRect(0, 0, 1, 1);
        const fillData = tempCtx.getImageData(0, 0, 1, 1).data;
        fillR = fillData[0];
        fillG = fillData[1];
        fillB = fillData[2];
        fillA = fillData[3];
    }

    // Undvik att fylla om f√§rgen redan √§r samma
    const tolerance = 10;
    if (Math.abs(targetR - fillR) <= 2 &&
        Math.abs(targetG - fillG) <= 2 &&
        Math.abs(targetB - fillB) <= 2 &&
        Math.abs(targetA - fillA) <= 2) {
        return;
    }

    const chunkSize = 1024;
    const chunkX = Math.max(0, startX - chunkSize / 2);
    const chunkY = Math.max(0, startY - chunkSize / 2);
    const chunkWidth = Math.min(chunkSize, drawingCanvas.width - chunkX);
    const chunkHeight = Math.min(chunkSize, drawingCanvas.height - chunkY);

    const imageData = drawingCtx.getImageData(chunkX, chunkY, chunkWidth, chunkHeight);
    const data = imageData.data;

    const visited = new Uint8Array(chunkWidth * chunkHeight);
    const maxStack = chunkWidth * chunkHeight * 2;
    const stack = new Uint32Array(maxStack);
    let stackLen = 0;

    const localX = startX - chunkX;
    const localY = startY - chunkY;

    stack[stackLen++] = localX;
    stack[stackLen++] = localY;

    function matchesTarget(x, y) {
        const idx = (y * chunkWidth + x) * 4;
        return (
            Math.abs(data[idx]     - targetR) <= tolerance &&
            Math.abs(data[idx + 1] - targetG) <= tolerance &&
            Math.abs(data[idx + 2] - targetB) <= tolerance &&
            Math.abs(data[idx + 3] - targetA) <= tolerance
        );
    }

    function setPixel(x, y) {
        const idx = (y * chunkWidth + x) * 4;
        data[idx]     = fillR;
        data[idx + 1] = fillG;
        data[idx + 2] = fillB;
        data[idx + 3] = fillA;
        visited[y * chunkWidth + x] = 1;
    }

    console.time("Fill");

    while (stackLen > 0) {
        const y = stack[--stackLen];
        const x = stack[--stackLen];

        if (x < 0 || y < 0 || x >= chunkWidth || y >= chunkHeight) continue;
        if (visited[y * chunkWidth + x]) continue;
        if (!matchesTarget(x, y)) continue;

        setPixel(x, y);

        stack[stackLen++] = x - 1; stack[stackLen++] = y;
        stack[stackLen++] = x + 1; stack[stackLen++] = y;
        stack[stackLen++] = x;     stack[stackLen++] = y - 1;
        stack[stackLen++] = x;     stack[stackLen++] = y + 1;
    }

    console.timeEnd("Fill");

    const offscreen = document.createElement('canvas');
    offscreen.width = chunkWidth;
    offscreen.height = chunkHeight;
    const offCtx = offscreen.getContext('2d');
    offCtx.putImageData(imageData, 0, 0);

    drawingCtx.clearRect(chunkX, chunkY, chunkWidth, chunkHeight);
    drawingCtx.drawImage(offscreen, chunkX, chunkY);
}

// Helper function to get pixel color
function getPixelColor(x, y) {
    if (x < 0 || y < 0 || x >= drawingCanvas.width || y >= drawingCanvas.height) {
        return 'rgba(0,0,0,0)';
    }
    
    const data = drawingCtx.getImageData(x, y, 1, 1).data;
    return `rgba(${data[0]},${data[1]},${data[2]},${data[3]/255})`;
}
function drawText(x, y, text) {
  // 1) Sk√§rm -> bildkoordinater
  const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : (window.zoom || 1);
  const relativeX = Math.floor((x - drawstartx) / z);
  const relativeY = Math.floor((y - drawstarty) / z);

  // Anv√§nd din nuvarande storlekslogik (√§ndra till "brushSize" rakt av om du vill)
  const fontSize = Math.max(1, Math.round((brushSize * 4) + 10));
  const fontStack = `${fontSize}px Arial, Helvetica, sans-serif`;

  // 2) M√§t f√∂rst p√• en tempor√§r context
  const measureCanvas = document.createElement('canvas');
  const mctx = measureCanvas.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(mctx);
  mctx.font = fontStack;
  // M√§tningar (med safaris√§kra fallbacks)
  const m = mctx.measureText(text);
  const ascent  = Math.ceil(m.actualBoundingBoxAscent  ?? m.fontBoundingBoxAscent  ?? fontSize * 0.8);
  const descent = Math.ceil(m.actualBoundingBoxDescent ?? m.fontBoundingBoxDescent ?? fontSize * 0.2);
  const pad = 2; // litet s√§kerhetsmarginal f√∂r Safari/iOS
  const w = Math.max(1, Math.ceil(m.width)) + pad * 2;
  const h = ascent + descent + pad * 2;

  // 3) Bygg canvasen i r√§tt storlek och rita texten med 'alphabetic' baseline
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  let tctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(tctx);
  tctx.font = fontStack;
  tctx.textAlign = 'left';
  tctx.textBaseline = 'alphabetic';
  tctx.fillStyle = brushColor;
  tctx.fillText(text, pad, pad + ascent);

  // 4) Koppla in i nya select-fl√∂det
  if (typeof clearSelection === 'function') clearSelection();
  selectionImageCanvas = c;
  selectionBBox = { x: relativeX, y: relativeY, w, h }; // anv√§nd faktiska canvasm√•tten inkl. pad

  if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

  hasSelection        = true;
  selSessionActive    = true;
  selectionSrcCanvas  = selectionImageCanvas;
  selectionHoleBBox   = null;
  selectionHoleCut    = true;
  if (typeof startSelectionSession === 'function') startSelectionSession();
  selErasedOnce = true;

  switchTool('select');

}


function roundToFullPixels(value) {
    return Math.round(value);
}

// Helper to check if two colors match
function colorsMatch(colorData, cssColor) {
    // Parse CSS color
    let targetR, targetG, targetB, targetA;
    
    if (cssColor.startsWith('rgba')) {
        const parts = cssColor.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = Math.round(parseFloat(parts[4]) * 255);
    } else if (cssColor.startsWith('rgb')) {
        const parts = cssColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = 255;
    } else {
        // For other formats, we need a different approach
        return false;
    }
    
    // Compare with small tolerance for floating point errors
    return Math.abs(colorData[0] - targetR) <= 2 && 
           Math.abs(colorData[1] - targetG) <= 2 && 
           Math.abs(colorData[2] - targetB) <= 2 && 
           Math.abs(colorData[3] - targetA) <= 2;
}

// Helper to set pixel color in ImageData
function setPixelInImageData(imageData, x, y, color) {
    const idx = (y * imageData.width + x) * 4;
    
    // Handle different color formats
    if (color.startsWith('#')) {
        // Hex color
        imageData.data[idx] = parseInt(color.substring(1, 3), 16);
        imageData.data[idx + 1] = parseInt(color.substring(3, 5), 16);
        imageData.data[idx + 2] = parseInt(color.substring(5, 7), 16);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else if (color.startsWith('rgba')) {
        // RGBA color
        const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = Math.round(parseFloat(parts[4]) * 255);
    } else if (color.startsWith('rgb')) {
        // RGB color
        const parts = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else {
        // Named colors or other formats
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = color;
        tempCtx.fillRect(0, 0, 1, 1);
        const colorData = tempCtx.getImageData(0, 0, 1, 1).data;
        
        imageData.data[idx] = colorData[0];
        imageData.data[idx + 1] = colorData[1];
        imageData.data[idx + 2] = colorData[2];
        imageData.data[idx + 3] = colorData[3];
    }
}
function switchTool(newTool, opts = {}) {
  // 1) S√§tt aktivt verktyg
  const prevTool = currentTool;
  currentTool = newTool;
  // 2) UI-knappar (l√§gg till lasso h√§r!)
  const toolButtons = {
    pen:        document.getElementById('penTool'),
    fill:       document.getElementById('fillTool'),
    select:     document.getElementById('selectTool'),
    eyedropper: document.getElementById('eyedropperTool'),
    text:       document.getElementById('textTool'),
    lasso:      document.getElementById('lassoTool') // ‚Üê NY
  };

  Object.keys(toolButtons).forEach(tool => {
    const btn = toolButtons[tool];
    if (!btn) return;
    if (tool === currentTool) {
      btn.style.backgroundColor = '#d4ffd4';
      btn.style.borderColor = '#4CAF50';
    } else {
      btn.style.backgroundColor = '#f1f1f1';
      btn.style.borderColor = '#ccc';
    }
  });

  // 3) Avsluta p√•g√•ende lasso-drag n√§r vi l√§mnar lasso-verktyget
  if (newTool !== 'lasso') {
    if (typeof isLassoActive !== 'undefined') isLassoActive = false;
    // Rensa markering helt bara om man vill
    if (opts.clearSelection === true && typeof clearSelection === 'function') {
      clearSelection();
    }
  }

  // (valfritt) logg
  // console.log("Switched to tool:", newTool, "from", prevTool);
}        
            // Ensure the drawing canvas is big enough for the image
            function ensureCanvasSize(width, height) {
                // Resize the drawing canvas if the new dimensions are larger
                if (width > drawingCanvas.width || height > drawingCanvas.height) {
                    // Save current content
                    const oldContent = document.createElement('canvas');
                    oldContent.width = drawingCanvas.width;
                    oldContent.height = drawingCanvas.height;
                    const oldCtx = oldContent.getContext('2d');
                    oldCtx.drawImage(drawingCanvas, 0, 0);

                    // Resize the canvas
                    drawingCanvas.width = Math.max(width, drawingCanvas.width);
                    drawingCanvas.height = Math.max(height, drawingCanvas.height);

                    // Fill with white and restore content
                    drawingCtx.fillStyle = "white";
                    drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    drawingCtx.drawImage(oldContent, 0, 0);

                    // Ensure smooth rendering is disabled
                    disableSmoothing(drawingCtx);

                    // Also resize temp canvas
                    tempCanvas.width = drawingCanvas.width;
                    tempCanvas.height = drawingCanvas.height;
                    disableSmoothing(tempCtx);

                    console.log(`Canvas resized to ${drawingCanvas.width}x${drawingCanvas.height}`);
                }
            }
            
            // Event listener for image open button
     
     
            function drawBresenhamLine(x0, y0, x1, y1, size) {
                x0 = Math.floor(x0);
                y0 = Math.floor(y0);
                x1 = Math.floor(x1);
                y1 = Math.floor(y1);

                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = (x0 < x1) ? 1 : -1;
                const sy = (y0 < y1) ? 1 : -1;
                let err = dx - dy;

                const halfSize = Math.floor(size / 2);

                while (true) {
                    // Simplified: just draw one rectangle at each point
                    if (isTransparentBrush) {
                        drawingCtx.clearRect(x0 - halfSize, y0 - halfSize, size, size);
                    } else {
                        drawingCtx.fillRect(x0 - halfSize, y0 - halfSize, size, size);
                    }

                    if (x0 === x1 && y0 === y1) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x0 += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }
            function ensureIntDimension(value) {
                // Add a tiny bias (0.001) to prevent rounding down due to floating point errors
                return Math.round(value + 0.001);
            }
            
            
            // IMPROVED: Make sure we have accurate mouse coordinates
            function getCanvasMousePosition(event) {
                const rect = canvas.getBoundingClientRect();
               // const devicePixelRatio = window.devicePixelRatio || 1;
                
                // Calculate scales including the device pixel ratio
              //  const scaleX = canvas.width / (rect.width * devicePixelRatio);
             //   const scaleY = canvas.height / (rect.height * devicePixelRatio);
                
                // Get mouse coordinates relative to the canvas
               // const clientX = event.clientX - rect.left;
              //  const clientY = event.clientY - rect.top;
               
                return {
                 //   x: clientX * (canvas.width / rect.width),
                 //   y: clientY * (canvas.height / rect.height)
                    
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            }
            
            
         
    
            
            
            // IMPROVED: More accurate pixel drawing
            function drawPixel(x, y) {
                const relativeX = Math.floor((x - drawstartx) / zoom );
                const relativeY = Math.floor((y - drawstarty) / zoom );

                // Set the brush color
                if (!isTransparentBrush) {
                    drawingCtx.fillStyle = brushColor;
                }

                if (x >= drawstartx && x < drawstartx + drawareax &&
                    y >= drawstarty && y < drawstarty + drawareay) {

                    if(lastX === 0 && lastY === 0) {
                        lastX = relativeX; 
                        lastY = relativeY;

                        const halfSize = Math.floor(brushSize / 2);
                        if (isTransparentBrush) {
                            drawingCtx.clearRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        } else {
                            drawingCtx.fillRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        }
                    } else {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                        lastX = relativeX;
                        lastY = relativeY;
                    }
                } else {
                    if(lastX !== 0 && lastY !== 0) {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                    }
                    lastX = relativeX;
                    lastY = relativeY;
                }
            }
            
            // Initialize canvas size properly
            function resizeCanvas() {
                const devicePixelRatio = window.devicePixelRatio || 1;
                
                // Set the canvas size to match the display size
                canvas.width = window.innerWidth * devicePixelRatio;
                canvas.height = window.innerHeight * devicePixelRatio;
                
                // Scale the canvas CSS size to match the window
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                
                // Ensure the canvas renders crisply on high DPI displays
                ctx.scale(devicePixelRatio, devicePixelRatio);
                
                disableSmoothing(ctx);
            }
            
            window.addEventListener('resize', (event) => {
                // Store current state before resize
                prevDrawAreaX = drawareax;
                prevDrawAreaY = drawareay;
                prevDrawStartX = drawstartx;
                prevDrawStartY = drawstarty;
                prevZoom = zoom;

                // Update canvas size
                const oldDevicePixelRatio = window.devicePixelRatio || 1;
                resizeCanvas();

                // Preserve drawing content by copying to temporary canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(drawingCanvas, 0, 0);

                // CRITICAL: Do not change the drawing area dimensions during resize!
                // Just maintain position based on window size change
                const deltaWidth = window.innerWidth - (canvas.width / oldDevicePixelRatio);
                const deltaHeight = window.innerHeight - (canvas.height / oldDevicePixelRatio);

                // Maintain the same relative position
                if (drawareax > canvas.width|| drawareay > canvas.height) { // If zoomed in
                    // Do nothing to the dimensions - keep them exactly as they were
                    drawareax = prevDrawAreaX;
                    drawareay = prevDrawAreaY;

                    // Keep the canvas in the same relative position
                    drawstartx = prevDrawStartX;
                    drawstarty = prevDrawStartY;
                } else {
                    // Not zoomed in - center the canvas
                    const toolbarHeight = 155;
                    drawstartx = (window.innerWidth / 2) - (drawareax / 2);
                    drawstarty = Math.max(toolbarHeight, (window.innerHeight / 2) - (drawareay / 2));
                    movescrollxvalue = 0;
                    scrollx = 0;
                    movescrollyvalue = 0;
                    scrolly = 0;
                }

                // Restore drawing content
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.fillStyle = "white";
                drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCtx.drawImage(tempCanvas, 0, 0);

                // Reset background
                ctx.fillStyle = "lightgray";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);

                startan = true;
            });
            //NYTT----------------------------------------------------------------------------------
            // ======== LASSO + TRANSFORM STATE ========
let lassoPoints = [];
let isLassoActive = false;
let hasSelection = false;
let selectionBBox = null;         // {x,y,w,h} i canvas-pixelkoordinater (inte sk√§rm)
let selectionPath = null;         // Path2D f√∂r klippning
let selectionMaskCanvas = null;   // mask av markerat omr√•de
let selectionImageCanvas = null;  // utdraget pixelinneh√•ll f√∂r transform
let selectionPathCanvas = null; // overlay-path i sk√§rm-koordinater
let selectionPathImg = null; 
let selectionOrigBBox = null;
let selSessionActive = false;
let selectionSrcCanvas = null;   // immutabel k√§lla (originalpixlar)
let selectionHoleBBox = null;    // var originalet satt (rekt eller lasso-bbox)
let selectionHoleCut  = false;   // har vi skurit h√•let i basen √§n?
// --- Selection history arming ---
let startdragstuffx=0;
let startdragstuffy=0;

function clearSelection() {
  hasSelection = false;
  isLassoActive = false;
  selectionBBox = null;
  selectionPathCanvas = null;  // om du anv√§nder den
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
  selectionOrigBBox = null;
}

function _effectiveZoom(){ return (zoom > 10) ? (zoom/100) : zoom; }
function _canvasXYtoImageXY(cx, cy){
  const z=_effectiveZoom();
  return { x: Math.floor((cx - drawstartx)/z), y: Math.floor((cy - drawstarty)/z) };
}
function _eraseSelectionAt(ix, iy){
  if (!selectionMaskCanvas) return;
  beginAction();
  drawingCtx.save();
  drawingCtx.translate(ix, iy);
  drawingCtx.globalCompositeOperation = 'destination-out';
  drawingCtx.drawImage(selectionMaskCanvas, 0, 0);
  drawingCtx.restore();
  drawingCtx.globalCompositeOperation = 'source-over';

}

// Bygg en mask (svart) fr√•n alphat i selectionImageCanvas
function _rebuildMaskFromImageCanvas(){
  if (!selectionImageCanvas) return;
  const w = selectionImageCanvas.width;
  const h = selectionImageCanvas.height;
  const m = document.createElement('canvas');
  m.width = w; m.height = h;
  const mctx = m.getContext('2d'); disableSmoothing(mctx);

  // L√§gg in bilden, l√•t alpha styra var masken finns
  mctx.drawImage(selectionImageCanvas, 0, 0);
  mctx.globalCompositeOperation = 'source-in';
  mctx.fillStyle = '#000';           // mask = svart d√§r alpha > 0
  mctx.fillRect(0,0,w,h);
  mctx.globalCompositeOperation = 'source-over';
  _binarizeAndDilateMask(m, 1); // ‚Üê NYTT
  selectionMaskCanvas = m;
}

function _imageXYtoCanvasXY(ix, iy) {
  const z = _effectiveZoom();
  const x = drawstartx + ix * z;
  const y = drawstarty + iy * z;
  return {x, y};
}

function _mkPathFromPoints(pts) {
  const p = new Path2D();
  if (!pts.length) return p;
  p.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<pts.length;i++) p.lineTo(pts[i].x, pts[i].y);
  p.closePath();
  return p;
}

function _computeBBoxFromImagePts(ptsImg) {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const p of ptsImg) {
    if (p.x<minX) minX=p.x;
    if (p.y<minY) minY=p.y;
    if (p.x>maxX) maxX=p.x;
    if (p.y>maxY) maxY=p.y;
  }
  const x=minX, y=minY, w=Math.max(1, maxX-minX+1), h=Math.max(1, maxY-minY+1);
  return {x, y, w, h};
}

// Ritar lasso-overlay (p√• huvud-ctx)
function _drawLassoOverlay() {
  if (!isLassoActive || lassoPoints.length < 2) return;
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4,3]);
  ctx.beginPath();
  const p0 = lassoPoints[0];
  ctx.moveTo(p0.cx, p0.cy);
  for (let i = 1; i < lassoPoints.length; i++) ctx.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  ctx.stroke();
  ctx.restore();
}

// Ta ut markerat omr√•de till selectionImageCanvas + skapa mask
function _extractSelection() {
  if (!selectionBBox || !selectionPathImg) return;
  const { x, y, w, h } = selectionBBox;

  selectionImageCanvas = document.createElement('canvas');
  selectionImageCanvas.width = w;
  selectionImageCanvas.height = h;
  const sctx = selectionImageCanvas.getContext('2d');
  disableSmoothing(sctx);

  selectionMaskCanvas = document.createElement('canvas');
  selectionMaskCanvas.width = w;
  selectionMaskCanvas.height = h;
  const mctx = selectionMaskCanvas.getContext('2d');
  disableSmoothing(mctx);
  

  // Rita mask i bild-koordinater, translaterad s√• (x,y) blir (0,0)
  mctx.save();
  mctx.translate(-x, -y);
  mctx.fillStyle = '#000';
  mctx.fill(selectionPathImg);
  mctx.restore();
  _binarizeAndDilateMask(selectionMaskCanvas, 1);
  // Klipp originalbilden till masken
  sctx.drawImage(drawingCanvas, -x, -y);
  sctx.globalCompositeOperation = 'destination-in';
  sctx.drawImage(selectionMaskCanvas, 0, 0);
  sctx.globalCompositeOperation = 'source-over';
}

// Rensa originalpixlar endast inom masken
function _eraseSelectionFromDrawing() {
  const {x,y,w,h} = selectionBBox;
  drawingCtx.save();
  drawingCtx.translate(x, y);
  // skapa clip fr√•n mask
  const t = drawingCtx;
  t.globalCompositeOperation = 'destination-out';
  t.drawImage(selectionMaskCanvas, 0, 0);
  t.globalCompositeOperation = 'source-over';
  drawingCtx.restore();
}

// Klistra tillbaka (utan transform)
function _pasteSelectionAt(x, y) {
  drawingCtx.drawImage(selectionImageCanvas, x, y);
}

// === TRANSFORMER ===
function rotateSelection(deg) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg * Math.PI) / 180;
    let outW = w, outH = h;
    if (Math.abs(deg % 180) === 90) { outW = h; outH = w; }

    const out = document.createElement('canvas');
    out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();
    
    selectionSrcCanvas = selectionImageCanvas;
    
    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    return; // (commit sker n√§r sessionen avslutas)
  }

  // --- HELA BILDEN ---
  beginAction();  // <-- SAKNADES
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  // rotera dokumentytan (0..w,0..h) till out-canvas
  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  // rita endast dokumentytan (inte hela drawingCanvas)
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  // rensa gamla dokumentytan och skriv in roterade resultatet
  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);

  // uppdatera dokumentm√•tt + centrera vy om storleken √§ndrades
  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    // centrera
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }

  endAction();
}

function flipSelection(axis /* 'h'|'v' */) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox;
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const out = document.createElement('canvas');
    out.width = w; out.height = h;
    const octx = out.getContext('2d'); disableSmoothing(octx);

    const ax = (axis || 'h').toLowerCase();  // <-- normalisera
    octx.save();
    if (ax === 'h') { octx.translate(w, 0); octx.scale(-1, 1); }
    else            { octx.translate(0, h); octx.scale(1, -1); }
    octx.drawImage(selectionImageCanvas, 0, 0);
    octx.restore();

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();
    
    selectionSrcCanvas = selectionImageCanvas;
    
    // bbox of√∂r√§ndrad
    return;
  }

  // --- HELA BILDEN ---
  beginAction(); // <-- SAKNADES
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);

  const ax = (axis || 'h').toLowerCase();
  tctx.save();
  if (ax === 'h') { tctx.translate(w, 0); tctx.scale(-1, 1); }
  else            { tctx.translate(0, h); tctx.scale(1, -1); }
  // rita endast dokumentytan
  tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  tctx.restore();

  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);
  endAction();
}

// Fri rotation med grad-dialog
function rotateSelectionFree() {
  const val = prompt('Rotate degrees (e.g. 20 or -30):', '20');
  const deg = Number(val);
  if (!isFinite(deg)) return;
   
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg*Math.PI)/180;
    const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
    const outW = Math.ceil(w*cos + h*sin);
    const outH = Math.ceil(h*cos + w*sin);

    const out = document.createElement('canvas'); out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    // Uppdatera f√∂rhandsbild + mask
    selectionImageCanvas = out;
    if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

    // VIKTIGT: L√•t commit anv√§nda den roterade bufferten
    selectionSrcCanvas = selectionImageCanvas;

    // Centrera nya bbox runt gamla centrum (som i rotateSelection)
    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    
    return; // commit sker n√§r sessionen avslutas
  }

  // --- HELA BILDEN (fri vinkel) ---
  beginAction();
  const z = (zoom > 10 ? zoom/100 : zoom);
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  drawingCtx.drawImage(tmp, 0, 0);

  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }
  endAction();
}

// ======== TOOL SWITCH HOOKS ========
document.getElementById('lassoTool')?.addEventListener('click', ()=> switchTool('lasso'));
document.getElementById('rotateRightBtn')?.addEventListener('click', ()=> rotateSelection(90));
document.getElementById('rotateLeftBtn')?.addEventListener('click', ()=> rotateSelection(-90));
document.getElementById('flipHBtn')?.addEventListener('click', ()=> flipSelection('h'));
document.getElementById('flipVBtn')?.addEventListener('click', ()=> flipSelection('v'));
document.getElementById('rotateFreeBtn')?.addEventListener('click', ()=> rotateSelectionFree());
const _byId = (id) => document.getElementById(id);

const _copyEl  = _byId('copyBtn');
if (_copyEl) _copyEl.addEventListener('click', () => { copySelectionMobileFriendly(); });

const _pasteEl = _byId('pasteBtn');
if (_pasteEl) _pasteEl.addEventListener('click', () => { pasteFromClipboard(); });

// tangentbordsgenv√§gar: R=+90, Shift+R=-90, H=flipH, V=flipV, L=lasso, Ctrl+R=free
document.addEventListener('keydown', (e)=>{
   const mod = e.ctrlKey || e.metaKey;
   if (mod && e.key.toLowerCase() === 'c') { copySelection(); return; }  
   if (mod && e.key.toLowerCase() === 'v') {pasteFromClipboard();return;}
   if (e.ctrlKey && (e.key==='r' || e.key==='R')) { e.preventDefault(); rotateSelectionFree(); return; }
   if (e.key==='r' || e.key==='R') { e.preventDefault(); rotateSelection( e.shiftKey? -90 : +90 ); return; }
   if (e.key==='h' || e.key==='H') { e.preventDefault(); flipSelection('h'); return; }
   if (e.key==='v' || e.key==='V') { e.preventDefault(); flipSelection('v'); return; }
   if (e.key==='l' || e.key==='L') { e.preventDefault(); switchTool('lasso'); return; }
  
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') {
    if (selSessionActive) {
      commitSelectionSession();  // skriver in urklippet och avslutar
    } else {
      // ingen session: st√§ng bara ev. lasso-skiss/markering
      isLassoActive = false;
      hasSelection = false;
      selectionBBox = null;
      selectionPathCanvas = null;
      selectionPathImg = null;
      selectionImageCanvas = null;
      selectionMaskCanvas = null;
    }
  }
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Delete') {

      // ingen session: st√§ng bara ev. lasso-skiss/markering
        selSessionActive   = false;
        selectionSrcCanvas = null;
        selectionHoleBBox  = null;
        selectionHoleCut   = false;
        clearSelection();
          hasSelection = false;
        selSessionActive = false;
        isDraggingSelection = false;
        isResizingSelection = false;
        isTransformingSelection = false;

        selectionImageCanvas = null;
        selectionSrcCanvas   = null;
        selectionPathImg     = null;
        selectionPathCanvas  = null;
        selectionMask        = null;
        selectionOrigBBox    = null;
        selectionHoleBBox    = null;
        selectionHoleCut     = false;

        selectionBBox = null;
        dragSelX = 0; dragSelY = 0;
        
  }
});

// G√∂r switchTool medveten om lasso/selection
const _origSwitchTool = switchTool;
switchTool = function(newTool){
  _origSwitchTool(newTool);
  if (newTool !== 'lasso') {
    isLassoActive = false;
  }
};

let isDraggingSelection = false;
let dragSelX = 0,  dragSelY  = 0;       // aktuell ‚Äúoverlay‚Äù-position i bildpixlar
let dragOffsetIX = 0, dragOffsetIY = 0; // pekarens offset i bbox

let selErasedOnce    = false;           // originalplatsen raderad (en g√•ng)



function startSelectionSession() {
    startdragstuffx=selectionStartX;
    startdragstuffy=selectionStartY;
  if (!selSessionActive) {
    if (typeof beginAction === 'function') beginAction(); // snapshot f√∂r undo
    selSessionActive = true;
    selErasedOnce = false;
    
  }
}

function commitSelectionSession(){
  if (!selSessionActive || !selectionBBox) return;

  // 1) Se till att bara originalh√•let finns (om s√•dant existerar)
  if (!selectionHoleCut && selectionHoleBBox){
    _eraseSelectionAt(selectionHoleBBox.x, selectionHoleBBox.y);
    selectionHoleCut = true;
  }

  // NEW: till√•t commit √§ven utan selectionSrcCanvas
  const src = selectionSrcCanvas || selectionImageCanvas;
  if (!src) return;

  // 2) Baka in slutl√§get
  drawingCtx.save();
  if (typeof disableSmoothing==='function') disableSmoothing(drawingCtx);
  drawingCtx.drawImage(
    src, 0,0, src.width, src.height,
    selectionBBox.x, selectionBBox.y, selectionBBox.w, selectionBBox.h
  );
  drawingCtx.restore();
  if(startdragstuffx!==selectionStartX||startdragstuffy!==selectionStartY){destroyAction();}
  
  endAction();

  
  // 3) St√§da
  selSessionActive   = false;
  selectionSrcCanvas = null;
  selectionHoleBBox  = null;
  selectionHoleCut   = false;
  clearSelection();
    hasSelection = false;
  selSessionActive = false;
  isDraggingSelection = false;
  isResizingSelection = false;
  isTransformingSelection = false;

  selectionImageCanvas = null;
  selectionSrcCanvas   = null;
  selectionPathImg     = null;
  selectionPathCanvas  = null;
  selectionMask        = null;
  selectionOrigBBox    = null;
  selectionHoleBBox    = null;
  selectionHoleCut     = false;

  selectionBBox = null;
  dragSelX = 0; dragSelY = 0;
  
  
}
function _clearSelectionState(reason = '') {
  hasSelection = false;
  selSessionActive = false;
  isDraggingSelection = false;
  isResizingSelection = false;
  isTransformingSelection = false;

  selectionImageCanvas = null;
  selectionSrcCanvas   = null;
  selectionPathImg     = null;
  selectionPathCanvas  = null;
  selectionMask        = null;
  selectionOrigBBox    = null;
  selectionHoleBBox    = null;
  selectionHoleCut     = false;

  selectionBBox = null;
  dragSelX = 0; dragSelY = 0;
}
function cancelSelectionSession() {
  if (!selSessionActive) return;
  // √Öterst√§ll canvas om vi raderat original
  if (selErasedOnce && typeof undo === 'function') undo();
  // √•terst√§ll UI-state till startl√§get
  selSessionActive = false;
  selErasedOnce = false;
  isDraggingSelection = false;
  // hoppa tillbaka markeringen till startpunkt
  if (selectionBBox) { selectionBBox.x = dragStartX; selectionBBox.y = dragStartY; }
}
// ======== POINTER-HANTERING F√ñR LASSO ========

let isdragdrag=false;

canvas.addEventListener('pointerdown', (ev)=>{
    isdragdrag=true;
    markDirty();
  if (currentTool !== 'lasso') return;
  if(tapedTwice)return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig markering ‚Üí starta/mata p√• en flytt-session
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {







    startSelectionSession();

    // Radera originalomr√•det bara f√∂rsta g√•ngen
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);  // g√∂r h√•l en g√•ng
      selErasedOnce = true;
    }

    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }

if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }


  // Annars: b√∂rja NY lasso-kurva
  
  commitSelectionSession();  
    isLassoActive = true;
    hasSelection = false;
    selectionBBox = null;
    selectionPathCanvas = null;
    selectionPathImg = null;
    selectionImageCanvas = null;
    selectionMaskCanvas = null;

    lassoPoints = [];
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  
});

canvas.addEventListener('pointermove', (ev)=>{
  if (currentTool !== 'lasso') return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    let nx = pImg.x - dragOffsetIX;
    let ny = pImg.y - dragOffsetIY;
    //nx = Math.max(0, Math.min(nx, drawingCanvas.width  - selectionBBox.w));
   // ny = Math.max(0, Math.min(ny, drawingCanvas.height - selectionBBox.h));
    dragSelX = nx; dragSelY = ny;
    return;
  }

  if (!isLassoActive) return;
  const last = lassoPoints[lassoPoints.length-1];
  if (!last || last.ix !== pImg.x || last.iy !== pImg.y) {
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  }
});
//NUWUWUWUWW
function _finalizeLasso() {
  if (lassoPoints.length < 3) { isLassoActive = false; return; }

  // 1) Overlay-path i sk√§rm-koordinater (f√∂r att rita ‚Äúmarching ants‚Äù)
  const pCanvas = new Path2D();
  pCanvas.moveTo(lassoPoints[0].cx, lassoPoints[0].cy);
  for (let i = 1; i < lassoPoints.length; i++) pCanvas.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  pCanvas.closePath();
  selectionPathCanvas = pCanvas;

  // 2) Mask-path i bildens pixelkoordinater (detta anv√§nds n√§r vi extraherar pixlar)
  const pImg = new Path2D();
  pImg.moveTo(lassoPoints[0].ix, lassoPoints[0].iy);
  for (let i = 1; i < lassoPoints.length; i++) pImg.lineTo(lassoPoints[i].ix, lassoPoints[i].iy);
  pImg.closePath();
  selectionPathImg = pImg;

  // 3) BBox i bildens pixelkoordinater
  const ptsImg = lassoPoints.map(p => ({ x: p.ix, y: p.iy }));
  const bbox = _computeBBoxFromImagePts(ptsImg);
  selectionBBox = { x: bbox.x, y: bbox.y, w: bbox.w, h: bbox.h };
  selectionOrigBBox = { ...selectionBBox };
  _extractSelection();
  hasSelection = true;
  isLassoActive = false;
    selSessionActive   = true;
    selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
    selectionHoleBBox  = { ...selectionBBox };
        // NEW: sk√§r h√•let direkt s√• man ‚Äúser h√•let p√• en g√•ng‚Äù
    _eraseSelectionAt(selectionBBox.x, selectionBBox.y);
    selErasedOnce   = true;
    selectionHoleCut= true; // s√• commit inte f√∂rs√∂ker radera igen
}

canvas.addEventListener('pointerup', (ev)=>{
    isdragdrag=false;
    if(tapedTwice)return;
  if (currentTool !== 'lasso') return;
  if (ev.pointerType === 'touch') ev.preventDefault(); 
  
  if (typeof isResizingSelection !== 'undefined' && isResizingSelection) return;
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    // flytten ‚Äúg√§ller‚Äù visuellt: uppdatera bbox men skriv inte till canvas √§nnu
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }

  // f√§rdigritad lasso ‚Üí skapa markering + extrakt
  if (lassoPoints.length > 6) _finalizeLasso();
});

// H√∂gerklick = √•ngra drag (√•terst√§ll snapshot)
canvas.addEventListener('contextmenu', (e)=>{
  if (selSessionActive) {
    e.preventDefault();
    cancelSelectionSession();    // √•terst√§ll h√•let och positionen
  }
});

// √§ven dubbelklick ‚Üí st√§ng/avsluta
canvas.addEventListener('dblclick', (ev)=>{
  
  if (currentTool!=='lasso') return;
  commitSelectionSession();      
  clearSelection();
});

canvas.addEventListener("touchstart", tapHandler);

var tapedTwice = false;

function tapHandler(event) {
    if(!tapedTwice) {
        tapedTwice = true;
        setTimeout( function() { tapedTwice = false; }, 300 );
        return false;
    }
    event.preventDefault();
    if (selSessionActive) {
      commitSelectionSession();  // skriver in urklippet och avslutar
    } else {
      // ingen session: st√§ng bara ev. lasso-skiss/markering
      isLassoActive = false;
      hasSelection = false;
      selectionBBox = null;
      selectionPathCanvas = null;
      selectionPathImg = null;
      selectionImageCanvas = null;
      selectionMaskCanvas = null;
    }
 }



canvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  isLassoActive = false;
  if (isDraggingSelection) {
    // Avbryt flytt: bara l√§mna allt som innan drag-start
    isDraggingSelection = false;
    
    // (vi har inte skrivit till drawingCanvas under drag, s√• inget mer beh√∂vs)
  }
}); 
canvas.addEventListener('pointercancel', (ev)=>{
  if (currentTool !== 'lasso') return;
  // Avbryt drag, men rulla inte tillbaka (sessionen lever kvar)
  isDraggingSelection = false;
});
// Tr√∂ska bort halv-alfa ‚Üí 0/255
function _binarizeAlpha(canvas, threshold = 128) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const img = ctx.getImageData(0, 0, w, h);
  const data = img.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i+3] = (data[i+3] >= threshold ? 255 : 0);
  }
  ctx.putImageData(img, 0, 0);
}

// V√§x masken 1 px (mycket enkel 3√ó3-dilation p√• alfa)
// iterationer=1 r√§cker oftast; √∂ka om du fortfarande ser glipor.
function _dilateAlpha(canvas, iterations = 1) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h || iterations <= 0) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  for (let it=0; it<iterations; it++) {
    const src = ctx.getImageData(0, 0, w, h);
    const s = src.data;
    const dst = ctx.createImageData(w, h);
    const d = dst.data;

    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        let on = 0;
        // 8-grannar
        for (let dy=-1; dy<=1; dy++) {
          const yy = y+dy; if (yy<0 || yy>=h) continue;
          for (let dx=-1; dx<=1; dx++) {
            const xx = x+dx; if (xx<0 || xx>=w) continue;
            const ai = ((yy*w + xx) << 2) + 3;
            if (s[ai] >= 128) { on = 1; break; }
          }
          if (on) break;
        }
        const i = ((y*w + x) << 2);
        d[i]   = s[i];
        d[i+1] = s[i+1];
        d[i+2] = s[i+2];
        d[i+3] = on ? 255 : 0; // bara alfa spelar roll f√∂r masken
      }
    }
    ctx.putImageData(dst, 0, 0);
  }
}

// Kombinerad
function _binarizeAndDilateMask(maskCanvas, dilatePx = 1) {
  _binarizeAlpha(maskCanvas, 128);
  if (dilatePx > 0) _dilateAlpha(maskCanvas, dilatePx);
}
let resizeOccurred = false;
// === NYTT: helpers ===
function _effZ(){ return (zoom > 10 ? zoom/100 : zoom); }

// snapshot av dokumentytan (0..docW √ó 0..docH) ‚Äî inte hela drawingCanvas
function _snapshotDocArea(docW, docH){
  const c = document.createElement('canvas');
  c.width = docW; c.height = docH;
  const cctx = c.getContext('2d'); disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0,0, docW,docH, 0,0, docW,docH);
  return c;
}

// rita tillbaka utan f√∂rlust (oavsett riktning)
function blitNoLoss(tempCanvas, newW, newH, dx, dy, bgColor = 'transparent'){
  const oldW = tempCanvas.width, oldH = tempCanvas.height;

  const dstX = (dx>0 ? dx : 0) | 0;
  const dstY = (dy>0 ? dy : 0) | 0;
  const srcX = (dx<0 ? -dx : 0) | 0;
  const srcY = (dy<0 ? -dy : 0) | 0;

  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // 1) clearRect g√∂r ytan helt transparent
  drawingCtx.clearRect(0, 0, Math.max(oldW,newW), Math.max(oldH,newH));

  // 2) Fyll endast om du VILL ha en bakgrundsf√§rg
  if (bgColor && bgColor !== 'transparent') {
    drawingCtx.save();
    drawingCtx.fillStyle = bgColor; // t.ex. '#ffffff'
    drawingCtx.fillRect(0, 0, newW, newH);
    drawingCtx.restore();
  }

  // 3) Kopiera overlap (f√∂rlustfritt)
  if (copyW>0 && copyH>0){
    drawingCtx.drawImage(
      tempCanvas,
      srcX, srcY, copyW, copyH,
      dstX, dstY, copyW, copyH
    );
  }
}

// dx,dy beroende p√• vilket h√∂rn som dras ‚Äî bevara motsatt h√∂rn
function offsetForCorner(corner, oldW, oldH, newW, newH){
  switch((corner||'SE').toUpperCase()){
    case 'NW': return { dx: newW - oldW, dy: newH - oldH }; // botten-h√∂ger fast
    case 'NE': return { dx: 0,            dy: newH - oldH }; // botten-v√§nster fast
    case 'SW': return { dx: newW - oldW,  dy: 0            }; // toppen-h√∂ger fast
    case 'SE':
    default:   return { dx: 0,            dy: 0            }; // toppen-v√§nster fast
  }
}
// === NYTT: resize-session ===
// === state f√∂r resize ===
let rc_active = false;
let rc_corner = 'SE';
let rc_oldW = 0, rc_oldH = 0;     // dokumentm√•tt i bildpixlar
let rc_prevW = 0, rc_prevH = 0;   // preview-m√•tt i bildpixlar
let rc_baseStartX = 0, rc_baseStartY = 0; // drawstart vid start (sk√§rmpixlar)
let rc_snap = null;
let rc_anchorX=0, rc_anchorY=0, rc_anchorSet=false;
let rc_lastSW=0, rc_lastSH=0;

function _effZ(){ return (zoom > 10 ? zoom/100 : zoom); }
function sx2ix(sx){ const z=_effZ(); return Math.round((sx - rc_baseStartX) / z); }
function sy2iy(sy){ const z=_effZ(); return Math.round((sy - rc_baseStartY) / z); }

function _snapshotDocArea(w,h){
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const cctx = c.getContext('2d'); cctx.imageSmoothingEnabled = false;
  cctx.drawImage(drawingCanvas, 0,0, w,h, 0,0, w,h);
  return c;
}

function resizeStart(corner){
  if (rc_active) return;
  const z = _effZ();
  rc_corner = corner.toUpperCase();
  rc_oldW = Math.floor(drawareax / z);
  rc_oldH = Math.floor(drawareay / z);
  rc_prevW = rc_oldW;
  rc_prevH = rc_oldH;
  rc_baseStartX = Math.round(drawstartx);   // <- BASEL√ÑGE
  rc_baseStartY = Math.round(drawstarty);   // <- BASEL√ÑGE
  rc_snap = _snapshotDocArea(rc_oldW, rc_oldH);
  beginAction?.(); // ett undo-steg
  rc_active = true;
}

// Anropar du med canvas-sk√§rmkoordinater (dina x,y):
function resizePreviewFromCanvasXY(sx, sy){
  if (!rc_active) return;
  const W = rc_oldW, H = rc_oldH;
  const imgX = sx2ix(sx);
  const imgY = sy2iy(sy);

  switch(rc_corner){
    case 'SE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, imgY);     break;
    case 'NE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, H - imgY); break;
    case 'SW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, imgY);     break;
    case 'NW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, H - imgY); break;
  }
}

function resizeCommit(){
  if (!rc_active) return;
  const newW = rc_prevW|0, newH = rc_prevH|0;
  const {dx,dy} = offsetForCorner(rc_corner, rc_oldW, rc_oldH, newW, newH);

  blitNoLoss(rc_snap, newW, newH, dx, dy, /* bgColor */ null);

  // uppdatera drawarea (sk√§rmpixlar)
  const z = _effZ();
  drawareax = newW * z;
  drawareay = newH * z;

  // H√•ll valfritt h√∂rn visuellt "fast" genom att flytta drawstart* (f√∂r NW/NE/SW)
  // SE: top-left fast ‚Üí inget att g√∂ra
  if (rc_corner === 'NW' || rc_corner === 'NE') drawstarty += (rc_oldH - newH) * z;
  if (rc_corner === 'NW' || rc_corner === 'SW') drawstartx += (rc_oldW - newW) * z;

  if (typeof endAction === 'function') endAction();
  rc_active = false; rc_snap = null;
}

function resizeCancel(){
  if (!rc_active) return;
  if (typeof undo === 'function') undo(); // backa snapshot-start
  rc_active = false; rc_snap = null;
}
function quantizeToZoomGrid(screenValue, z) {
  // Sn√§pper till n√§rmaste multipel av z (s√• 1 doc-pixel = exakt z sk√§rmpixlar)
  return Math.round(screenValue / z) * z;
}
//funkar lite
function drawResizeOverlay() {
  if (!rc_active) return;

  const z = (zoom > 10 ? zoom/100 : zoom);
  const oldW = rc_oldW, oldH = rc_oldH;
  const newW = rc_prevW|0, newH = rc_prevH|0;

  // ... (beh√•ll din offsetForCorner etc)

  const { dx, dy } = offsetForCorner(rc_corner, oldW, oldH, newW, newH);

  const dstX = (dx > 0 ? dx : 0) | 0;
  const dstY = (dy > 0 ? dy : 0) | 0;
  const srcX = (dx < 0 ? -dx : 0) | 0;
  const srcY = (dy < 0 ? -dy : 0) | 0;
  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // F√∂rhandsvisningens topp-v√§nster i SK√ÑRMpixlar (h√•ll motsatt h√∂rn "fast")
  let previewTLx = drawstartx + ((rc_corner==='NW' || rc_corner==='SW') ? (oldW - newW) * z : 0);
  let previewTLy = drawstarty + ((rc_corner==='NW' || rc_corner==='NE') ? (oldH - newH) * z : 0);

  // === VIKTIGT: kvantisera sk√§rmpixlar till zoom-rutn√§tet ===
  previewTLx = quantizeToZoomGrid(previewTLx, z);
  previewTLy = quantizeToZoomGrid(previewTLy, z);

  // Sk√§rm-rektar (kvantisera √§ven storleken)
  const prevW = quantizeToZoomGrid(newW * z, z);
  const prevH = quantizeToZoomGrid(newH * z, z);

  const docX0 = drawstartx,             docY0 = drawstarty;
  const docX1 = docX0 + quantizeToZoomGrid(oldW * z, z);
  const docY1 = docY0 + quantizeToZoomGrid(oldH * z, z);

  const prevX0 = Math.floor(previewTLx), prevY0 = Math.floor(previewTLy);
  const prevX1 = prevX0 + prevW,         prevY1 = prevY0 + prevH;

  // Destinationspunkt f√∂r snapshot i SK√ÑRMpixlar ‚Üí kvantisera
  const dstXs = quantizeToZoomGrid(prevX0 + dstX * z, z);
  const dstYs = quantizeToZoomGrid(prevY0 + dstY * z, z);
  const drawW = quantizeToZoomGrid(copyW * z, z);
  const drawH = quantizeToZoomGrid(copyH * z, z);

  ctx.save();
  disableSmoothing(ctx);

  // 1) Bakgrund i nya ytan
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(prevX0, prevY0, prevW, prevH);

  // 2) Rita snapshot (endast overlap) p√• kvantiserad plats
  if (rc_snap && copyW > 0 && copyH > 0) {
      ctx.drawImage(
      rc_snap,
      srcX, srcY, copyW, copyH,        // K√ÑLLA: or√∂rd i doc-pixlar
      dstXs,dstYs, drawW, drawH // M√ÖL: kvantiserade sk√§rmpixlar
    );
  }

  // 3) Skugga UTANF√ñR nya ytan
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(docX0, docY0, Math.max(0, prevX0 - docX0), docY1 - docY0);
  ctx.fillRect(Math.min(docX1, prevX1), docY0, Math.max(0, docX1 - prevX1), docY1 - docY0);
  ctx.fillRect(prevX0, docY0, Math.max(0, prevX1 - prevX0), Math.max(0, prevY0 - docY0));
  ctx.fillRect(prevX0, Math.min(docY1, prevY1), Math.max(0, prevX1 - prevX0), Math.max(0, docY1 - prevY1));

  // 4) Ram
  ctx.setLineDash([6,4]);
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.strokeRect(prevX0 + 0.5, prevY0 + 0.5, prevW, prevH);

  ctx.restore();
}
let isRectSelecting = false;

canvas.addEventListener('pointerdown', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig rektangelmarkering ‚Üí b√∂rja flytta (som lasso)
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {

    startSelectionSession();
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);
      selErasedOnce = true;
    }
    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }







if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }






  // Ny rektangel
  commitSelectionSession();
  isRectSelecting = true;
  selectionStartX = selectionEndX = pImg.x;
  selectionStartY = selectionEndY = pImg.y;
  // nolla gamla
  hasSelection = false;
  selectionBBox = null;
  selectionPathCanvas = null;
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
});

canvas.addEventListener('pointermove', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    dragSelX = pImg.x - dragOffsetIX;
    dragSelY = pImg.y - dragOffsetIY;
    return;
  }
  if (isRectSelecting) {
    selectionEndX = pImg.x;
    selectionEndY = pImg.y;
  }
});

function _finalizeRectSelection() {
  const x0 = Math.min(selectionStartX, selectionEndX);
  const y0 = Math.min(selectionStartY, selectionEndY);
  const w  = Math.max(1, Math.abs(selectionEndX - selectionStartX));
  const h  = Math.max(1, Math.abs(selectionEndY - selectionStartY));
  if (w <= 0 || h <= 0) return;

  // Canvas-path (sk√§rm) f√∂r ‚Äúmarching ants‚Äù
  const p0 = _imageXYtoCanvasXY(x0, y0);
  const z  = _effectiveZoom();
  const pCanvas = new Path2D();
  pCanvas.rect(p0.x, p0.y, w*z, h*z);
  selectionPathCanvas = pCanvas;

  // Mask-path i bildkoordinater
  const pImg = new Path2D();
  pImg.rect(x0, y0, w, h);
  selectionPathImg = pImg;

  selectionBBox = { x: x0, y: y0, w, h };
  _extractSelection(); // bygger selectionImageCanvas + mask fr√•n pathen
  hasSelection = true;
  selSessionActive   = true;
  selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
  selectionHoleBBox  = { ...selectionBBox };
  
  _eraseSelectionAt(selectionBBox.x, selectionBBox.y);
    selErasedOnce   = true;
    selectionHoleCut= true; 
  
}

canvas.addEventListener('pointerup', (ev)=>{
  if (currentTool !== 'select') return;
  if (ev.pointerType === 'touch') ev.preventDefault();
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }
  if (isRectSelecting) {
    isRectSelecting = false;
    _finalizeRectSelection();
  }
});

canvas.addEventListener('pointercancel', ()=>{ if (currentTool==='select') { isDraggingSelection=false; isRectSelecting=false; }});
async function copySelection() {
  // V√§lj k√§lla: aktiv selection ‚Üí annars hela dokumentytan
  let srcCanvas = null;

  if (hasSelection && selectionImageCanvas) {
    srcCanvas = selectionImageCanvas;
  } else {
    // Kopiera hela dokumentytan (origo-bilden, inte zoomad)
    const z = _effectiveZoom();
    const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
    tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
    srcCanvas = tmp;
  }

  // F√∂rs√∂k Clipboard API (bild)
  try {
    const blob = await new Promise(res => srcCanvas.toBlob(res, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    console.log('Selection copied to clipboard (image/png).');
  } catch (err) {
    // Fallback: Base64-text
    try {
      await navigator.clipboard.writeText(srcCanvas.toDataURL('image/png'));
      alert('Kopierade som data-URL (fallback).');
    } catch (err2) {
      console.warn('Clipboard copy failed:', err2);
      alert('Kunde inte kopiera till urklipp i den h√§r webbl√§saren.');
    }
  }
}
function _drawSelectOverlay() {
  // Visa bara medan man drar en rektangel i select/copy-l√§ge
  if (!isSelecting || (currentTool !== 'select' && currentTool !== 'copy')) return;

  const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : zoom;

  const left   = drawstartx + Math.min(selectionStartX, selectionEndX) * z;
  const top    = drawstarty + Math.min(selectionStartY, selectionEndY) * z;
  const width  = Math.abs(selectionEndX - selectionStartX) * z;
  const height = Math.abs(selectionEndY - selectionStartY) * z;

  if (width <= 0 || height <= 0) return;

  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4, 3]);          // samma ‚Äúants‚Äù-stil som lasso
  ctx.strokeRect(left, top, width, height);
  ctx.restore();
}
// === Double-click f√∂r SELECT: f√§rdigst√§ll eller commit+clear ===
canvas.addEventListener('dblclick', (ev) => {
  if (currentTool !== 'select') return;
  ev.preventDefault();

  // 1) Om vi h√•ller p√• att rita rektangel ‚Üí f√§rdigst√§ll rutan
  if ((typeof isRectSelecting !== 'undefined' && isRectSelecting) ||
      (typeof isSelecting !== 'undefined' && isSelecting)) {
    if (typeof isRectSelecting !== 'undefined') isRectSelecting = false;
    if (typeof isSelecting !== 'undefined')     isSelecting = false;
    if (typeof _finalizeRectSelection === 'function') _finalizeRectSelection(); // skapar selectionPath/Mask/BBox
    return;
  }

  // 2) Om vi har en aktiv markering/drag-session ‚Üí commit & clear (samma som lasso)
  if ((typeof isDraggingSelection !== 'undefined' && isDraggingSelection) ||
      (typeof selSessionActive !== 'undefined' && selSessionActive) ||
      (typeof hasSelection !== 'undefined' && hasSelection)) {

    // Om vi draggar, baka in drag-positionen i BBox f√∂rst
    if (typeof isDraggingSelection !== 'undefined' && isDraggingSelection) {
      if (typeof selectionBBox !== 'undefined' && selectionBBox) {
        selectionBBox.x = dragSelX;
        selectionBBox.y = dragSelY;
      }
      isDraggingSelection = false;
    }

    if (typeof commitSelectionSession === 'function') commitSelectionSession(); // skriv tillbaka
    if (typeof clearSelection === 'function') clearSelection();                 // rensa ants/overlay
  }
});






async function pasteFromClipboard() {
  try {
    // 1) image/* direkt
    if (navigator.clipboard?.read) {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          const t = item.types.find(x => x.startsWith('image/'));
          if (t) {
            const blob = await item.getType(t);
            const bmp  = await createImageBitmap(blob);
            _activatePastedBitmap(bmp);
            return;
          }
        }
        // 2) HTML -> <img> / og:image
        for (const item of items) {
          if (item.types.includes('text/html')) {
            const html = await (await item.getType('text/html')).text();
            const src = _parseImgSrcFromHTML(html);
            if (src && _looksLikeImageURL(src)) {
              const bmp = await _loadBitmapFromURL(src);
              _activatePastedBitmap(bmp);
              return;
            }
          }
        }
        // 3) URI-list / plain text
        for (const mime of ['text/uri-list','text/plain']) {
          const item = items.find(it => it.types.includes(mime));
          if (item) {
            const txt = (await (await item.getType(mime)).text()).trim();
            const norm = _normalizeImageURL(txt);
            if (norm && _looksLikeImageURL(norm)) {
              const bmp = norm.startsWith('data:image/')
                ? await _bitmapFromDataURL(norm)
                : await _loadBitmapFromURL(norm);
              _activatePastedBitmap(bmp);
              return;
            }
          }
        }
      } catch (e) {
        console.warn('clipboard.read failed', e);
      }
    }

    // 4) Fallback: readText
    if (navigator.clipboard?.readText) {
      const txt = (await navigator.clipboard.readText()).trim();
      const norm = _normalizeImageURL(txt);
      if (norm && _looksLikeImageURL(norm)) {
        const bmp = norm.startsWith('data:image/')
          ? await _bitmapFromDataURL(norm)
          : await _loadBitmapFromURL(norm);
        _activatePastedBitmap(bmp);
        return;
      }
    }

    
  } catch (err) {
    console.error(err);
    
  }
}

// Hj√§lpare: dataURL -> ImageBitmap
async function _bitmapFromDataURL(dataURL) {
  const res = await fetch(dataURL);
  const blob = await res.blob();
  return await createImageBitmap(blob);
}

// Aktivera som flyttbar markering (ingen direkt m√•lning p√• ritytan)
function _activatePastedBitmap(imgBitmap) {
  // 1) Bygg en canvas av den inklistrade bilden
  const w = imgBitmap.width | 0, h = imgBitmap.height | 0;
  if (!w || !h) return;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);
  cctx.drawImage(imgBitmap, 0, 0);

    // 2) Placera i mitten av vyn (bildkoordinater)
    const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : (window.zoom || 1);

    // R√§tt s√§tt: konvertera canvas-mitten ‚Üí bildkoordinater
    let centerImg;
    if (typeof _canvasXYtoImageXY === 'function') {
      centerImg = _canvasXYtoImageXY(drawareax/2, drawareay/2);
    } else {
      // Fallback om helper saknas: (canvasX - drawstart) / zoom
      centerImg = {
        x: ((drawareax/2) - drawstartx) / z,
        y: ((drawareay/2) - drawstarty) / z
      };
    }

    // Centera bilden kring vymitten
    const cx = Math.max(0, (centerImg.x - w/2) | 0);
    const cy = Math.max(0, (centerImg.y - h/2) | 0);

  // 3) Mata in i selection-systemet
  selectionImageCanvas = c;
  selectionBBox = { x: cx, y: cy, w, h };

    // NEW: make paste committable
  selectionSrcCanvas   = selectionImageCanvas;   // ‚Üê viktigt f√∂r commit
  selectionHoleBBox    = null;                   // ingen ‚Äúh√•l‚Äù-yta f√∂r paste
  selectionHoleCut     = true;                   // hoppa √∂ver h√•l-kapitel vid commit
  hasSelection         = true;
  isDraggingSelection  = false;
  selSessionActive     = true;                   // commit skriver in bilden
  selErasedOnce        = true;                   // s√• vi f√∂rs√∂ker inte radera n√•got
  if (typeof currentTool !== 'undefined') {switchTool('select');currentTool = 'select';  }

  // Bygg mask fr√•n bilden (anv√§nds av transform/erase)
  if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

  // 4) Flagga markering + ‚Äúp√•g√•ende session‚Äù s√• commit ritar in bilden
  hasSelection = true;
  isDraggingSelection = false;
  selSessionActive = true;   // ‚Üê viktigt
  selErasedOnce    = true;   // ‚Üê g√∂r att commitSelectionSession() ritar in bilden

  // 5) Byt till select s√• anv√§ndaren kan dra direkt
  if (typeof currentTool !== 'undefined') {switchTool('select');currentTool = 'select';}

  // 6) Be om en redraw
  if (typeof requestAnimationFrame === 'function') requestAnimationFrame(()=>{});
}
window.addEventListener('paste', async (e) => {
  // F√∂rs√∂k hitta bild
  const cd = e.clipboardData;
  if (!cd) return;
  // 1) Filer (png/jpg/webp) direkt
  if (cd.files && cd.files.length) {
    const file = Array.from(cd.files).find(f => f.type.startsWith('image/'));
    if (file) {
      e.preventDefault();
      const bmp = await createImageBitmap(file);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 2) Items (t.ex. fr√•n Photoshop etc.)
  if (cd.items && cd.items.length) {
    const it = Array.from(cd.items).find(i => i.type && i.type.startsWith('image/'));
    if (it) {
      e.preventDefault();
      const blob = it.getAsFile();
      const bmp = await createImageBitmap(blob);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 3) Text-dataURL
  const txt = cd.getData('text/plain');
  if (txt && txt.startsWith('data:image/')) {
    e.preventDefault();
    const bmp = await _bitmapFromDataURL(txt);
    _activatePastedBitmap(bmp);
  }
});
// === COPY: skriv data-URL till urklipp via copy-event (funkar utan HTTPS) ===
function _buildCopyDataURL() {
  // 1) Direkt fr√•n en redan beskuren canvas
  if (hasSelection && selectionImageCanvas) {
    const c = selectionImageCanvas;
    if (!c || !c.width || !c.height) return ''; // undvik 'data:,'
    return c.toDataURL('image/png');
  }

  // 2) Fr√•n en markeringsruta p√• huvud-canvas
  if (hasSelection && selectionBBox) {
    const { x, y, w, h } = selectionBBox;

    // Klipp till giltigt omr√•de inom drawingCanvas
    const srcW = drawingCanvas.width  | 0;
    const srcH = drawingCanvas.height | 0;
    let sx = Math.max(0, Math.round(x));
    let sy = Math.max(0, Math.round(y));
    let sw = Math.max(0, Math.round(w));
    let sh = Math.max(0, Math.round(h));
    if (sx + sw > srcW) sw = Math.max(0, srcW - sx);
    if (sy + sh > srcH) sh = Math.max(0, srcH - sy);
    // Se till att m√•let inte blir 0√ó0
    const outW = Math.max(1, sw);
    const outH = Math.max(1, sh);

    const c = document.createElement('canvas');
    c.width = outW; c.height = outH;
    const cctx = c.getContext('2d');
    if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

    if (sw > 0 && sh > 0) {
      cctx.drawImage(drawingCanvas, sx, sy, sw, sh, 0, 0, outW, outH);
    } // annars l√§mna transparent

    // OBS: om canvas √§r tainted kan iOS returnera 'data:,'
    return c.toDataURL('image/png');
  }

  // 3) Hela ritytan (justerat f√∂r din zoommodell)
  const z = (!Number.isFinite(zoom) || zoom <= 0)
    ? 1
    : (zoom > 10 ? zoom / 100 : zoom);

  // Anv√§nd round + min 1
  const outW = Math.max(1, Math.round((drawareax || drawingCanvas.width)  / z));
  const outH = Math.max(1, Math.round((drawareay || drawingCanvas.height) / z));

  // Klipp k√§llrektangel inom drawingCanvas
  const srcW = Math.min(outW, drawingCanvas.width);
  const srcH = Math.min(outH, drawingCanvas.height);

  const c = document.createElement('canvas');
  c.width = outW; c.height = outH;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

  cctx.drawImage(drawingCanvas, 0, 0, srcW, srcH, 0, 0, outW, outH);
  return c.toDataURL('image/png');
}

async function _dataURLToBlob(dataURL) {
  const res = await fetch(dataURL);
  return await res.blob();
}

function _fallbackTextareaCopy(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.setAttribute('readonly', '');
  ta.style.position = 'fixed';
  ta.style.top = '0';
  ta.style.left = '0';
  ta.style.opacity = '0';
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  ta.setSelectionRange(0, ta.value.length);
  let ok = false;
  try { ok = document.execCommand('copy'); } catch (_) {}
  document.body.removeChild(ta);
  return ok;
}

function _toast(msg) {
  let box = document.getElementById('toast-box');
  if (!box) {
    box = document.createElement('div');
    box.id = 'toast-box';
    box.style.cssText = `
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:#111; color:#fff; padding:8px 12px; border-radius:10px;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      box-shadow:0 6px 24px rgba(0,0,0,.25); z-index:999999; opacity:0; transition:opacity .2s;
      pointer-events:none;
    `;
    document.body.appendChild(box);
  }
  box.textContent = msg;
  requestAnimationFrame(() => {
    box.style.opacity = '1';
    clearTimeout(box._t);
    box._t = setTimeout(() => { box.style.opacity = '0'; }, 1400);
  });
}

// Huvudfunktionen du anropar fr√•n knappen (m√•ste k√∂ras i user gesture)
function _buildCopyCanvas() {
  // 1) If a floating selection image exists, use that
  if (window.hasSelection && window.selectionImageCanvas) {
    return window.selectionImageCanvas;
  }
  // 2) If we only have a selection bbox, extract that region
  if (window.hasSelection && window.selectionBBox) {
    const { x, y, w, h } = window.selectionBBox;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
    cctx.drawImage(drawingCanvas, x, y, w, h, 0, 0, w, h);
    return c;
  }
  // 3) Fallback: copy the whole visible document area
  const z = (window.zoom > 10 ? window.zoom/100 : window.zoom || 1);
  const w = Math.floor(window.drawareax / z);
  const h = Math.floor(window.drawareay / z);
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  return c;
}

// Replace this function with the version below
function _isCanvasTainted(c) {
  try {
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.getImageData(0, 0, 1, 1); // kastar SecurityError vid taint
    return false;
  } catch (e) {
    return true;
  }
}



// iOS-fallback: kopiera genom att v√§lja ett IMG i en contenteditable
function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.position = 'fixed';
  host.style.left = '-99999px';
  host.style.top = '0';
  host.style.opacity = '0';
  // Viktigt: IMG som faktiskt renderas
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const img = host.firstChild;
  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(img);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch(_) {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.cssText = 'position:fixed;left:-99999px;top:0;opacity:0;';
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(host.firstChild);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

async function copySelectionMobileFriendly() {
  const url = _buildCopyDataURL();
  if (!url || url === 'data:,') { _toast('Inget att kopiera.'); return; }

  // 1) Riktig bild till urklipp ‚Äî iOS/Safari vill ha PROMISE direkt i ClipboardItem
  try {
    if (navigator.clipboard && window.ClipboardItem) {
      const blobPromise = (async () => (await fetch(url)).blob())(); // <- Promise, inte f√§rdig blob
      const item = new ClipboardItem({ 'image/png': blobPromise });
      await navigator.clipboard.write([item]);
      _toast('Kopierat (bild).');
      return;
    }
  } catch (e) {
    console.warn('clipboard.write image failed:', e);
  }

  // 2) iOS-fallback: contenteditable + IMG + execCommand('copy')
  try {
    if (_copyViaEditableIMG(url)) {
      _toast('Kopierat (iOS-fallback).');
      return;
    }
  } catch (e2) {
    console.warn('editable IMG copy failed:', e2);
  }

  // 3) writeText(dataURL)
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(url);
      _toast('Kopierat (text-dataURL).');
      return;
    }
  } catch {}

  // 4) execCommand (textarea)
  if (_fallbackTextareaCopy(url)) { _toast('Kopierat.'); return; }

  // 5) prompt (sista utv√§gen)
  try { window.prompt('Tryck Kopiera:', url); } catch {}
}
//-----NYTT
// ===== BEGIN PATCH: resize-corners state =====
let isResizingSelection = false;
let activeResizeCorner = null;   // 'tl','tr','bl','br'
let resizeAnchorImg = null;      // {x,y} i bild-koordinater (motsatt h√∂rn)
let resizeStartBBox = null;      // snapshot av bbox vid pointerdown
let HANDLE_SIZE_SCR = 12;      // storlek p√• h√∂rn-handtag i sk√§rm-px


// Tr√§ffa h√∂rn i SK√ÑRM-koordinater (mx,my i canvas.getBoundingClientRect()-space)
function _hitTestResizeHandleScreen(mx, my, bbox){
  if (!bbox) return null;
  const tl = _imageXYtoCanvasXY(bbox.x,             bbox.y);
  const tr = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y);
  const bl = _imageXYtoCanvasXY(bbox.x,             bbox.y + bbox.h);
  const br = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y + bbox.h);
  const S  = HANDLE_SIZE_SCR;

  const hits = (p) => (mx >= p.x - S && mx <= p.x + S && my >= p.y - S && my <= p.y + S);
  if (hits(tl)) return 'tl';
  if (hits(tr)) return 'tr';
  if (hits(bl)) return 'bl';
  if (hits(br)) return 'br';
  return null;
}

// Ber√§kna ny bbox fr√•n muspunkt (bild-koordinater) + l√•st ankare
function _bboxFromDragAnchor(currImg, anchorImg){
  const x = Math.min(currImg.x, anchorImg.x);
  const y = Math.min(currImg.y, anchorImg.y);
  const w = Math.max(1, Math.abs(currImg.x - anchorImg.x));
  const h = Math.max(1, Math.abs(currImg.y - anchorImg.y));
  return { x, y, w, h };
}

// Hj√§lp: h√•l i gamla omr√•det och inritning av skalad bild i nya
function _commitSelectionResize(oldBBox, newBBox){
  if (!selSessionActive || !selectionSrcCanvas || !newBBox) return;

  // 1) Uppdatera aktuell bbox
  selectionBBox = { ...newBBox };

  // 2) (valfritt) Bygg om en f√∂rhandsbuffer fr√•n *originalk√§llan*, inte fr√•n basen
  const c = document.createElement('canvas');
  c.width  = Math.max(1, Math.round(newBBox.w));
  c.height = Math.max(1, Math.round(newBBox.h));
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(
    selectionSrcCanvas,
    0,0, selectionSrcCanvas.width, selectionSrcCanvas.height,
    0,0, c.width, c.height
  );
  selectionImageCanvas = c; // f√∂rhandsvisning / overlay
}
// ===== END PATCH: resize-corners state =====
// ===== BEGIN PATCH: pointer listeners for corner resize =====
canvas.addEventListener('pointerdown', (ev) => {
  if (!selectionImageCanvas || !selectionBBox) return;

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (!corner) return;

  ev.preventDefault();
  ev.stopPropagation();

  // Om du har drag-l√§ge f√∂r selection, st√§ng av s√• de inte krockar:
  if (typeof isDraggingSelection !== 'undefined') isDraggingSelection = false;

  activeResizeCorner = corner;
  isResizingSelection = true;
  resizeStartBBox = { ...selectionBBox };

  // Motsatt h√∂rn = ankare (i bild-koordinater)
  let ax, ay;
  if (corner === 'tl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'tr') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'bl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y;                       }
  if (corner === 'br') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y;                       }
  resizeAnchorImg = { x: ax, y: ay };
});

canvas.addEventListener('pointermove', (ev) => {
  // Hover-cursor n√§r inte resizing
  if (!isResizingSelection) {
    if (selectionBBox) {
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
      let cur = 'default';
      if (corner === 'tl' || corner === 'br') cur = 'nwse-resize';
      if (corner === 'tr' || corner === 'bl') cur = 'nesw-resize';
      canvas.style.cursor = cur;
    }
    return;
  }

  // N√§r resizing: uppdatera selectionBBox live (preview)
  if (!resizeAnchorImg) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const mImg = _canvasXYtoImageXY(mx, my); // mus i bild-koordinater

  // (valfritt) beh√•ll aspektf√∂rh√•llande om Shift h√•lls:
  // if (ev.shiftKey) { ...justera mImg.x/mImg.y f√∂r ratio... }

  let newBBox = _bboxFromDragAnchor(mImg, resizeAnchorImg);

  // Kl√§m inom canvas-gr√§nser
  newBBox.x = Math.max(0, Math.min(newBBox.x, drawingCanvas.width  - 1));
  newBBox.y = Math.max(0, Math.min(newBBox.y, drawingCanvas.height - 1));
  newBBox.w = Math.max(1, Math.min(newBBox.w, drawingCanvas.width  - newBBox.x));
  newBBox.h = Math.max(1, Math.min(newBBox.h, drawingCanvas.height - newBBox.y));

  selectionBBox = newBBox; // detta r√§cker f√∂r live-preview eftersom din overlay ritar selectionImageCanvas skalad
  ev.preventDefault();
});

function _endResizeCommit(){
  if (!isResizingSelection) return;
  _commitSelectionResize(resizeStartBBox, selectionBBox);

  isResizingSelection = false;
  activeResizeCorner = null;
  resizeAnchorImg = null;
  resizeStartBBox = null;
}

canvas.addEventListener('pointerup',    _endResizeCommit);
canvas.addEventListener('pointercancel',_endResizeCommit);
canvas.addEventListener('pointerleave', () => {
  // valfritt: commit √§ven n√§r man drar utanf√∂r canvas
  if (isResizingSelection) _endResizeCommit();
});
// ===== END PATCH: pointer listeners for corner resize =====
function _parseImgSrcFromHTML(html) {
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    if (!doc) return '';

    // 1) Vanlig <img>
    let img = doc.querySelector('img[src], img[data-src], img[data-original], img[data-iurl]');
    if (img) {
      let src = img.getAttribute('src') ||
                img.getAttribute('data-src') ||
                img.getAttribute('data-original') ||
                img.getAttribute('data-iurl') || '';
      if ((!src || src === '#') && img.getAttribute('srcset')) {
        src = _pickLargestFromSrcset(img.getAttribute('srcset'));
      }
      return _normalizeImageURL(src);
    }

    // 2) OG/Twitter fallback
    const og = doc.querySelector('meta[property="og:image"][content],meta[name="twitter:image"][content]');
    if (og) return _normalizeImageURL(og.getAttribute('content'));

    // 3) √Ñldre fallback
    const linkImg = doc.querySelector('link[rel="image_src"][href]');
    if (linkImg) return _normalizeImageURL(linkImg.getAttribute('href'));

    return '';
  } catch { return ''; }
}

function _pickLargestFromSrcset(srcset) {
  // V√§lj kandidaten med h√∂gst "w" (eller sista om bara "x"-descriptor)
  try {
    const parts = srcset.split(',').map(s => s.trim()).filter(Boolean).map(s => {
      const [u, d = ''] = s.split(/\s+/);
      const w = d.endsWith('w') ? parseInt(d) : (d.endsWith('x') ? parseFloat(d) * 1000 : 0);
      return { u, w: isFinite(w) ? w : 0 };
    });
    parts.sort((a,b) => b.w - a.w);
    return parts.length ? parts[0].u : '';
  } catch { return ''; }
}

// -------------- Normalisera bilder fr√•n s√∂kmotorer ------
function _normalizeImageURL(u) {
  try {
    const url = new URL(u, location.href);

    // Google Image redirect: https://www.google.xx/imgres?imgurl=...
    if (/\.google\./i.test(url.hostname) && /\/imgres/i.test(url.pathname)) {
      const real = url.searchParams.get('imgurl') || url.searchParams.get('imgrefurl');
      if (real) return real;
    }

    // Google "url" wrapper: https://www.google.xx/url?q=...
    if (/\.google\./i.test(url.hostname) && /\/url/i.test(url.pathname)) {
      const q = url.searchParams.get('q');
      if (q) return q;
    }

    // Bing Images: mediaurl=
    if (/\.bing\./i.test(url.hostname)) {
      const m = url.searchParams.get('mediaurl');
      if (m) return m;
    }

    // DuckDuckGo: u=
    if (/duckduckgo\.com/i.test(url.hostname)) {
      const m = url.searchParams.get('u');
      if (m) return m;
    }

    return url.href;
  } catch {
    return u;
  }
}

// -------------- URL heuristik: acceptera mer -------------
function _looksLikeImageURL(s) {
  // Var inte f√∂r strikt ‚Äì prova att ladda allt http(s) och data:image
  if (!s) return false;
  if (/^data:image\//i.test(s)) return true;
  if (/^blob:/i.test(s)) return true;                 // kan funka om samma origin
  if (/^https?:/i.test(s)) return true;               // l√•t loader avg√∂ra
  return false;
}
async function _loadBitmapFromURL(src) {
  // f√∂rs√∂k anonymt f√∂rst (om CORS finns blir canvas *inte* tainted)
  const img = new Image();
  img.crossOrigin = 'anonymous';
  const done = new Promise((res, rej) => {
    img.onload = () => res(img);
    img.onerror = () => rej(new Error('Image load failed: ' + src));
  });
  img.src = src;
  const el = await done;
  try {
    return await createImageBitmap(el);
  } catch {
    // sista utv√§g: rita till mellan-canvas (kan tainta)
    const c = document.createElement('canvas');
    c.width = el.naturalWidth || el.width;
    c.height = el.naturalHeight || el.height;
    const cctx = c.getContext('2d');
    if (typeof disableSmoothing === 'function') disableSmoothing(cctx);
    cctx.drawImage(el, 0, 0);
    return await createImageBitmap(c);
  }
}
//NYTT
function _fitViewportToImage(newW, newH) {
  // Beh√•ll beteendet: auto-fit till ~80% av f√∂nstret, men lyft upp till ~50% om det blir f√∂r sm√•tt
  let newZoom = zoom;
  const availW = window.innerWidth;
  const availH = window.innerHeight - 100; // din toppbar-marginal

  if (newW * newZoom > availW * 0.8 || newH * newZoom > availH * 0.8) {
    const zx = Math.round(((availW * 0.8) / newW) * 10) / 10;
    const zy = Math.round(((availH * 0.8) / newH) * 10) / 10;
    newZoom = Math.min(zx, zy);
  } else if (newW * newZoom < availW * 0.5 || newH * newZoom < availH * 0.5) {
    const zx = Math.round(((availW * 0.5) / newW) * 10) / 10;
    const zy = Math.round(((availH * 0.5) / newH) * 10) / 10;
    newZoom = Math.min(zx, zy);
  }

  // Skriv tillbaka zoom + UI
  zoom = newZoom;
  zoomvalue = Math.round(newZoom * 100);
  const zSlider = document.getElementById("zoomSlider");
  const zLabel  = document.getElementById("zoomLabel");
  if (zSlider) zSlider.value = zoomvalue;
  if (zLabel)  zLabel.innerText = "Zoom: " + zoomvalue + "%";

  // Uppdatera drawarea och centrera
  drawareax = newW * zoom;
  drawareay = newH * zoom;
  const dpr = window.devicePixelRatio || 1;
  drawstartx = (canvas.width / dpr - drawareax) / 2;
  drawstarty = (canvas.height / dpr - drawareay) / 2;
}
async function _activateLoadedBitmap(imgBitmap) {
  if (!imgBitmap || !imgBitmap.width || !imgBitmap.height) return;
  ensureCanvasSize(imgBitmap.width, imgBitmap.height); // beh√•ll din s√§kerhetsmarginal
  _fitViewportToImage(imgBitmap.width, imgBitmap.height);
  _activatePastedBitmap(imgBitmap);                     // in i nya selectTool-fl√∂det
  if (typeof currentTool !== 'undefined') { switchTool('select'); currentTool = 'select'; }
}
//NYTT
window.addEventListener('load', ()=>{
  const startTool = (window.currentTool || 'pen'); // du har default 'pen' redan
  if (window.__setSidebarActive) window.__setSidebarActive(startTool); // direkt uppdatering
  window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool: startTool } })); // f√∂r alla andra lyssnare
});

// Originalknappar
  const inputOpen   = document.getElementById('directFileInput');
  const lblOpen     = document.querySelector('label[for="directFileInput"]');
  const btnSave     = document.getElementById('saveImageBtn');
  const btnResize   = document.getElementById('ResizeBtn');
  const btnGrid     = document.getElementById('gridBtn');
  const btnP1       = document.getElementById('project1Btn');
  const btnP2       = document.getElementById('project2Btn');
  const btnP3       = document.getElementById('project3Btn');

  // D√∂lj original (vi proxy-klickar dem)
  if (lblOpen)   lblOpen.style.display = 'none';
  if (btnSave)   btnSave.style.display = 'none';
  if (btnResize) btnResize.style.display = 'none';
  if (btnGrid)   btnGrid.style.display = 'none';
  if (btnP1) btnP1.style.display = 'none';
  if (btnP2) btnP2.style.display = 'none';
  if (btnP3) btnP3.style.display = 'none';

  // Top-meny element
  const hamburgerBtn = document.getElementById('hamburgerBtn');
  const mainMenu     = document.getElementById('mainMenu');
  const projectsBtn  = document.getElementById('projectsBtn');
  const projectsDrop = document.getElementById('projectsDrop');
  const backdrop     = document.getElementById('menuBackdrop');

  // Hj√§lpare
  function closeAll(){
    mainMenu.classList.remove('open');
    projectsDrop.classList.remove('open');
    hamburgerBtn.setAttribute('aria-expanded','false');
    projectsBtn.setAttribute('aria-expanded','false');
    backdrop.classList.remove('show');
  }

  function toggle(el, btn){
    const willOpen = !el.classList.contains('open');
    closeAll();
    if (willOpen){
      el.classList.add('open');
      btn.setAttribute('aria-expanded','true');
      // CSS sk√∂ter position (left:0; top:‚Ä¶)
      backdrop.classList.add('show');
    }
  }

  // √ñppna/st√§ng via knappar
  hamburgerBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(mainMenu, hamburgerBtn); });
  projectsBtn ?.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(projectsDrop, projectsBtn); });

  // F√•nga interaktioner INUTI menyerna s√• de inte bubbler upp till backdrop
  [hamburgerBtn, projectsBtn, mainMenu, projectsDrop].forEach(el=>{
    el?.addEventListener('pointerdown', e=> e.stopPropagation());
    el?.addEventListener('touchstart',  e=> e.stopPropagation(), {passive:true});
    el?.addEventListener('mousedown',   e=> e.stopPropagation());
  });

  // Klick/touch utanf√∂r -> st√§ng (fungerar p√• iOS)
  function closeOnOutside(){ closeAll(); }
  backdrop.addEventListener('pointerdown', closeOnOutside);
  backdrop.addEventListener('mousedown',   closeOnOutside);
  backdrop.addEventListener('touchstart',  closeOnOutside, {passive:true});

  // Som extra s√§kerhet ‚Äì ESC st√§nger
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeAll(); });

  // Proxy-actions
  document.getElementById('mnuOpen') ?.addEventListener('click', ()=>{ closeAll(); inputOpen?.click(); });
  document.getElementById('mnuSave') ?.addEventListener('click', ()=>{ closeAll(); btnSave?.click(); });
  document.getElementById('mnuResize')?.addEventListener('click', ()=>{ closeAll(); btnResize?.click(); });
  document.getElementById('mnuGrid')  ?.addEventListener('click', ()=>{ closeAll(); btnGrid?.click(); });

  document.getElementById('mnuProj1')?.addEventListener('click', ()=>{ closeAll(); btnP1?.click(); });
  document.getElementById('mnuProj2')?.addEventListener('click', ()=>{ closeAll(); btnP2?.click(); });
  document.getElementById('mnuProj3')?.addEventListener('click', ()=>{ closeAll(); btnP3?.click(); });




// H√§mta originalknapparna
  const flipHBtn      = document.getElementById('flipHBtn');
  const flipVBtn      = document.getElementById('flipVBtn');
  const rotateRightBtn= document.getElementById('rotateRightBtn');
  const rotateLeftBtn = document.getElementById('rotateLeftBtn');
  const rotateFreeBtn = document.getElementById('rotateFreeBtn');

  // G√∂m dem om de syns i UI (valfritt)
  [flipHBtn, flipVBtn, rotateRightBtn, rotateLeftBtn, rotateFreeBtn]
    .forEach(b=>{ if(b) b.style.display='none'; });

  // V√•r launcher och meny
  const trBtn  = document.getElementById('transformBtn');
  const trMenu = document.getElementById('transformMenu');

  function closeTransform(){
    trMenu.classList.remove('open');
    backdrop?.classList.remove('show');
  }
  function toggleTransform(){
    const willOpen = !trMenu.classList.contains('open');
    // st√§ng andra menyer om du anv√§nder closeAll()
    if (typeof closeAll === 'function') closeAll();
    if (willOpen){
      trMenu.classList.add('open');
      backdrop?.classList.add('show');
    }else{
      closeTransform();
    }
  }

  // √ñppna/st√§ng
  trBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); toggleTransform(); });

  // Stoppa bubblering inuti menyn s√• backdrop inte st√§nger direkt
  [trBtn, trMenu].forEach(el=>{
    el?.addEventListener('pointerdown', e=> e.stopPropagation());
    el?.addEventListener('touchstart',  e=> e.stopPropagation(), {passive:true});
    el?.addEventListener('mousedown',   e=> e.stopPropagation());
  });

  // Backdrop ‚Üí st√§ng
  const closeOnOutside2 = ()=> closeTransform();
  backdrop?.addEventListener('pointerdown', closeOnOutside2);
  backdrop?.addEventListener('mousedown',   closeOnOutside2);
  backdrop?.addEventListener('touchstart',  closeOnOutside2, {passive:true});

function proxy(btn){
    // s√§krare proxy: trigga b√•de pointerup/click-v√§gen
    if (!btn) { console.warn('Missing target button for proxy'); return; }
    // en del iOS-webkit-versioner missar .click() direkt efter close ‚Üí k√∂r i microtask
    Promise.resolve().then(()=> btn.click());
  }

  document.getElementById('trFlipH')  ?.addEventListener('click', ()=>{ closeTransform(); proxy(flipHBtn); });
  document.getElementById('trFlipV')  ?.addEventListener('click', ()=>{ closeTransform(); proxy(flipVBtn); });
  document.getElementById('trRotR')   ?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateRightBtn); });
  document.getElementById('trRotL')   ?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateLeftBtn); });
  document.getElementById('trRotFree')?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateFreeBtn); });

  const copyBtn = document.getElementById('copyBtn');
  const pasteBtn = document.getElementById('pasteBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function proxyClick(target){
    if (!target) return;
    Promise.resolve().then(()=> target.click());
  }

  document.getElementById('barCopy') ?.addEventListener('click', ()=> proxyClick(copyBtn));
  document.getElementById('barPaste')?.addEventListener('click', ()=> proxyClick(pasteBtn));
  document.getElementById('barUndo') ?.addEventListener('click', ()=> proxyClick(undoBtn));
  document.getElementById('barRedo') ?.addEventListener('click', ()=> proxyClick(redoBtn));


const btnProjects = document.getElementById('projectsBtn');
  const item1 = document.getElementById('mnuProj1');
  const item2 = document.getElementById('mnuProj2');
  const item3 = document.getElementById('mnuProj3');

  const projItems = { 1:item1, 2:item2, 3:item3 };

  const origP1 = document.getElementById('project1Btn');
  const origP2 = document.getElementById('project2Btn');
  const origP3 = document.getElementById('project3Btn');

  // 1) S√§kerst√§ll att knappen har en separat label-span
  function ensureLabelSpan(){
    if (!btnProjects) return null;
    let label = document.getElementById('projectsLabel');
    if (!label){
      // Plocka nuvarande text (utan pilen) och bygg om knappen
      const raw = (btnProjects.textContent || '').replace('‚ñæ','').trim();
      const txt = raw || 'Canvas 1';
      btnProjects.innerHTML = `<span id="projectsLabel">${txt}</span> ‚ñæ`;
      label = document.getElementById('projectsLabel');
    }
    return label;
  }
  const labelSpan = ensureLabelSpan();

  // 2) S√§tt aktiv canvas (uppdatera knapp + highlight)
  function setActiveProject(n){
    if (labelSpan) labelSpan.textContent = `Canvas ${n}`;
    Object.values(projItems).forEach(el => el?.classList.remove('active'));
    projItems[n]?.classList.add('active');
  }

  // 3) Initiera fr√•n knappens befintliga text (t.ex. "Canvas 1 ‚ñæ")
  function initialIndex(){
    const base = (labelSpan?.textContent || btnProjects?.textContent || '').replace('‚ñæ','').trim();
    const m = base.match(/(\d+)/);
    return m ? parseInt(m[1],10) : 1;
  }
  setActiveProject(initialIndex());

  // 4) Koppla klick i dropdownen ‚Üí proxya originalknappar + uppdatera label/highlight
  item1?.addEventListener('click', ()=>{ origP1?.click(); setActiveProject(1); });
  item2?.addEventListener('click', ()=>{ origP2?.click(); setActiveProject(2); });
  item3?.addEventListener('click', ()=>{ origP3?.click(); setActiveProject(3); });

  // 5) Om du byter canvas p√• annat s√§tt (t.ex. programatiskt),
  //    lyssna √§ven p√• originalknapparna:
  origP1?.addEventListener('click', ()=> setActiveProject(1));
  origP2?.addEventListener('click', ()=> setActiveProject(2));
  origP3?.addEventListener('click', ()=> setActiveProject(3));
let zomzomzom=1;

            //check---------------------------------------------------------------------------------------
            var check = function() {
            if(document.querySelector('.color-swatch.active')&&document.querySelector('.color-swatch.active').dataset.color!== brushColor)brushColor=document.querySelector('.color-swatch.active').dataset.color;
                
                
                zomzomzom=1;
                if(window.innerHeight  < window.innerWidth&&mobileAndTabletCheck()){
                    zomzomzom=0.5;
                }
                
                // Update canvas size
                if (canvas.width !== window.innerWidth * (window.devicePixelRatio || 1) ||
                    canvas.height !== window.innerHeight * (window.devicePixelRatio || 1)) {
                    resizeCanvas();
                }
                
                
                
                
                zoom=zoom/zomzomzom;
                let centerX = drawstartx + drawareax / 2;
                let centerY = drawstarty + drawareay / 2;
                drawareax = (drawareax / zoom * (zoomvalue / 100));
                drawareay = (drawareay / zoom * (zoomvalue / 100));
                drawstartx = centerX - drawareax / 2;
                drawstarty = centerY - drawareay / 2;
                zoom = zoomvalue / 100;
                zoom=zoom*zomzomzom;
                if((document.body.clientWidth > 100 && startan == false)) {
                    startan = true;  
                    drawstartx = (canvas.width/devicePixelRatio)/2 - drawareax/2;
                    drawstarty = (canvas.height/devicePixelRatio)/2 - drawareay/2;
                    prevDrawAreaX = drawareax;
                    prevDrawAreaY = drawareay;
                    prevDrawStartX = drawstartx;
                    prevDrawStartY = drawstarty;
                    projectdrawareax = [drawareax, drawareax, drawareax];
                    projectdrawareay = [drawareay, drawareay, drawareay];
                    projectdrawstartx = [drawstartx, drawstartx, drawstartx];
                    projectdrawstarty = [drawstarty, drawstarty, drawstarty];
                    projectzoom = [zoom, zoom, zoom];
                    if(mobileAndTabletCheck())HANDLE_SIZE_SCR = 24;
                    if(window.innerHeight  < window.innerWidth&&mobileAndTabletCheck()){}
                    else zoom=zoom/zomzomzom;
                }
                
                
   
                
                // Store the old dimensions before any changes
                const oldDrawStartX = drawstartx;
                const oldDrawStartY = drawstarty;
                const oldDrawAreaX = drawareax;
                const oldDrawAreaY = drawareay;
                
                
                
                
                if (movescrollx == true) {
                    movescrollxvalue = -savescrollxvalue + x + scrollx;
                    if (canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue < 0 && !isposetive) {
                        scrollx = scrollx - movescrollxvalue + canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 - (canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01));
                        movescrollxvalue = canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 - (canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01));
                    }
                    if (canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue > canvas.width/devicePixelRatio - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) && isposetive) {
                        scrollx = scrollx - movescrollxvalue + canvas.width/devicePixelRatio - ((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01 - (canvas.width/devicePixelRatio/2 - ((((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2));
                        movescrollxvalue = canvas.width/devicePixelRatio - ((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01 - (canvas.width/devicePixelRatio/2 - ((((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2));
                    }
                    drawstartx = -(drawareax/2) - (movescrollxvalue * ((drawareax)/(canvas.width/devicePixelRatio)+(100/drawareax)*canvas.width/devicePixelRatio/20)*1.08) + canvas.width/devicePixelRatio/2;
                }
                
                if (movescrolly == true) {
                    movescrollyvalue = -savescrollyvalue + y + scrolly;
                    if (-50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue < 0 && !isposetivey) {
                        scrolly = 50 + scrolly - movescrollyvalue + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 - (canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                        movescrollyvalue = 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 - (canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                    }
                    if (50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue > canvas.height/devicePixelRatio - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
                        scrolly = scrolly - movescrollyvalue - 50 + canvas.height/devicePixelRatio - ((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01) - (canvas.height/devicePixelRatio/2 - ((((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01))/2));
                        movescrollyvalue = -50 + canvas.height/devicePixelRatio - ((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01) - (canvas.height/devicePixelRatio/2 - ((((canvas.height/devicePixelRatio-200)/drawareay)*(canvas.height/devicePixelRatio/1.01))/2));
                    }
                    drawstarty = 50 - (drawareay/2) - (movescrollyvalue * ((drawareay)/(canvas.height/devicePixelRatio)+(100/drawareay)*canvas.height/devicePixelRatio/20)*1.08) + canvas.height/devicePixelRatio/2;
                }
                
                // Draw the document background
                ctx.fillStyle = "#4D4D4D";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
                
 

                const checkerPattern = (function createCheckerPattern() {
                const patternCanvas = document.createElement('canvas');
                const size = 16; // Small pattern size (8px per square)
                patternCanvas.width = size;
                patternCanvas.height = size;
                const patternCtx = patternCanvas.getContext('2d');

                // Create the pattern
                patternCtx.fillStyle = "white";
                patternCtx.fillRect(0, 0, size, size);
                patternCtx.fillStyle = "#cccccc";
                patternCtx.fillRect(0, 0, size/2, size/2);
                patternCtx.fillRect(size/2, size/2, size/2, size/2);

                return patternCanvas;
            })();
                const pattern = ctx.createPattern(checkerPattern, 'repeat');
                ctx.fillStyle = pattern;
                // Use integer coordinates and add 1px buffer to prevent edge artifacts
                const patternX = Math.floor(drawstartx+1);
                const patternY = Math.floor(drawstarty+1);
                const patternWidth = (Math.ceil(drawareax + (drawstartx - patternX)) - 3);
                const patternHeight = (Math.ceil(drawareay + (drawstarty - patternY)) - 3);
                ctx.fillRect(patternX, patternY, patternWidth, patternHeight);


                
                // Calculate how much of the drawing area to display
                //const displayWidth = Math.ceil(drawareax / zoom) + EDGE_BUFFER;
              //  const displayHeight = Math.ceil(drawareay / zoom) + EDGE_BUFFER;

  
                // Draw the content from the drawing canvas to the visible canvas
           
                
                    ctx.save(); // Save the current state
                    ctx.translate(drawstartx, drawstarty); // Move to the top-left corner
                    ctx.scale(zoom, zoom); // Apply zoom scaling
                    const displayWidth = ensureIntDimension(drawareax / zoom);
                    const displayHeight = ensureIntDimension(drawareay / zoom);
                    ctx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0,0,displayWidth, displayHeight);
                    ctx.restore();
            
            
            if (showGrid) {
                    ctx.save();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';

                    for (let gx = 0; gx <= displayWidth; gx++) {
                        const xPix = drawstartx-0.5 + gx * zoom;
                        ctx.beginPath();
                        ctx.moveTo(xPix + 0.5, drawstarty-0.5);
                        ctx.lineTo(xPix + 0.5, drawstarty-0.5 + displayHeight * zoom);
                        ctx.stroke();
                    }

                    for (let gy = 0; gy <= displayHeight; gy++) {
                        const yPix = drawstarty-0.5 + gy * zoom;
                        ctx.beginPath();
                        ctx.moveTo(drawstartx-0.5, yPix + 0.5);
                        ctx.lineTo(drawstartx-0.5 + displayWidth * zoom, yPix + 0.5);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
            
            
            
            
            
            
            
            
                // ********** NEW: Draw the image layer overlay if an image is loaded **********
                if(currentImage){
                    // Draw the image
                    
                    currentImageWidth = currentImageOriginalWidth*zoom;;
                    currentImageHeight = currentImageOriginalHeight*zoom;
                    
                    
                    if(prevzoom!=zoom){
                    
                      
                        prevzoom=zoom;
                        currentImageX = (drawstartx + selLeft * zoom);
                        currentImageY = (drawstarty + selTop * zoom);
                         
                    }
                    if(currentImagecanvas!=currentproject){
                        
                        
                        
                        if(currentproject==0&&firstImageLoaded1==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}
                        if(currentproject==1&&firstImageLoaded2==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}
                        if(currentproject==2&&firstImageLoaded3==false){drawareax=currentImageWidth;drawareay=currentImageHeight;}

                        drawstartx = canvas.width/devicePixelRatio/2 - drawareax/2;
                        movescrollxvalue = 0;
                        scrollx = 0;
                        drawstarty = canvas.height/devicePixelRatio/2 - drawareay/2;
                        movescrollyvalue = 0;
                        scrolly = 0;
                        
                        
                        currentImageX = (drawstartx );
                        currentImageY = (drawstarty );
                        
                        currentImagecanvas=currentproject;
                    }
                    
                    
                        
                        
             
                        
                        
                       

                    
                    
                    
                 
           
                    
                    
                    ctx.drawImage(currentImage, currentImageX, currentImageY, currentImageWidth, currentImageHeight);



                    





                    // Draw a green border around the image to indicate it's movable
                    ctx.strokeStyle = "#4CAF50"; // Green color matching the UI
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]); // Dashed line for better visibility
                    ctx.strokeRect(currentImageX, currentImageY, currentImageWidth, currentImageHeight);

                    // Add corner handles for visual clarity
                    const handleSize = 8;
                    ctx.fillStyle = "#4CAF50";
                    // Draw corner handles
                    ctx.fillRect(currentImageX - handleSize/2, currentImageY - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX + currentImageWidth - handleSize/2, currentImageY - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX - handleSize/2, currentImageY + currentImageHeight - handleSize/2, handleSize, handleSize);
                    ctx.fillRect(currentImageX + currentImageWidth - handleSize/2, currentImageY + currentImageHeight - handleSize/2, handleSize, handleSize);

                    // Reset dash pattern for other drawings
                    ctx.setLineDash([]);
                }
                // ****************************************************************************
                
                
                
                if(!movecorners1&&!movecorners2&&!movecorners3&&!movecorners4){
                    ctx.fillStyle = "black";
                    ctx.fillRect(drawstartx-20, drawstarty-20, 20, 20);
                    ctx.fillRect(drawstartx+drawareax, drawstarty-20, 20, 20);
                    ctx.fillRect(drawstartx-20, drawstarty+drawareay, 20, 20);
                    ctx.fillRect(drawstartx+drawareax, drawstarty+drawareay, 20, 20);
                }
                // Draw scrollbars
                ctx.fillStyle = "rgb(100, 100, 100)";
                let sbThickness = getScrollbarThickness();
    
                if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
                    ctx.fillRect(
                        canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue, 
                        canvas.height/devicePixelRatio - sbThickness, 
                        (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01), 
                        sbThickness
                    );
                }
                
                if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
                   ctx.fillRect(canvas.width/devicePixelRatio - sbThickness, 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue, sbThickness, (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01));
                }
              
                const isCanvasTooSmallForScrollingX = !(drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50);
                const isCanvasTooSmallForScrollingY = !(drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50);

                // Center horizontally if needed
                if (isCanvasTooSmallForScrollingX && 
                    (drawstartx < 0 || drawstartx + drawareax > canvas.width/devicePixelRatio)) {
                    // Center horizontally
                    drawstartx = canvas.width/devicePixelRatio/2 - drawareax/2;
                    movescrollxvalue = 0;
                    scrollx = 0;
                }

                // Center vertically if needed
                if (isCanvasTooSmallForScrollingY && 
                    (drawstarty < 0 || drawstarty + drawareay > canvas.height/devicePixelRatio)) {
                    // Center vertically
                    drawstarty = canvas.height/devicePixelRatio/2 - drawareay/2;
                    movescrollyvalue = 0;
                    scrolly = 0;
                }
                            // ======== RITA LOOPEN/SELECTION-OVERLAY I DIN huvud-loop ========
               // i din render/overlay-del
               
               if(currentTool!=="lasso"&&currentTool !== 'select'){isDraggingSelection = false;if (selSessionActive) commitSelectionSession();clearSelection();}
               
               
                  // visa urklippet i overlay p√• nuvarande (ev. drag) position
                if (selectionImageCanvas &&selectionBBox) {
                  const showX = isDraggingSelection ? dragSelX : selectionBBox.x;
                  const showY = isDraggingSelection ? dragSelY : selectionBBox.y;

                  const { w, h } = selectionBBox;
                  const p = _imageXYtoCanvasXY(showX, showY);
                  const z = _effectiveZoom();
                  ctx.drawImage(selectionImageCanvas, p.x, p.y, w*z, h*z);

                  // ‚Äúmarching ants‚Äù
                  const p0 = _imageXYtoCanvasXY(showX, showY);
                  const p1 = _imageXYtoCanvasXY(showX + w, showY + h);
                  ctx.save();
                  ctx.setLineDash([4,3]);
                  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                  ctx.strokeRect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y);
                    const curX = (isDraggingSelection && typeof dragSelX === 'number') ? dragSelX : selectionBBox.x;
                    const curY = (isDraggingSelection && typeof dragSelY === 'number') ? dragSelY : selectionBBox.y;

                    // Om du har ‚Äúpreviews‚Äù f√∂r resize, anv√§nd dem ‚Äì annars fall tillbaka till selectionBBox
                    const curW = (isResizingSelection && typeof rc_prevW === 'number') ? rc_prevW : selectionBBox.w;
                    const curH = (isResizingSelection && typeof rc_prevH === 'number') ? rc_prevH : selectionBBox.h;

                    if (selectionPathImg && selectionOrigBBox && currentTool === 'lasso') {
                      const z = _effectiveZoom();
                      ctx.save();

                      // bild‚Üísk√§rm
                      ctx.translate(drawstartx, drawstarty);
                      ctx.scale(z, z);

                      // Mappa originalkonturen (selectionPathImg i bildkoordinater)
                      // fr√•n selectionOrigBBox ‚Üí till nuvarande bbox (curX/curY/curW/curH)
                      ctx.translate(curX, curY);
                      ctx.scale(curW / selectionOrigBBox.w, curH / selectionOrigBBox.h);
                      ctx.translate(-selectionOrigBBox.x, -selectionOrigBBox.y);

                      ctx.setLineDash([4,3]);
                      // (valfritt: animera "marching" om du vill)
                      // ctx.lineDashOffset = -(performance.now() / 50) % 7;

                      ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                      ctx.stroke(selectionPathImg);
                      ctx.restore();
                    }
                  ctx.restore();
                  //corners ---NYTT
                    ctx.save();
                    ctx.strokeStyle = 'black';
                    ctx.fillStyle = 'white';
                    ctx.lineWidth = 1;
                    const size = HANDLE_SIZE_SCR; // storlek p√• handtaget
                    const corners = [
                      {x: p0.x, y: p0.y}, // top-left
                      {x: p1.x, y: p0.y}, // top-right
                      {x: p0.x, y: p1.y}, // bottom-left
                      {x: p1.x, y: p1.y} // bottom-right
                    ];
                    for (const c of corners) {
                      ctx.fillRect(c.x - size/2, c.y - size/2, size, size);
                      ctx.strokeRect(c.x - size/2, c.y - size/2, size, size);
                    }
                    ctx.restore();
                }

                if(isdragdrag&&currentTool === 'lasso')_drawLassoOverlay();
                if(isdragdrag&&isRectSelecting&&currentTool === 'select')_drawSelectOverlay();
                drawResizeOverlay();
            
            
            
                window.requestAnimationFrame(check);   
            }; 
            
            check();
            
            // Process mouse events
            window.addEventListener("mousemove", (e) => {
                
                
            if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
              
        resizePreviewFromCanvasXY(x, y);  // <<<<<<<<<< NYTT
        // (rita overlay i din render-loop via drawResizeOverlay())
        
      }    
                
                
           if (e.target === canvas){      
                
    const mousePos = getCanvasMousePosition(e);
    x = mousePos.x;
    y = mousePos.y;
    
    isposetive = false;
    if (isdirposetive < x) {
        isposetive = true;
    }
    isdirposetive = x;
    
    isposetivey = false;
    if (isdirposetivey < y) {
        isposetivey = true;
    }
    isdirposetivey = y;
    
    // Handle image dragging
    if(isMovingImage && currentImage&&!selectionNeedsClick){
        currentImageX = (x - dragOffsetX);
        currentImageY = (y - dragOffsetY);
    }
    
    // Handle selection tool
    if (isSelecting && (currentTool === 'select')) {
        selectionEndX = Math.floor((x - drawstartx) / zoom);
        selectionEndY = Math.floor((y - drawstarty) / zoom);
        
        
        
    }
    
    // Handle drawing when mousemove with pen tool
    if (isDrawing  && currentTool === 'pen'&&!movescrolly&&!movescrollx) {
        drawPixel(x, y);
    }
    
    
    
}});
            
            window.addEventListener("mousedown", (e) => {
                if (e.target === canvas){ 
    const mousePos = getCanvasMousePosition(e);
    x = mousePos.x;
    y = mousePos.y;
    

    
    
    // Check if clicking on the image overlay first
 if(currentImage && x >= currentImageX && x <= currentImageX + currentImageWidth &&
                   y >= currentImageY && y <= currentImageY + currentImageHeight){
                    if(!isMovingImage){
                        // Begin dragging the image
                        isMovingImage = true;
                        dragOffsetX = x - (currentImageX);;
                        dragOffsetY = y - (currentImageY);
                        selectionNeedsClick=false;
                    }
                   
                    else {
                        // If already dragging, finalize by drawing the image permanently onto the drawing canvas
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                    }
                    
                    
                    return;
                }
                else if((currentTool === 'select')&&currentImage!=null){
                        
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                        
                        
                    }
    
    
    // Handle UI interaction with corners and scrollbars
    if (x >= drawstartx-30 && x < drawstartx && y >= drawstarty-30 && y < drawstarty+10) {
        movecorners1 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('NW'); 
        return;
    }
    if (x >= drawstartx+drawareax-10 && x < drawstartx+drawareax+30 && y >= drawstarty-30 && y < drawstarty+10) {
        movecorners2 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('NE');   
        return;
    }
    if (x >= drawstartx-30 && x < drawstartx && y >= drawstarty+drawareay && y < drawstarty-10+drawareay+30) {
        movecorners3 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('SW');    
        return;
    }
    if (x >= drawstartx+drawareax-10 && x < drawstartx+drawareax+30 && y >= drawstarty+drawareay-10 && y < drawstarty+drawareay+30) {
        movecorners4 = true;
        dragStartX = x;
        dragStartY = y;
        resizeStart('SE');
        return;
    }
    
    // Handle scrollbar interactions
    let sbThickness = getScrollbarThickness();
    if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
        if (x <= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue + (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) &&
           x >= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue &&
           y >= canvas.height/devicePixelRatio - sbThickness && y <= canvas.height/devicePixelRatio) {
            movescrollx = true;
            savescrollxvalue = x;
            return;
        }
    }
    if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
        if (x <= canvas.width/devicePixelRatio && x >= canvas.width/devicePixelRatio - sbThickness &&
           y >= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue &&
           y <= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue + (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
            movescrolly = true;
            savescrollyvalue = y;
            return;
        }
    }
    // Process tool actions if inside the drawing area and below the toolbar
    if (x >= drawstartx && x < drawstartx + drawareax &&
        y >= drawstarty && y < drawstarty + drawareay && y > 100) {
        
        const canvasX = Math.floor((x - drawstartx) / zoom);
        const canvasY = Math.floor((y - drawstarty) / zoom);
        
    if (currentTool === 'eyedropper') {
        updateEyedropperBuffer();
        const data = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
        const hexColor = `#${data[0].toString(16).padStart(2, '0')}${data[1].toString(16).padStart(2, '0')}${data[2].toString(16).padStart(2, '0')}`;

        brushColor = hexColor;
        isTransparentBrush = false;
        switchTool('pen');
        return;
    }
        else if (currentTool === 'fill') {
            // Fill tool
            beginAction();
            floodFill(canvasX, canvasY);
            endAction();
            
        }
        else if ((currentTool === 'select')) {
            // Selection tool
            isSelecting = true;
            selectionStartX = canvasX;
            selectionStartY = canvasY;
            selectionEndX = canvasX;
            selectionEndY = canvasY;
            
            
        }
        else if(currentTool === 'text'){
             
            const text = prompt("Enter your text:"); // Prompt user for text input
            if (text) {
                beginAction();
                drawText(x, y, text); // Draw the text on the canvas
                endAction();
            }
        }
        
        
        
        else if (currentTool === 'pen') {
            // Draw with pen
             beginAction();
            isDrawing = true;
            lastX = 0;
            lastY = 0;
            drawPixel(x, y);
            
           
        }
    }
                } });    
            
            window.addEventListener('mouseup', (e) => {
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
  resizeCommit();                   // <<<<<<<<<< NYTT
  movecorners1 = movecorners2 = movecorners3 = movecorners4 = false;
}
    movescrollx = false;
    movescrolly = false;
    isposetive = false;
    scrollx = movescrollxvalue;
    scrolly = movescrollyvalue;
    
    if(isDrawing==true)endAction();
    // Stop drawing
    isDrawing = false;
    lastX = 0;
    lastY = 0;




    
    

    
    
// i mouseup/touchend f√∂r select:
isSelecting = false;
selLeft = Math.min(selectionStartX, selectionEndX); // om du anv√§nder dessa lokalt
selTop  = Math.min(selectionStartY, selectionEndY);
// ... men slutligen:
//if(currentTool === 'select')_finalizeRectSelection();
});
            
            // Stop drawing if the mouse leaves the canvas
            window.addEventListener('mouseout', () => {
                isDrawing = false;
                lastX = 0;
                lastY = 0;
            });
           // ===== MOBILE DEVICE SUPPORT =====
           
           
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false}); 
            let touchTimer = null;
            let delatare=false;
            function handleTouchStart(e) {
        e.preventDefault();
        
        if (e.touches.length === 2) {
            clearTimeout(touchTimer);
            if(delatare==true){delatare=false;undo();}
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastPinchDistance = Math.hypot(dx, dy);
            return;
        }
        if (e.touches.length === 1){
            
            touchTimer = setTimeout(() => {
                delatare=false;
            
        }, 40);}
        
        
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();

        const touchX = Math.round((touch.clientX - rect.left) * (canvas.width / rect.width / devicePixelRatio));
        const touchY = Math.round((touch.clientY - rect.top) * (canvas.height / rect.height / devicePixelRatio));

        // Update global position variables
        x = touchX;
        y = touchY;
                // Handle image interaction
    if (currentImage) {
    // Check if touch is on the image
    if (touchX >= currentImageX && touchX <= currentImageX + currentImageWidth &&
        touchY >= currentImageY && touchY <= currentImageY + currentImageHeight) {
        
       if(!isMovingImage){
                        // Begin dragging the image
                        isMovingImage = true;
                        dragOffsetX = x - currentImageX;
                        dragOffsetY = y - currentImageY;
                        selectionNeedsClick=false;
                    } else {
                        // If already dragging, finalize by drawing the image permanently onto the drawing canvas
                        let unzoomedX = Math.floor((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.floor((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                    }
                    return;
    }
    else if((currentTool === 'select')&&currentImage!=null){
                        
                        let unzoomedX = Math.round((currentImageX - drawstartx) / zoom);
                        let unzoomedY = Math.round((currentImageY - drawstarty) / zoom);
                        drawingCtx.drawImage(currentImage, unzoomedX, unzoomedY, currentImageOriginalWidth, currentImageOriginalHeight);
                        currentImage = null;
                        isMovingImage = false;
                        
                        
                    }
    
    
    
}



                    
                 
                







        let cornerTouched = 0;
        // Check each corner with a slightly larger touch area for mobile
        const cornerSize = 60; // Larger touch target for corners on mobile

        // Top-left corner
        if (touchX >= drawstartx-cornerSize && touchX < drawstartx+cornerSize && 
            touchY >= drawstarty-cornerSize && touchY < drawstarty+cornerSize) {
            cornerTouched = 1;
            
        }
        // Top-right corner
        else if (touchX >= drawstartx+drawareax-cornerSize && touchX < drawstartx+drawareax+cornerSize && 
                 touchY >= drawstarty-cornerSize && touchY < drawstarty+cornerSize) {
            cornerTouched = 2;
           
        }
        // Bottom-left corner
        else if (touchX >= drawstartx-cornerSize && touchX < drawstartx+cornerSize && 
                 touchY >= drawstarty+drawareay-cornerSize && touchY < drawstarty+drawareay+cornerSize) {
            cornerTouched = 3;
           
        }
        // Bottom-right corner
        else if (touchX >= drawstartx+drawareax-cornerSize && touchX < drawstartx+drawareax+cornerSize && 
                 touchY >= drawstarty+drawareay-cornerSize && touchY < drawstarty+drawareay+cornerSize) {
            cornerTouched = 4;
            
        }

        // Check if it's a double tap on a corner
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;

        if (cornerTouched > 0 && tapLength < doubleTapThreshold && cornerTouched === lastTapCorner) {
            // Double tap detected on the same corner!
            console.log("Double tap on corner " + cornerTouched);

            // Enable dragging for the corresponding corner
            if (cornerTouched === 1) {
                movecorners1 = true;
                resizeStart('NW');  
                return;
            } else if (cornerTouched === 2) {
                movecorners2 = true;
                resizeStart('NE');
                return;
            } else if (cornerTouched === 3) {
                movecorners3 = true;
                resizeStart('SW');
                return;
            } else if (cornerTouched === 4) {
                movecorners4 = true;
                resizeStart('SE');  
                return;
            }

            dragStartX = touchX;
            dragStartY = touchY;
        }

        // Update the last tap info for next time
        if (cornerTouched > 0) {
            lastTapTime = currentTime;
            lastTapCorner = cornerTouched;

            // Return early to prevent other interactions from happening
            // when touching a corner but not double-tapping yet
            if (!movecorners1 && !movecorners2 && !movecorners3 && !movecorners4) {
                return;
                
            }
        }
        
        
        
        
        
        
        // Check for scrollbar interaction on touch devices
        let sbThickness = getScrollbarThickness();
        if (drawareax - (canvas.width/devicePixelRatio*2) > -canvas.width/devicePixelRatio-50) {
            if(touchX <= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue + (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01) &&
               touchX >= canvas.width/devicePixelRatio/2 - (((canvas.width/devicePixelRatio)/drawareax)*canvas.width/devicePixelRatio/1.01)/2 + movescrollxvalue &&
               touchY >= canvas.height/devicePixelRatio - sbThickness && touchY <= canvas.height/devicePixelRatio) {
                movescrollx = true;
                savescrollxvalue = touchX - movescrollxvalue ;
                return;
                
            }
        }
        if (drawareay - (canvas.height/devicePixelRatio*2) > -canvas.height/devicePixelRatio-50) {
            if(touchX <= canvas.width/devicePixelRatio && touchX >= canvas.width/devicePixelRatio - sbThickness &&
               touchY >= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue &&
               touchY <= 50 + canvas.height/devicePixelRatio/2 - (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)/2 + movescrollyvalue + (((canvas.height/devicePixelRatio-200)/drawareay)*canvas.height/devicePixelRatio/1.01)) {
                movescrolly = true;
                savescrollyvalue = touchY- movescrollyvalue ;;
                return;
                
            }
        }
                    // Check for tool actions inside the drawing area
        if (touchX >= drawstartx && touchX < drawstartx + drawareax &&
           touchY >= drawstarty && touchY < drawstarty + drawareay ) {

            const canvasX = Math.floor((touchX - drawstartx) / zoom);
            const canvasY = Math.floor((touchY - drawstarty) / zoom);

            if (currentTool === 'eyedropper') {
                updateEyedropperBuffer();
                const data = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
                const hexColor = `#${data[0].toString(16).padStart(2, '0')}${data[1].toString(16).padStart(2, '0')}${data[2].toString(16).padStart(2, '0')}`;

                brushColor = hexColor;
                isTransparentBrush = false;
                switchTool('pen');
                return;
            }
             else if (currentTool === 'fill') {
                // Fill tool
                beginAction();
                floodFill(canvasX, canvasY);
                endAction();
            }
             else if ((currentTool === 'select')) {
                // Selection tool
                isSelecting = true;
                selectionStartX = canvasX;
                selectionStartY = canvasY;
                selectionEndX = canvasX;
                selectionEndY = canvasY;

           }
           else if(currentTool === 'text'){
                const text = prompt("Enter your text:"); // Prompt user for text input
                if (text) {
                    beginAction();
                    drawText(touchX, touchY, text); // Draw the text on the canvas
                    endAction();
                }
           }
           
             else if (currentTool === 'pen') {
                // Rest of your existing touch handling code for drawing
                isDrawing = true;
                lastX = 0;
                lastY = 0;
                beginAction();
                delatare=true;
                drawPixel(touchX, touchY);
                
                
                

           }
        }
    }

function handleTouchMove(e) {
    e.preventDefault();
    
    
    if (e.touches.length === 2 && lastPinchDistance !== null) {

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.hypot(dx, dy);

        const delta = newDistance - lastPinchDistance;

        // üîç Zooma in/ut beroende p√• distans√§ndring
        let newzoom =zoom/zomzomzom;
        
        if (Math.abs(delta) > 5) {
            if (delta > 0) newzoom *= 1.05;
            else newzoom *= 0.95;

            newzoom = Math.max(0.10, Math.min(newzoom, 50)); // begr√§nsa zoomniv√•
            
                    zoomvalue = Math.round(newzoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
            
            
            lastPinchDistance = newDistance;
        }
        return;
    }
    
    
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();

    // Convert to canvas coordinates
    const touchX = (touch.clientX - rect.left) * (canvas.width / rect.width / devicePixelRatio);
    const touchY = (touch.clientY - rect.top) * (canvas.height / rect.height / devicePixelRatio);

    // Update directions
    isposetive = isdirposetive < touchX;
    isdirposetive = touchX;
    
    isposetivey = isdirposetivey < touchY;
    isdirposetivey = touchY;

    // Update current position
    x = touchX;
    y = touchY;

    // Handle selection tool
    if (isSelecting && (currentTool === 'select')) {
        selectionEndX = Math.floor((x - drawstartx) / zoom);
        selectionEndY = Math.floor((y - drawstarty) / zoom);
    }


   // Move the image if it's in moving state
    if (isMovingImage && currentImage&&!selectionNeedsClick) {
        currentImageX = touchX - dragOffsetX;
        currentImageY = touchY - dragOffsetY;
    }

    // Handle drawing with pen tool
    if (isDrawing && currentTool === 'pen'&&!movescrolly&&!movescrollx) {
        //beginAction();
        drawPixel(touchX, touchY);
     
    }
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
        resizePreviewFromCanvasXY(x, y);  // <<<<<<<<<< NYTT
        // (rita overlay i din render-loop via drawResizeOverlay())
        return;
      }
    
 
}

   function handleTouchEnd(e) {
    e.preventDefault();
    clearTimeout(touchTimer);
    if (e.touches.length < 2) {
        lastPinchDistance = null;
    }
    movescrollx = false;
    movescrolly = false;
    if(isDrawing==true){endAction();}
    // Stop drawing
    isDrawing = false;
    lastX = 0;
    lastY = 0;
    
    if (movecorners1 || movecorners2 || movecorners3 || movecorners4) {
        resizeCommit();                   // <<<<<<<<<< NYTT
        movecorners1 = movecorners2 = movecorners3 = movecorners4 = false;
        
      }
    

    
    
    // i mouseup/touchend f√∂r select:
isSelecting = false;
selLeft = Math.min(selectionStartX, selectionEndX); // om du anv√§nder dessa lokalt
selTop  = Math.min(selectionStartY, selectionEndY);
// ... men slutligen:
//if(currentTool === 'select')_finalizeRectSelection();
    

}
           
     //==========LOAD IMAGES MOBILE===========
                
document.addEventListener('DOMContentLoaded', function () {
  const directInput = document.getElementById('directFileInput');
  if (!directInput) return;

  directInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    if (!file.type || !file.type.startsWith('image/')) {
      alert('Filen √§r inte en bild.');
      return;
    }
    try {
      const bmp = await createImageBitmap(file);
      await _activateLoadedBitmap(bmp);
    } catch (err) {
      console.error(err);
      alert('Kunde inte l√§sa bilden.');
    } finally {
      // Nollst√§ll inputen s√• samma fil kan v√§ljas igen
      directInput.value = '';
    }
  });
});
    document.addEventListener('DOMContentLoaded', function() {
    // Get the save button
    const saveBtn = document.getElementById('saveImageBtn');
    
    // Add click event handler for save button
    if (saveBtn) {
        saveBtn.addEventListener('click', function() {
            // Create a temporary canvas for the final image
            const saveCanvas = document.createElement('canvas');
            const saveCtx = saveCanvas.getContext('2d', {alpha: true});
            
            // Set dimensions to match the current drawing area
            const displayWidth = Math.floor(drawareax / zoom);
            const displayHeight = Math.floor(drawareay / zoom);
            saveCanvas.width = displayWidth;
            saveCanvas.height = displayHeight;
            
            // Draw the content WITHOUT filling white background first
            disableSmoothing(saveCtx);
            
            // Just draw the drawing canvas directly   
            saveCtx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0, 0, displayWidth, displayHeight);
            
            try {
                // Convert to data URL with PNG format to support transparency
                const dataURL = saveCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'maxpaint-image.png';
                link.href = dataURL;
                link.click();
                console.log("Image saved successfully with transparency");
            } catch (e) {
                console.error("Error saving image:", e);
                alert("Could not save the image. Error: " + e.message);
            }
        });
    }
    
    // Mobile-specific adjustments for the save button
    function adjustButtonsForMobile() {
        const saveBtn = document.getElementById('saveImageBtn');
        const openLabel = document.querySelector('label[for="directFileInput"]');
        
        if (mobileAndTabletCheck()) {
            // Mobile styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "15px 25px";
                saveBtn.style.fontSize = "22px";
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "120px";
            }
            if (openLabel) {
                openLabel.style.padding = "15px 25px";
                openLabel.style.fontSize = "22px"; // Exact same font size
                openLabel.style.top = "15px";
                openLabel.style.minWidth = "120px";
            }
        } else {
            // Desktop styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "8px 15px";
                saveBtn.style.fontSize = "16px"; // Exact same font size
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "90px";
            }
            if (openLabel) {
                openLabel.style.padding = "8px 15px";
                openLabel.style.fontSize = "16px"; // Exact same font size
                openLabel.style.top = "10px";
                openLabel.style.minWidth = "90px";
            }
        }
    }
    
    // Call initially
    adjustButtonsForMobile();
    
    // Also adjust when window is resized
    window.addEventListener('resize', adjustButtonsForMobile);
});



    
           // ===== END MOBILE DEVICE SUPPORT =====
            resizeCanvas();
            
        </script>
<script>
// Assuming drawingCanvas, drawingCtx, undoStack, redoStack are defined globally or accessible.
// Also assuming drawareax, drawareay, zoom, showGrid, gridBtn, lastSaveTime, actionInProgress are defined.

// ===== Robust history state (canvas + vy) =====
// ===== History (synkron, region-baserad) =====
const HIST_MAX = 100;

let savelabel,savebmp,savew,saveh,savedrawareax,savedrawareay,savedrawstartx,savedrawstarty,savezoom;



function pruneStack(stack){
  while (stack.length > HIST_MAX) {
    const old = stack.shift();
    // old.bmp √§r en <canvas>; l√•t GC ta den
  }
}

function captureRegionSnapshot() {
  // Snapshot av aktuella bildm√•tt (w,h) ‚Äì inte hela backing-canvas
  const z = (zoom > 10 ? zoom/100 : zoom);
  const imgW = Math.max(1, Math.floor(drawareax / z)) | 0;
  const imgH = Math.max(1, Math.floor(drawareay / z)) | 0;

  const snap = document.createElement('canvas');
  snap.width = imgW; snap.height = imgH;
  const sctx = snap.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(sctx);
  // kopiera exakt bildytan 0..imgW/0..imgH
  sctx.drawImage(drawingCanvas, 0, 0, imgW, imgH, 0, 0, imgW, imgH);

  return { snap, imgW, imgH };
}

function beginAction(label = ''){
  const { snap, imgW, imgH } = captureRegionSnapshot();
  
    savelabel=label;
    savebmp=snap;
    savew=imgW;
    saveh=imgH;
    savedrawareax=drawareax;
    savedrawareay=drawareay;
    savedrawstartx=drawstartx;
    savedrawstarty=drawstarty;
    savezoom=zoom;
  
  
}
function destroyAction(){
    
    savelabel=null;
    savebmp=null;
    savew=0;
    saveh=0;
    savedrawareax=0;
    savedrawareay=0;
    savedrawstartx=0;
    savedrawstarty=0;
    savezoom=0;
    
    
}




function endAction(){
  if (typeof markDirty === 'function'){
      
      if(savedrawareax===0){return;}
      
      undoStack.push({
        savelabel,
        bmp: savebmp,         // snapshot canvas av bildytan
        w: savew, h: saveh,  // "logiska" bildm√•tt i px (utan zoom)
        drawareax:savedrawareax, drawareay:savedrawareay, drawstartx:savedrawstartx, drawstarty:savedrawstarty, zoom:savezoom
      });
      pruneStack(undoStack);

      // Ny gren -> t√∂m redo
      while (redoStack.length) redoStack.pop();
      
      
      
      
      
      
      markDirty();
  }
}

function restoreState(state){
  if (!state || !state.bmp) return;

  // 1) Rensa HELA backing-canvas (undvik gamla rester)
  drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  if (typeof disableSmoothing === 'function') disableSmoothing(drawingCtx);

  // 2) Rita tillbaka snapshoten p√• (0,0) i originalstorlek
  drawingCtx.drawImage(state.bmp, 0, 0);

  // 3) √Öterst√§ll vy ‚Äì baserat p√• sparad zoom + bildm√•tt
  zoom       = state.zoom;
  drawareax  = state.w * zoom;
  drawareay  = state.h * zoom;
  drawstartx = state.drawstartx;
  drawstarty = state.drawstarty;

  // 4) UI sync
  const zval = Math.round(zoom * 100);
  const zsl  = document.getElementById('zoomSlider');
  const zlbl = document.getElementById('zoomLabel');
  if (zsl)  zsl.value = zval;
  if (zlbl) zlbl.innerText = "Zoom: " + zval + "%";

  if (typeof markDirty === 'function') markDirty();
}

function undo(){
  if (!undoStack.length) return;

  // flytta current ‚Üí redo
  const cur = captureRegionSnapshot();
  redoStack.push({
    bmp: cur.snap, w: cur.imgW, h: cur.imgH,
    drawareax:drawareax, drawareay:drawareay, drawstartx:drawstartx, drawstarty:drawstarty, zoom:zoom
  });
  pruneStack(redoStack);

  // √•terst√§ll f√∂reg√•ende
  const prev = undoStack.pop();
  restoreState(prev);
}

function redo(){
  if (!redoStack.length) return;

  // flytta current ‚Üí undo
  const cur = captureRegionSnapshot();
  undoStack.push({
    bmp: cur.snap, w: cur.imgW, h: cur.imgH,
    drawareax:drawareax, drawareay:drawareay, drawstartx:drawstartx, drawstarty:drawstarty, zoom:zoom
  });
  pruneStack(undoStack);

  // √•terst√§ll n√§sta
  const next = redoStack.pop();
  restoreState(next);
}

const gridBtn = document.getElementById('gridBtn');
function updateGridButton() {
    if (!gridBtn) return;
    gridBtn.style.backgroundColor = showGrid ? '#d4ffd4' : '#f1f1f1';
    gridBtn.style.borderColor = showGrid ? '#4CAF50' : '#ccc';
}

gridBtn.addEventListener('click', () => { showGrid = !showGrid; updateGridButton(); });
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);
window.addEventListener('keydown', function(e) {
  const z = e.key.toLowerCase() === 'z';
  const y = e.key.toLowerCase() === 'y';
  const mod = e.ctrlKey || e.metaKey;
  if (mod && z && !e.shiftKey) { e.preventDefault(); undo(); }
  else if (mod && (y || (z && e.shiftKey))) { e.preventDefault(); redo(); }
  if (e.key.toLowerCase() === 'g') { showGrid = !showGrid; updateGridButton(); }
});
updateGridButton();</script>

<script>
(function(){
  const editBtn = document.getElementById('edit-color-btn');
  const pop     = document.getElementById('color-editor');

  // Flytta editorn direkt under <body> (undviker att n√•gon container klipper den)
  if (pop && pop.parentElement !== document.body) {
    document.body.appendChild(pop);
  }

  function measureShown(el){
    const wasHidden = getComputedStyle(el).display === 'none';
    const prevD = el.style.display, prevV = el.style.visibility;
    if (wasHidden){ el.style.visibility='hidden'; el.style.display='block'; }
    const r = el.getBoundingClientRect();
    if (wasHidden){ el.style.display=prevD||''; el.style.visibility=prevV||''; }
    return { w: r.width || 360, h: r.height || 220 };
  }



  function placeEditor(){
    if (!editBtn || !pop || pop.classList.contains('hidden')) return;

    const { w: ew, h: eh } = measureShown(pop);
    const br = editBtn.getBoundingClientRect();
    const M  = 8;

    // centrera √∂ver knappen
    let left = Math.round(br.left + br.width/2 - ew/2);


    // helst ovanf√∂r; annars under
    let top = Math.round(br.top - eh - M);


    pop.style.left = (canvas.width/2/ devicePixelRatio)-250 + 'px';
    pop.style.top  = top  + 'px';
    
  }

  // Knyt till din befintliga üé®-knapp + mutationer + resize
  editBtn?.addEventListener('click', ()=> requestAnimationFrame(placeEditor));
  new MutationObserver(()=> requestAnimationFrame(placeEditor))
    .observe(pop, { attributes:true, attributeFilter:['class','style'] });
  window.addEventListener('resize', placeEditor);
})();

(function initMainToolSidebar(){
  const bar = document.getElementById('mainToolBar');
  if (!bar) return;

  // --- UI helper
  function setActive(tool){
    bar.querySelectorAll('[data-tool]').forEach(b=>{
      const on = b.dataset.tool === tool;
      b.classList.toggle('is-active', on);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  }
  // g√∂r √•tkomlig f√∂r andra hooks
  window.__setSidebarActive = setActive;

  // --- Klick p√• knappar
  bar.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-tool]');
    if (!btn) return;
    const tool = btn.dataset.tool;

    // anv√§nd din befintliga switchTool om den finns
    if (typeof window.switchTool === 'function') {
      window.switchTool(tool);
    } else {
      window.currentTool = tool;
    }
    // trigga global sync
    window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool } }));
  });

  ['pointerdown','mousedown','touchstart'].forEach(ev=>{
    bar.addEventListener(ev, e=>e.stopPropagation(), {passive:false});
  });

  // --- Globalt event ‚Üí uppdatera sidomenyn
  window.addEventListener('toolchange', (e)=>{
    const t = (e && e.detail && e.detail.tool) || window.currentTool || 'pen';
    setActive(t);
  });

  // --- Hooka nuvarande switchTool om den redan finns
  function wrapExistingSwitch(){
    if (typeof window.switchTool === 'function' && !window.__wrappedSwitchTool){
      const orig = window.switchTool;
      window.switchTool = function(tool){
        const out = orig.apply(this, arguments);
        window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool } }));
        return out;
      };
      window.__wrappedSwitchTool = true;
    }
  }
  wrapExistingSwitch();

  // --- F√•nga FRAMTIDA assignment till window.switchTool
  if (!window.__switchToolSetterInstalled){
    let _st = window.switchTool; // kan vara undefined nu
    Object.defineProperty(window, 'switchTool', {
      configurable: true,
      get(){ return _st; },
      set(fn){
        // wrap varje g√•ng n√•gon s√§tter en ny funktion
        _st = function(){
          const tool = arguments[0];
          const r = fn && fn.apply(this, arguments);
          window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool } }));
          return r;
        };
        window.__wrappedSwitchTool = true;
      }
    });
    window.__switchToolSetterInstalled = true;
  }

  // --- Fallback: om kod byter currentTool direkt utan switchTool
  (function pollCurrentTool(){
    let last = window.currentTool || null;
    setInterval(()=>{
      const now = window.currentTool || null;
      if (now !== last){
        last = now;
        window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool: now } }));
      }
    }, 200);
  })();

  // Initiera aktiv knapp
  setActive(window.currentTool || 'pen');
  
  
  
  
})();



</script>
</body>
</html>