<!DOCTYPE html>

<html>
<head>
<title>MaxPaint</title>
<meta charset="utf-8"/>
<meta name="viewport"
  content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">

<meta content="maxpaint,paint" name="keywords"/>


<!-- PWA -->
<link rel="manifest" href="/manifest.webmanifest">
<meta name="theme-color" content="#111111">

<!-- iOS speciellt -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-status-bar-style" content="black-translucent">
<link rel="touch-icon" href="icons/icon-180.png">


<link href="icons/icon-192.png" rel="icon" type="image/vnd.microsoft.icon"/>
<style>
            

/* =========================
   ROOT: DPR-agnostisk UI-skala
   ========================= */
:root{
  /* Skala UI efter viewportens minsta sida ‚Äì inte efter DPR */
  --ui-scale: clamp(0.85, min(100vw, 100vh) / 1100, 1.15);
  font-size: calc(16px * var(--ui-scale));
}

/* =========================
   GLOBAL BAS
   ========================= */
html{ background:#000; }
body{
  overscroll-behavior:none;
  touch-action:none;
  background:#000;
  -webkit-user-select:none !important;
          user-select:none !important;
  -webkit-touch-callout:none !important;
  -webkit-tap-highlight-color:transparent;
}

/* Canvas ‚Äì l√•t gester g√• h√§r, inte p√• UI */
canvas{
  display:block; margin:0 auto; z-index:0;
  background:#50459b;
  image-rendering:-moz-crisp-edges;
  image-rendering:-webkit-crisp-edges;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
  -ms-interpolation-mode:nearest-neighbor;
  touch-action:none;
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  user-select:none;
}

/* Anti-hairline utility ‚Äì l√§gg p√• alla flytande paneler/bars */
.ui-panel,
#topBar, #bottomDock, #mainToolBar, #centerTopBar,
.dropdown, .menu, .color-pop{
  overflow:hidden;
  background-clip:padding-box;
  -webkit-background-clip:padding-box;
  outline:1px solid transparent;
  transform:translateZ(0);
  backface-visibility:hidden;
  will-change:transform;
}

#copyBtn, #pasteBtn, #undoBtn, #redoBtn{
  display:none !important;
}

/* =========================
   TOP BAR & DROPDOWNS
   ========================= */
#topBar{
  pointer-events:none !important;
  position:fixed;
  left:0.625rem; right:0.625rem;
  top:0.75rem;                               /* fallback */
  top:calc(0.75rem + env(safe-area-inset-top));
  top:calc(0.75rem + constant(safe-area-inset-top));
  display:flex; align-items:center; gap:0.625rem;
  z-index:2300;
  overflow:visible !important;
  background-clip:border-box !important;
  -webkit-background-clip:border-box !important;
  outline:none !important;
}
.topbar-group{ display:flex; gap:0.625rem; pointer-events:auto; }

.topbtn{
  height:3rem; min-width:3rem; padding:0 0.75rem;
  display:flex; align-items:center; justify-content:center; gap:0.5rem;
  background:rgba(30,30,30,.92); color:#fff;
  border:1px solid rgba(255,255,255,.12);
  border-radius:0.75rem; cursor:pointer;
  box-shadow:0 0.75rem 1.125rem rgba(0,0,0,.25);
  transition:transform .06s ease, background .12s ease, box-shadow .12s ease;
  font-size:0.9rem;
}
.topbtn:hover, .topbtn:focus-visible{
  background:rgba(45,45,45,.98);
  box-shadow:0 0.75rem 1.75rem rgba(0,0,0,.38);
}
.topbtn:active{ transform:translateY(0.0625rem); }
.hamburger{ font-size:1.25rem; line-height:1; }

/* Backdrop under dropdowns men √∂ver resten */
#menuBackdrop{
  position:fixed; inset:0; background:transparent; display:none;
  z-index:2200;
}
#menuBackdrop.show{ display:block; }

/* Meny/dropdown ‚Äì en definition */
.dropdown, .menu{
  position:absolute; top:3.5rem; left:0;
  min-width:13.75rem; padding:0.375rem; display:none;
  background:rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12); border-radius:0.75rem;
  box-shadow:0 0.625rem 1.875rem rgba(0,0,0,.35);
  z-index:2400; pointer-events:auto;
}
.menu.open, .dropdown.open{ display:block; }
.menu .item, .dropdown .item{
  width:100%; text-align:left; padding:0.625rem 0.75rem; border-radius:0.625rem;
  background:transparent; color:#fff; border:none; cursor:pointer;
  font-size:0.9rem;
}
.menu .item:hover, .dropdown .item:hover{ background:rgba(255,255,255,.08); }
.dropdown .item.active{ background:rgba(255,255,255,.18); font-weight:600; }

/* =========================
   TRANSFORM-FLYTKNAPP (H√ñGER)
   ========================= */
#transformBtn{
  position:fixed;
  top:0.75rem; top:calc(0.75rem + env(safe-area-inset-top));
  right:0.75rem; right:calc(0.75rem + env(safe-area-inset-right));
  z-index:100010; pointer-events:auto;
  width:3.5rem; height:3.5rem; border-radius:9999px;
  display:flex; align-items:center; justify-content:center;
  background:rgba(30,30,30,.92); color:#fff;
  border:1px solid rgba(255,255,255,.12);
  box-shadow:0 0.625rem 1.5rem rgba(0,0,0,.35);
  cursor:pointer; user-select:auto;
  transform:none !important;
  font-size:1rem;
}
#transformBtn:active{ transform:translateY(0.0625rem) !important; }

#transformMenu{
  position:absolute; right:0; top:calc(4.25rem + env(safe-area-inset-top)); display:none;
  padding:0.5rem; border-radius:0.875rem;
  background:rgba(30,30,30,.97); color:#fff;
  border:1px solid rgba(255,255,255,.12);
  box-shadow:0 0.75rem 2rem rgba(0,0,0,.35);
  z-index:2400; pointer-events:auto;
  width:max-content;
}
#transformMenu.open{ display:block; }
#transformMenu .item{
  width:100%; text-align:left; padding:0.75rem 0.875rem; border-radius:0.75rem;
  background:transparent; color:#fff; border:none; cursor:pointer;
  font-size:0.9rem;
}
#transformMenu .item:hover{ background:rgba(255,255,255,.08); }

/* =========================
   CENTER TOP BAR (Copy/Paste/Undo/Redo)
   ========================= */
#dockWrap3{
  position:fixed; left:0; right:0;
  top:calc(0.75rem + env(safe-area-inset-top));
  display:flex; justify-content:center;
  pointer-events:none; z-index:100000;
}
#dockWrap3 > *{ pointer-events:auto; }

#centerTopBar{
  display:flex; gap:0.75rem;
  background:rgba(30,30,30,.92);
  border:1px solid rgba(255,255,255,.12);
  border-radius:1.25rem; padding:0.5rem 0.875rem;
  box-shadow:0 0.625rem 1.625rem rgba(0,0,0,.35);
}
#centerTopBar .barbtn{
  min-width:2.8125rem; height:3rem;
  display:flex; align-items:center; justify-content:center;
  background:transparent; color:#fff;
  border:none; border-radius:0.875rem; font-size:1rem; cursor:pointer;
  transition:background .15s, box-shadow .15s, transform .06s;
}
#centerTopBar .barbtn:hover,
#centerTopBar .barbtn:focus-visible{
  background:rgba(255,255,255,.08);
  box-shadow:0 0.375rem 1rem rgba(0,0,0,.25);
}
#centerTopBar .barbtn:active{ transform:translateY(0.0625rem); }

/* =========================
   SIDEBAR ‚Äì MAIN TOOL BAR
   ========================= */
#dockWrap2{
  position:fixed; top:0; left:env(safe-area-inset-left, 0);
  height:100%; display:flex; align-items:center;
  pointer-events:none;
}
#dockWrap2 > *{ pointer-events:auto; }

#mainToolBar{
  display:grid; gap:0.625rem; padding:0.625rem;
  background:rgba(30,30,30,.9);
  border-radius:0.75rem; box-shadow:0 0.625rem 1.5rem rgba(0,0,0,.35);
  contain:layout paint;
}
#mainToolBar .tool-btn{
  width:3.5rem; height:3.5rem; display:grid; place-items:center;
  font-size:1.625rem; line-height:1;
  background:#444; color:#fff; border:none; border-radius:0.75rem;
  box-shadow:inset 0 0 0 0.125rem rgba(255,255,255,.15);
  cursor:pointer; user-select:none; outline:none;
}
#mainToolBar .tool-btn:hover{ filter:brightness(1.1); }
#mainToolBar .tool-btn:active{ transform:scale(.98); }
#mainToolBar .tool-btn.is-active{
  box-shadow:inset 0 0 0 0.125rem #fff, 0 0 0 0.125rem rgba(0,0,0,.55);
  background:#555;
}

/* =========================
   BOTTOM DOCK (center) + LANDSCAPE-H√ñGER
   ========================= */
#dockWrap{
  position:fixed; left:0; right:env(safe-area-inset-right);
  bottom:2.5rem; bottom:max(env(safe-area-inset-bottom), 2.5rem);
  display:flex; justify-content:center;
  pointer-events:none; z-index:1200;
}
#dockWrap > *{ pointer-events:auto; }

#bottomDock{
  max-width:min(47.5rem, 96vw);
  width:max-content;
  display:grid; gap:0.75rem;
  grid-template-columns:1fr auto; /* v√§nster: palett/brush, h√∂ger: üé® */
  padding:0.625rem 0.75rem; border-radius:0.875rem;
  background:rgba(30,30,30,.88);
  border:1px solid rgba(255,255,255,.09);
  box-shadow:0 0.625rem 1.875rem rgba(0,0,0,.35);
}

/* V√§nsterkolumn */
.dock-left{ display:grid; gap:0.625rem; }

/* Palett (2 rader default) */
.palette-grid{
  display:grid;
  grid-auto-flow:column;
  grid-auto-columns:4.375rem;               /* 70px */
  grid-template-rows:repeat(2, 4.375rem);   /* 70px */
  gap:0.375rem;                             /* 6px */
}
.palette-grid .color-swatch{
  width:4.3125rem; height:4.3125rem;        /* 69px */
  border-radius:0.4375rem;                  /* 7px */
  border:0.125rem solid transparent;        /* 2px */
  transition:transform .1s;
}
.palette-grid .color-swatch:hover{ transform:scale(1.1); }
.palette-grid .color-swatch.active{ border-color:#fff; box-shadow:0 0 0 0.0625rem #000; }

/* Brush row */
.brush-row{
  display:grid; grid-template-columns:1fr 1fr; gap:0.625rem; align-items:center;
}
#brushSizeSlider{ width:20rem; max-width:56vw; }
.brush-row label{ color:#fff; font-size:0.9rem; }

/* üé®-knapp h√∂ger */
.dock-right{ display:flex; align-items:center; }
.edit-btn{
  width:4.3125rem; height:4.3125rem; border-radius:0.4375rem;
  font-size:3.25rem;
}
.edit-btn:hover{ transform:scale(1.1); }

/* Landscape + touch: docken l√§ngs H√ñGER kant, centrerad p√• h√∂jden */
@media (orientation:landscape) and (pointer:coarse){
  #dockWrap{
    top:1.25rem; right:0; left:auto; bottom:auto;
    height:100%; display:flex; align-items:center; justify-content:flex-end;
  }
}

/* =========================
   COLOR-POPOVER (kort version)
   ========================= */
#colorWrap{
      position:fixed; left:0; right:0;
  top:10rem;
  display:flex; justify-content:center;
  pointer-events:none; z-index:100000;
    
    
    
}




.color-pop.hidden{ display:none; }
.color-pop{
  position:fixed !important;
  z-index:3000;
  max-width:min(26.25rem, calc(100vw - 1rem));
  background:#222; color:#fff;
  border:1px solid #444; border-radius:0.75rem;
  box-shadow:0 0.5rem 1.875rem rgba(0,0,0,.35);
  pointer-events:auto;
}
.color-pop-inner{ padding:0.75rem; }
#rainbowCanvas{
  width:100%;
  height:clamp(16.25rem, 50vh, 26.25rem);
  display:block; border:0; outline:0; cursor:crosshair;
}
#colorPreview{
  width:6.25rem; height:6.25rem; border-radius:0.625rem;
  box-shadow:0 0 0 0.0625rem rgba(0,0,0,.12) inset;
}
#hexOut{ font-size:1.875rem; }

/* =========================
   MODAL (enkel)
   ========================= */
.modal{
  display:none; position:fixed; inset:0; z-index:3000;
  background:rgba(0,0,0,.4);
}
.modal-content{
  background:#fefefe; width:18.75rem; margin:15% auto; padding:1.25rem;
  border:1px solid #888; border-radius:0.3125rem;
}

/* =========================
   KOMPAKT MOBILPROFIL
   ========================= */
@media (pointer:coarse), (max-width:48rem){
  /* Top bar + knappar */
  #topBar{ gap:0; height:2.375rem; }
  @media (orientation:landscape){#topBar{ left:1.625rem; }}
  .topbtn{
    height:2.375rem; min-width:2.375rem; padding:0 0.625rem; border-radius:0.5625rem;
    font-size:0.78rem; gap:0;
  }
  .hamburger{ font-size:0.875rem; }

  .menu, .dropdown{
    top:2.9375rem; min-width:11.25rem; padding:0.4375rem; border-radius:0.5625rem;
  }
  .menu .item, .dropdown .item{
    padding:0.5625rem 0.6875rem; font-size:0.72rem; border-radius:0.5625rem;
  }

  /* Center-TopBar */
  #dockWrap3{ left:6.5625rem; }
  #centerTopBar{ padding:0; gap:0; border-radius:0.625rem; }
  #centerTopBar .barbtn{
    width:0.0625rem; height:2.375rem; font-size:0.5rem; border-radius:0.625rem;
    -webkit-tap-highlight-color:transparent;
    outline:none; touch-action:manipulation;
  }
  #centerTopBar .barbtn:hover,
  #centerTopBar .barbtn:focus,
  #centerTopBar .barbtn:focus-visible{
    background:transparent !important; box-shadow:none !important;
  }
  @media (orientation:landscape){ #dockWrap3{ left:0; } }

  /* Transform-knapp + meny */
  #transformBtn{ width:2.5rem; height:2.5rem; font-size:1rem; }
  #transformMenu{ top:calc(3.625rem + env(safe-area-inset-top)); width:11.25rem; padding:0.4375rem; border-radius:0.6875rem; }
  #transformMenu .item{ padding:0.5625rem 0.6875rem; font-size:0.78rem; border-radius:0.5625rem; }

  /* Sidebar */
  #mainToolBar{ gap:0.4rem; padding:0.4rem; border-radius:0.6875rem; }
  #mainToolBar .tool-btn{
    width:2.4rem; height:2.4rem; font-size:1.15rem; border-radius:0.5625rem;
  }

  /* Bottom dock */
  #bottomDock{ padding:0.3125rem 0.4375rem; gap:0.4375rem; border-radius:0.6875rem; width:12.5rem; }
  .palette-grid{
    grid-auto-columns:1.8125rem;            /* 29px */
    grid-template-rows:repeat(2, 1.8125rem);
    gap:0.21875rem;                          /* 3.5px */
  }
  .palette-grid .color-swatch{ width:1.8125rem; height:1.8125rem; border-radius:0.3125rem; }
  .edit-btn{ width:1.8125rem; height:1.8125rem; border-radius:0.4375rem; font-size:1.25rem; }

  #brushSizeSlider, #zoomSlider{ max-width:36vw; height:1rem; }
  #zoomLabel, #brushSizeLabel{ font-size:0.5625rem; }
}

/* Extra: landscape + touch ‚Äì smal h√∂gerdocka med staplade sliders */
@media (orientation:landscape) and (pointer:coarse){
  #bottomDock{
    display:grid;
    grid-template-rows:auto auto auto; /* 1: palett, 2: edit-btn, 3: sliders */
    grid-template-columns: minmax(0, 1fr); /* fyll bredd, till√•t att krympa */
    row-gap: 0rem;                      /* ‚Üì mindre vertikalt mellanrum */
    justify-items: stretch;                /* inga extra sidogap */
    align-content: start;   
    width:4.6875rem;   /* 75px */
    height:85%;
    
  }
  #bottomDock > *{
    margin: 0;         /* nolla titel/p/knapp-marginaler som sp√§r ut */
    min-height: 0;     /* till√•t krymp */
    min-width: 0;      /* om n√•got barn (t.ex. slider) annars tvingar ut */
    }
  
  .palette-grid{
    grid-row:1;
    grid-auto-columns:1.8125rem;
    grid-template-rows:repeat(5, 1.8125rem);
  }
  .edit-btn{ grid-row:2; }
  .brush-row{
    grid-row:3; display:flex; flex-direction:column;
    gap:0.0rem; width:100%;
    padding:0rem 0rem;
  }
  .brush-row label{
    font-size:0.75rem; color:#fff; margin-bottom:0.125rem; text-align:left;
    padding:0rem 0rem; gap:0rem;
  }
  #brushSizeLabel, #zoomLabel{ font-size:0.5rem; color:#fff; padding:0rem 0rem; gap:0rem;}
  #brushSizeSlider, #zoomSlider{ width:100%; height:1.125rem; }
  #zoomLabel, #zoomSlider{ order:2; }
  #brushSizeLabel, #brushSizeSlider{ order:1; }
  #dockWrap{ right:env(safe-area-inset-right); }
  
  #dockWrap2{top:2rem;}
}

/* =========================
   Z-INDEX S√ÑKERHET
   ========================= */
#menuBackdrop{ z-index:2200 !important; }
#topBar{ z-index:2300 !important; }
.dropdown, .menu, #transformMenu{ z-index:2400 !important; }

/* =========================
   COLOR-POPOVER ‚Äì kompakt mobil
   ========================= */
@media (pointer:coarse), (max-width: 48rem) {
  .color-pop{
    /* smalare + tajtare p√• mobil */
    max-width: min(19rem, calc(100vw - 0.75rem));
    border-radius: 0.625rem;
  }
  .color-pop-inner{
    padding: 0.5rem;
  }

  /* F√§rgrutan mindre */
  #colorPreview{
    width: 3.25rem;
    height: 3.25rem;
    border-radius: 0.5rem;
  }

  /* HSV-rutan l√§gre */
  #rainbowCanvas{
    height: clamp(9rem, 36vh, 14rem);
  }

  /* Hex-text och √∂vrig typografi */
  #hexOut{
    font-size: 1rem;
    line-height: 1.1;
  }
  .color-pop .btn,
  .color-pop button{
    min-height: 2rem;
    padding: 0.375rem 0.625rem;
    font-size: 0.85rem;
    border-radius: 0.5rem;
  }
}

/* Extra krymp i landscape p√• mobil */
@media (orientation: landscape) and (pointer:coarse){
    
   #colorWrap{top:5rem;} 
    

  #rainbowCanvas{
    height: clamp(7.5rem, 32vh, 12rem);
  }
  #hexOut{
    font-size: 0.9rem;
  }
}




        </style>
</head>
<body>  
    
<label for="directFileInput" style="position:absolute; top:10px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; min-width:90px; text-align:center; font-size:16px;">Open Image</label>
<input accept="image/*" id="directFileInput" style="position:absolute; left:-200px;" type="file"/>
<!-- Save Image button, positioned much lower -->
<button id="saveImageBtn" style="position:absolute; top:130px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:90px; text-align:center; font-size:16px;">Save Image</button>
<button id="project1Btn" style="position:absolute; top:150px; left:0px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 1</button>
<button id="project2Btn" style="position:absolute; top:150px; left:100px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 2</button>
<button id="project3Btn" style="position:absolute; top:150px; left:202px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Canvas 3</button>
<button id="ResizeBtn" style="position: absolute;right: 0%; top:150px; z-index:1000; display:inline-block; background-color:#4CAF50; color:white; padding:8px 15px; border-radius:4px; font-weight:bold; cursor:pointer; border:none; min-width:60px; text-align:center; font-size:16px; ">Resize</button>
<div class="tool-buttons" style="position: absolute; left:500px; top: 30px; z-index: 110; display: grid; grid-template-columns: repeat(6, 100px); grid-gap: 5px; transform: translateY(-50%);">



<!-- Copy (action only) -->
<button class="tool-btn" id="copyBtn" title="Copy selection (Ctrl/Cmd+C)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M16 1H4c-1.1 0-2 .9-2 2v12h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="#333"/>
  </svg>
</button>
<!-- Paste (action only) -->
<button class="tool-btn" id="pasteBtn" title="Paste (Ctrl/Cmd+V)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <!-- clipboard + plus -->
    <path d="M16 2h-2.18C13.4.84 12.3 0 11 0S8.6.84 8.18 2H6c-1.1 0-2 .9-2 2v16c0 1.11.9 2 2 2h10c1.1 0 2-.89 2-2V4c0-1.1-.9-2-2-2zM11 2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1z" fill="#333"/>
    <path d="M12 8v3H9v2h3v3h2v-3h3v-2h-3V8h-2z" fill="#333"/>
  </svg>
</button>


<button class="tool-btn" id="undoBtn" style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Undo (Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5v-3L7 7l5 5V9c3.31 0 6 2.69 6 6 0 .34-.03.67-.08 1h2.02c.04-.33.06-.66.06-1 0-4.42-3.58-8-8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="redoBtn" style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Redo (Ctrl/Cmd+Y, Shift+Ctrl/Cmd+Z)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M12 5V2l5 5-5 5V9c-3.31 0-6 2.69-6 6 0 .34.03.67.08 1H4.06A7.98 7.98 0 0 1 4 15c0-4.42 3.58-8 8-8z" fill="#333"></path>
</svg>
</button>
<button class="tool-btn" id="gridBtn" style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;" title="Toggle Grid (G)">
<svg style="width:100%;height:100%;" viewbox="0 0 24 24">
<path d="M3 3h18v18H3V3zm6 0v18M15 3v18M3 9h18M3 15h18" fill="none" stroke="#333" stroke-width="2"></path>
</svg>
</button>


<!-- Rotate Right 90¬∞ -->
<button class="tool-btn" id="rotateRightBtn" title="Rotate +90¬∞ (R)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M15.55 5.55L11 1v3.07C6.05 4.56 2.5 8.54 2.5 13.5 2.5 18.47 6.53 22.5 11.5 22.5S20.5 18.47 20.5 13.5h-2
             c0 3.86-3.14 7-7 7s-7-3.14-7-7c0-3.58 2.65-6.53 6.1-6.96V9l4.45-3.45z" fill="#333"></path>
  </svg>
</button>

<!-- Rotate Left 90¬∞ -->
<button class="tool-btn" id="rotateLeftBtn" title="Rotate -90¬∞ (Shift+R)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M8.45 5.55L13 1v3.07C17.95 4.56 21.5 8.54 21.5 13.5c0 4.97-4.03 9-9 9s-9-4.03-9-9h2
             c0 3.86 3.14 7 7 7s7-3.14 7-7c0-3.58-2.65-6.53-6.1-6.96V9L8.45 5.55z" fill="#333"></path>
  </svg>
</button>

<!-- Flip Horizontal -->
<button class="tool-btn" id="flipHBtn" title="Flip Horizontal (H)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M3 4h8v16H3zM13 4h8v16h-8z" fill="#333"/>
    <path d="M12 4v16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Flip Vertical -->
<button class="tool-btn" id="flipVBtn" title="Flip Vertical (V)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M4 3h16v8H4zM4 13h16v8H4z" fill="#333"/>
    <path d="M4 12h16" stroke="#333" stroke-width="1.5"/>
  </svg>
</button>

<!-- Free Rotate -->
<button class="tool-btn" id="rotateFreeBtn" title="Rotate Free‚Ä¶ (Ctrl+R)"
  style="width:0px;height:0px;background-color:#f1f1f1;border:2px solid #ccc;border-radius:4px;cursor:pointer;padding:2px;position:relative;">
  <svg viewBox="0 0 24 24" style="width:100%;height:100%;">
    <path d="M12 2a10 10 0 100 20 10 10 0 000-20z" fill="none" stroke="#333" stroke-width="2"/>
    <path d="M12 6v6l4 2" stroke="#333" stroke-width="2" fill="none"/>
  </svg>
</button>




</div>




<!-- Bottom Dock -->
<!-- Centered Bottom Dock -->

<div id="dockWrap">
<div id="bottomDock" aria-label="Bottom dock controls">
  <div class="dock-left">
    <!-- 2 rader f√§rger -->
    <div class="palette-grid" id="dockPalette">
      <!-- Rad 1 -->
      <div class="color-swatch" data-color="black"  style="background:black;"></div>
      <div class="color-swatch" data-color="white"    style="background:white;"></div>
      <div class="color-swatch" data-color="blue"   style="background:blue;"></div>
      <div class="color-swatch" data-color="green"  style="background:green;"></div>
      <div class="color-swatch" data-color="yellow" style="background:yellow;"></div>
      <!-- Rad 2 -->
      <div class="color-swatch" data-color="cyan"   style="background:cyan;"></div>
      <div class="color-swatch" data-color="red"  style="background:red;"></div>
      <div class="color-swatch" data-color="purple" style="background:purple;"></div>
      <div class="color-swatch" data-color="orange" style="background:orange;"></div>
      <div class="color-swatch" data-color="checkerboard" style="background:repeating-conic-gradient(#ccc 0% 25%, #fff 0% 50%);"></div>
    </div>

    <!-- Kontroller under paletten: tv√• kolumner = Brush (v√§nster), Zoom (h√∂ger) -->
    <div class="brush-row">
      <div class="control-col" style="display:grid; gap:6px; align-items:center;">
        <label for="brushSizeSlider" id="brushSizeLabel">Brush Size: 1px</label>
        <input id="brushSizeSlider" type="range" min="1" max="10" step="1" value="1"
               style="width:100%;"/>
      </div>
      <div class="control-col" style="display:grid; gap:6px; align-items:center;">
        <label for="zoomSlider" id="zoomLabel">Zoom: 100%</label>
        <input id="zoomSlider" type="range" min="10" max="5000" value="100"
               style="width:100%;"/>
      </div>
    </div>
  </div>
  <!-- üé®-knapp till h√∂ger -->
  <div class="dock-right">
    <button id="edit-color-btn" class="edit-btn" type="button" title="Edit Color üé®">üé®</button>
  </div>
</div>
</div>

<!-- Flyttad/beh√•llen f√§rg-editor (popup) -->
<div id="colorWrap">
<div id="color-editor" class="color-pop hidden" role="dialog" aria-modal="true" aria-label="Edit Color">
  <div class="color-pop-inner">
    <div class="row">
      <canvas id="rainbowCanvas" width="512" height="300"></canvas>
    </div>
    <label class="row" style="gap:.5rem;align-items:center">
      Ljushet
      <input id="lightnessSlider" type="range" min="0" max="100" value="100"/>
      <span id="lightnessVal">100%</span>
    </label>
    <div class="row" style="gap:1rem;align-items:center;margin-top:.5rem;display:flex;">
      <!-- tom flex-spacer f√∂rst -> allt hamnar h√∂ger -->
      
      <button id="colorCancel" class="btn-secondary" type="button">Cancel</button>
      <button id="colorApply"  class="btn-primary"   type="button">Save</button>
      <div style="flex:1"></div>
      <div id="colorPreview"></div>
      <!-- ta bort inline-styles s√• CSS nedan kan styra storlek/utseende -->
      <code id="hexOut">#FFFFFF</code>
      
    </div>
  </div>
</div>
</div>
<div id="dockWrap2">
<!-- === MAIN TOOL SIDEBAR === -->
<nav id="mainToolBar" aria-label="Main tools">
  <button class="tool-btn" id="tool-pen"        data-tool="pen"        title="Pen (B)"         aria-pressed="false" style="font-size:38px;">‚úèÔ∏è</button>
  <button class="tool-btn" id="tool-fill"       data-tool="fill"       title="Fill (G)"        aria-pressed="false" style="font-size:38px;">ü™£</button>
  <button class="tool-btn" id="tool-eyedropper" data-tool="eyedropper" title="Eyedropper (I)"  aria-pressed="false" style="font-size:38px;">üéØ</button>
  <button class="tool-btn" id="tool-text"       data-tool="text"       title="Text (T)"        aria-pressed="false" style="font-size:38px;">üî§</button>
  <button class="tool-btn" id="tool-select"     data-tool="select"     title="Select (V)"      aria-pressed="false" style="font-size:38px;">‚ñ£</button>
  <button class="tool-btn" id="tool-lasso"      data-tool="lasso"      title="Lasso (L)"       aria-pressed="false" style="font-size:38px;">ü™¢</button>
</nav>
</div>







<div id="dockWrap3">
<div id="centerTopBar" aria-label="Clipboard & history">
  <button id="barCopy"  class="barbtn" title="Copy" style="font-size:48px;">‚ßâ</button>
  <button id="barPaste" class="barbtn" title="Paste" style="font-size:48px;">üìã</button>
  <button id="barUndo"  class="barbtn" title="Undo" style="font-size:48px;">‚ü≤</button>
  <button id="barRedo"  class="barbtn" title="Redo" style="font-size:48px;">‚ü≥</button>
</div>
    

    
</div>




<!-- === TOP BAR === -->
<div id="topBar" aria-label="Top toolbar">
  <!-- Hamburger (v√§nster) -->
  <div class="topbar-group" style="position:relative">
    <button id="hamburgerBtn" class="topbtn" aria-haspopup="true" aria-expanded="false" title="Menu">
      <span class="hamburger">‚ò∞</span> <span style="font-weight:600">Menu</span>
    </button>
    <div id="mainMenu" class="menu" role="menu" aria-label="Main menu">
      <button class="item" id="mnuNew"   role="menuitem">New</button>  
      <button class="item" id="mnuOpen"  role="menuitem">Open image‚Ä¶</button>
      <button class="item" id="mnuSave"  role="menuitem">Save image</button>
      <hr style="border:0;height:1px;background:rgba(255,255,255,.12);margin:6px 2px;">
      <button class="item" id="mnuResize" role="menuitem">Resize canvas‚Ä¶</button>
      <button class="item" id="mnuGrid"   role="menuitem">Toggle grid</button>
      <button class="item" id="mnuCameraCenter"   role="menuitem">Center camera</button>
    </div>
  </div>

  <!-- Projects direkt till v√§nster (bredvid hamburgern) -->
  <div class="topbar-group" style="position:relative">
    <button id="projectsBtn" class="topbtn" aria-haspopup="true" aria-expanded="false" title="Projects">
      Canvas 1 ‚ñæ
    </button>
    <div id="projectsDrop" class="dropdown" role="menu" aria-label="Projects">
      <button class="item" id="mnuProj1" role="menuitem">Canvas 1</button>
      <button class="item" id="mnuProj2" role="menuitem">Canvas 2</button>
      <button class="item" id="mnuProj3" role="menuitem">Canvas 3</button>
    </div>
  </div>
</div>

<div id="menuBackdrop" aria-hidden="true"></div>    




<!-- Right-side Transform menu -->
  <button id="transformBtn" title="Transform">‚ú•</button>
  <div id="transformMenu" role="menu" aria-label="Transform menu">
    <button class="item" id="trFlipH"  role="menuitem">Flip Horizontal</button>
    <button class="item" id="trFlipV"  role="menuitem">Flip Vertical</button>
    <hr style="border:0;height:1px;background:rgba(255,255,255,.12);margin:6px 2px;">
    <button class="item" id="trRotR"   role="menuitem">Rotate +90¬∞</button>
    <button class="item" id="trRotL"   role="menuitem">Rotate ‚àí90¬∞</button>
    <button class="item" id="trRotFree" role="menuitem">Rotate (free)‚Ä¶</button>
  </div>






















<!-- Resize Modal Dialog -->
<div class="modal" id="resizeModal">
<div class="modal-content">
<h3>Resize Canvas</h3>
<div class="form-group">
<label for="canvasWidth">Width (pixels):</label>
<input id="canvasWidth" min="10" type="number"/>
</div>
<div class="form-group">
<label for="canvasHeight">Height (pixels):</label>
<input id="canvasHeight" min="10" type="number"/>
</div>
<div class="button-row">
<button id="cancelResizeBtn">Cancel</button>
<button id="confirmResizeBtn">Resize</button>
</div>
</div>
</div>
<canvas height="10" id="myCanvas" style="border:0px solid black" width="10"></canvas>

    


 
<script>
(function(){
  // === Hj√§lpare: f√§rgkonvertering ===
  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  function hsv2rgb(h, s, v){
    h = ((h%360)+360)%360; s=clamp(s,0,1); v=clamp(v,0,1);
    const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
    let r=0,g=0,b=0;
    if (h<60){r=c;g=x;} else if (h<120){r=x;g=c;}
    else if (h<180){g=c;b=x;} else if (h<240){g=x;b=c;}
    else if (h<300){r=x;b=c;} else {r=c;b=x;}
    return {r:Math.round((r+m)*255), g:Math.round((g+m)*255), b:Math.round((b+m)*255)};
  }
  function rgb2hex(r,g,b){
    return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('').toUpperCase();
  }
  function hex2rgb(hex){
    hex = hex.trim();
    if (hex.startsWith('#')) hex = hex.slice(1);
    if (hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const num = parseInt(hex,16);
    if (Number.isNaN(num) || hex.length!==6) return null;
    return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 };
  }
  function cssColorToRGB(str){
    const ctx = document.createElement('canvas').getContext('2d');
    ctx.fillStyle = str; // l√•ter browsern parsa
    const d = ctx.fillStyle;
    // d blir i formatet #RRGGBB om det √§r giltigt
    return hex2rgb(d);
  }

  // === DOM-hj√§lpare: hitta aktiv palettknapp ===
  function getActiveSwatch(){
    // Anpassa vid behov: byt selektor om du anv√§nder andra klassnamn/attribut
    const btn = document.querySelector('.color-swatch.active');
    if (!btn) return null;
    // transparensdetekt
    const isTrans = btn.dataset.transparent === '1' ||
                    (btn.dataset.color || '').toLowerCase()==='transparent' ||
                    (getComputedStyle(btn).backgroundColor.includes('rgba(0, 0, 0, 0)'));
    return { el: btn, isTransparent: isTrans };
  }
  
  
  
  function getButtonColor(btn){
    // Prioritera data-color (hex), annars ber√§kna fr√•n computed style
    const data = btn.dataset.color;
    if (data && data !== 'transparent') {
      const rgb = hex2rgb(data) || cssColorToRGB(data);
      if (rgb) return rgb2hex(rgb.r,rgb.g,rgb.b);
    }
    const rgb = cssColorToRGB(getComputedStyle(btn).backgroundColor) || {r:255,g:255,b:255};
    return rgb2hex(rgb.r,rgb.g,rgb.b);
  }
  function setButtonColor(btn, hex){
    btn.dataset.color = hex;
    btn.style.background = hex;
    // ping till din app om du har central f√§rg:
    if (window.setCurrentColor) window.setCurrentColor(hex);
    document.dispatchEvent(new CustomEvent('palette:colorUpdated', {
      detail: { button: btn, color: hex }
    }));
  }

  // === UI-element ===
  const editBtn   = document.getElementById('edit-color-btn');
  const pop       = document.getElementById('color-editor');
  const canvas    = document.getElementById('rainbowCanvas');
  const ctx       = canvas.getContext('2d', { willReadFrequently:true });
  const slider    = document.getElementById('lightnessSlider');
  const sliderVal = document.getElementById('lightnessVal');
  const prevEl    = document.getElementById('colorPreview');
  const hexOut    = document.getElementById('hexOut');
  const btnCancel = document.getElementById('colorCancel');
  const btnApply  = document.getElementById('colorApply');
  
  let coloerpickeractive=false;
  
  // State f√∂r editorn
  let H = 0, S = 1, V = 1;      // Hue [0..360), Sat [0..1], Val [0..1]
  let startHex = '#FFFFFF';
  let targetBtn = null;

  function drawRainbow(){
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    let i = 0;
    for (let y=0;y<h;y++){
      const s = y/(h-1);
      for (let x=0;x<w;x++){
        const hdeg = (x/(w-1))*360;
        const {r,g,b} = hsv2rgb(hdeg, s, V);
        img.data[i++] = r;
        img.data[i++] = g;
        img.data[i++] = b;
        img.data[i++] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
    // rita mark√∂r
    const mx = Math.round((H/360) * (w-1));
    const my = Math.round(S * (h-1));
    ctx.beginPath();
    ctx.arc(mx+0.5, my+0.5, 6, 0, Math.PI*2);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.stroke();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
  }

  function updatePreview(){
    const {r,g,b} = hsv2rgb(H, S, V);
    const hex = rgb2hex(r,g,b);
    prevEl.style.background = hex;
    hexOut.textContent = hex;
  }

  function openEditor(){
      
      if(coloerpickeractive===true){pop.classList.add('hidden');coloerpickeractive=false;return;}
      
    const active = getActiveSwatch();
    targetBtn = active ? active.el : null;

    // Hantera transparens: disabla knapp och visa tooltip
    if (!targetBtn || (active && active.isTransparent)) {
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
      return;
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }

    startHex = getButtonColor(targetBtn);

    // Initiera HSV fr√•n startHex (approx: g√• via canvas parse)
    const rgb = hex2rgb(startHex);
    // snabb rgb->hsv:
    (function toHSV(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      const d=max-min;
      let h=0, s=max===0?0:d/max, v=max;
      if (d!==0){
        switch(max){
          case r: h=((g-b)/d)+(g<b?6:0); break;
          case g: h=((b-r)/d)+2; break;
          case b: h=((r-g)/d)+4; break;
        }
        h*=60;
      }
      H=h; S=s; V=v;
    })(rgb.r,rgb.g,rgb.b);

    slider.value = Math.round(V*100);
    sliderVal.textContent = slider.value + '%';
    
    coloerpickeractive=true;
    pop.classList.remove('hidden');
    drawRainbow();
    updatePreview();
  }

  function closeEditor(){
    coloerpickeractive=false;  
    pop.classList.add('hidden');
  }

  // === Events ===
  editBtn?.addEventListener('click', openEditor   );
  btnCancel?.addEventListener('click', closeEditor);

  btnApply?.addEventListener('click', ()=>{
    if (!targetBtn) return closeEditor();
    const {r,g,b} = hsv2rgb(H,S,V);
    const hex = rgb2hex(r,g,b);
    setButtonColor(targetBtn, hex);
    closeEditor();
  });

  // V (ljushet)
  slider?.addEventListener('input', ()=>{
    V = Number(slider.value)/100;
    sliderVal.textContent = slider.value + '%';
    drawRainbow();
    updatePreview();
  });

  // Pick i regnb√•gsrutan (H,S)
  function pickAt(evt){
    const rect = canvas.getBoundingClientRect();
    const x = clamp((evt.clientX || (evt.touches?.[0]?.clientX||0)) - rect.left, 0, rect.width-1);
    const y = clamp((evt.clientY || (evt.touches?.[0]?.clientY||0)) - rect.top, 0, rect.height-1);
    const rx = x/rect.width, ry = y/rect.height;
    H = rx * 360;
    S = ry;
    updatePreview();
    drawRainbow();
  }
  let dragging=false;
  canvas?.addEventListener('pointerdown', (e)=>{ dragging=true; canvas.setPointerCapture(e.pointerId); pickAt(e); });
  canvas?.addEventListener('pointermove', (e)=>{ if (dragging) pickAt(e); });
  window.addEventListener('pointerup', ()=>{ dragging=false; });

  // St√§ng p√• Escape/klick utanf√∂r
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeEditor(); });
  document.addEventListener('click', (e)=>{
    if (!pop.classList.contains('hidden') && !pop.contains(e.target) && e.target!==editBtn){
      closeEditor();
    }
  });

  // H√•ll edit-knappen i sync med aktiv palett
  document.addEventListener('click', ()=>{
    const active = getActiveSwatch();
    if (!active || active.isTransparent){
      editBtn.disabled = true;
      editBtn.title = "V√§lj en icke-transparent f√§rg f√∂rst";
    } else {
      editBtn.disabled = false;
      editBtn.title = "Redigera f√§rg üé®";
    }
  });

})();
</script>


<script>
            
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            document.getElementById("myCanvas").style.margin = "-8px -8px -8px -8px";
    
            // Create an in-memory canvas to store our drawing
            const drawingCanvas = document.createElement('canvas');
            const drawingCtx = drawingCanvas.getContext('2d');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            const eyedropperCanvas = document.createElement('canvas');
            const eyedropperCtx = eyedropperCanvas.getContext('2d');
            
            function updateEyedropperBuffer() {
                eyedropperCanvas.width = Math.floor(drawareax / zoom);
                eyedropperCanvas.height = Math.floor(drawareay / zoom);
                eyedropperCtx.drawImage(drawingCanvas, 0, 0);
            }
            
                        
                        
            const projectImages = [null, null, null];
            let currentproject=0;
            
            
            let undoMap = new Map();
            let redoMap = new Map();


            let undoStack = [];
            let redoStack = [];
            let canvasPools = new Map();
            let projectBitmaps = [null, null, null];     // ImageBitmap per projekt (RAM)
            let projectBlobURLs = [null, null, null];    // Fallback om bitmap inte g√•r
            let projectDirty = [false, false, false]; 
            
            let projectstopper=false;
            let tvfirst=[false, false, false];
            
            tvaaaa=false;
            treeee=false;
            
            let koko=false;
            function markDirty(){ projectDirty[currentproject] = true; }
            // Function to save the current drawing to the selected project
            async function saveCurrentProject(index) {
                // Spara vy/zoom mm som innan
                projectdrawareax[index] = drawareax;
                projectdrawareay[index] = drawareay;
                projectdrawstartx[index] = drawstartx;
                projectdrawstarty[index] = drawstarty;
                projectzoom[index] = zoom;
                projectcamerax[index]=camera.x;
                projectcameray[index]=camera.y;
                
                if (!projectDirty[index]) return; // ingenting att spara

                // Rensa tidigare cache
                if (projectBitmaps[index] && projectBitmaps[index].close) {
                  projectBitmaps[index].close();
                }
                if (projectBlobURLs[index]) {
                  URL.revokeObjectURL(projectBlobURLs[index]);
                  projectBlobURLs[index] = null;
                }

                try {
                  // Snabbaste v√§gen: ImageBitmap (ingen PNG-encode)
                  projectBitmaps[index] = await createImageBitmap(drawingCanvas);
                } catch (e) {
                  // Fallback: Blob (asynk) + object URL
                  const blob = await new Promise(res => drawingCanvas.toBlob(res, 'image/png'));
                  projectBlobURLs[index] = URL.createObjectURL(blob);
                  projectBitmaps[index] = null;
                }

                projectDirty[index] = false;
              }
            
            // Function to load the selected project image into the drawing canvas
            async function loadProject(index) {
            // Spara undo/redo-mapparna som du redan g√∂r
            if(koko===true){koko=false;return;}
            else koko=true;
            // 1) Spara *bara* om nuvarande projekt √§r dirty
            await saveCurrentProject(currentproject);
            // 2) V√§xla aktivt projekt (l√§ge/zoom m.m.)
            currentproject = index;
            drawareax   = projectdrawareax[index] ?? drawareax;
            drawareay   = projectdrawareay[index] ?? drawareay;
            drawstartx  = projectdrawstartx[index] ?? drawstartx;
            drawstarty  = projectdrawstarty[index] ?? drawstarty;
            camera.x     = projectcamerax[index];
            camera.y     = projectcameray[index];
            
            zoom        = projectzoom[index] ?? zoom;
            
            if(currentproject===1&&tvfirst[1]===false){
             //   zoomvalue = 100;
              //  document.getElementById("zoomSlider").value = zoomvalue;
               // document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
                tvaaaa=true;
                tvfirst[1]=true;
                
            }
            else if(currentproject===2&&tvfirst[2]===false){
               // zoomvalue = 100;
              //  document.getElementById("zoomSlider").value = zoomvalue;
              //  document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
                treeee=true;
                tvfirst[2]=true;
            }
            else{
               zoomvalue = Math.round(zoom* 100);
               document.getElementById("zoomSlider").value = zoomvalue;
               document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
                
            }
            // 3) Rita tillbaka fr√•n snabb-cache (bitmap) eller blob-URL
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            if (projectBitmaps[index]) {
              drawingCtx.drawImage(projectBitmaps[index], 0, 0);
            } else if (projectBlobURLs[index]) {
              const img = new Image();
              img.onload = () => drawingCtx.drawImage(img, 0, 0);
              img.src = projectBlobURLs[index];
            } else {
              // Nytt tomt projekt: fyll vitt (som du g√∂r vid init)
              drawingCtx.fillStyle = "white";
              drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
            // Nytt projekt startar "clean"
          
            if(redoMap.get(currentproject)?.length===0&&undoMap.get(currentproject)?.length===0){
              //  drawstartx = window.innerWidth/2- drawareax/2;
               // drawstarty = window.innerHeight/2 -drawareay/2;
            }
      
            projectDirty[index] = false;
          }
            document.getElementById('project1Btn').addEventListener('click', () => loadProject(0));
            document.getElementById('project2Btn').addEventListener('click', () => loadProject(1));
            document.getElementById('project3Btn').addEventListener('click', () => loadProject(2));
            
            document.getElementById('ResizeBtn').addEventListener('click', () => resizecanvas());
            
            
            const resizeModal = document.getElementById('resizeModal');
            const widthInput = document.getElementById('canvasWidth');
            const heightInput = document.getElementById('canvasHeight');
            const confirmResizeBtn = document.getElementById('confirmResizeBtn');
            const cancelResizeBtn = document.getElementById('cancelResizeBtn');
            
            function resizecanvas(){
                
                
                widthInput.value = Math.round(drawareax/zoom) ;
               heightInput.value = Math.round(drawareay/zoom);
               
        
            // Show the modal
             resizeModal.style.display = 'block';
                
            }
            cancelResizeBtn.addEventListener('click', function() {
                resizeModal.style.display = 'none';
            });
      
            // Confirm resize button event
confirmResizeBtn.addEventListener('click', async function() {
    let newWidth = parseInt(widthInput.value);
    let newHeight = parseInt(heightInput.value);

    // Validate dimensions
    
    if (isNaN(newWidth) || newWidth < 1 || isNaN(newHeight) || newHeight < 1 || newWidth>drawingCanvas.width||newHeight>drawingCanvas.height) {
        alert('Invalid dimensions');
        return;
    }

    // Create a snapshot of the current canvas content
    const snapshot = createCanvasSnapshot(drawingCanvas.width, drawingCanvas.height);

    // Create an offscreen canvas for resizing
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');
    offscreenCanvas.width = newWidth;
    offscreenCanvas.height = newHeight;

    // Draw the snapshot onto the offscreen canvas
    offscreenCtx.drawImage(snapshot, 0, 0, drawareax/zoom,drawareay/zoom, 0, 0, newWidth, newHeight);

    // Clear the drawing context
    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    disableSmoothing(drawingCtx);

    // Draw the resized image onto the main canvas
    drawingCtx.drawImage(offscreenCanvas, 0, 0);

    // Update drawing area dimensions
     

                    // Reset zoom to 1 after resizing
                    let newZoom = zoom; // Start with current zoom
                    if (newWidth * newZoom > window.innerWidth * 0.8 || 
                        newHeight * newZoom > (window.innerHeight - 100) * 0.8) {
                        // Image is too large at current zoom, recalculate
                        const zoomX = Math.round(((window.innerWidth * 0.8) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.8) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                    }
                    else if(((newWidth * newZoom < window.innerWidth * 0.5 ||newHeight * newZoom < (window.innerHeight - 100) * 0.5 ))){
                        
     
                        const zoomX = Math.round(((window.innerWidth * 0.5) / newWidth)*10)/10;
                        const zoomY = Math.round((((window.innerHeight - 100) * 0.5) / newHeight)*10)/10;
           
                        newZoom = Math.min(zoomX, zoomY);
                        
                        
                        
                    }
                    
                    
                    zoom = newZoom;
                    zoomvalue = Math.round(newZoom * 100);
                    document.getElementById("zoomSlider").value = zoomvalue;
                    document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";

    // Center the drawing area
    drawareax = newWidth*zoom; 
    drawareay = newHeight*zoom;
    
    drawstartx = (canvas.width / devicePixelRatio - drawareax) / 2;
    drawstarty = (canvas.height / devicePixelRatio - drawareay) / 2;

    // Close the modal
    resizeModal.style.display = 'none';
});
            function createCanvasSnapshot(width,height) {
                const offscreen = document.createElement('canvas');
                offscreen.width = width;
                offscreen.height = height;
                const offCtx = offscreen.getContext('2d');
                disableSmoothing(offCtx);
                
                offCtx.drawImage(drawingCanvas, 0, 0,width,height);
                return offscreen;
            }

            
            
            
            
              document.addEventListener('DOMContentLoaded', function() {
            // Get all color swatches
            const swatches = document.querySelectorAll('.color-swatch');

            // Add click event handlers
            swatches.forEach(swatch => {
            swatch.addEventListener('click', function() {
              swatches.forEach(s => s.classList.remove('active'));
              this.classList.add('active');
              brushColor = this.getAttribute('data-color');
              isTransparentBrush = brushColor === "checkerboard";
            });
          });

            // Set black as the initial active color
            const blackSwatch = document.querySelector('[data-color="black"]');
            if (blackSwatch) {
              blackSwatch.classList.add('active');
            }
          });
            document.addEventListener('DOMContentLoaded', function() {
                // Adjust color palette position for mobile
                function adjustColorPalettePosition() {
                  const colorPalette = document.querySelector('.color-palette');
                  if (colorPalette) {
                    if (mobileAndTabletCheck()) {
                      colorPalette.style.top = '0px'; // 8px lower for mobile
                      colorPalette.style.transform = 'none'; // Remove vertical centering transform
                    } else {
                      colorPalette.style.top = '50px'; // Original position for desktop
                      colorPalette.style.transform = 'translateY(-50%)'; // Original transform
                    }
                  }
                }

                // Call initially
                adjustColorPalettePosition();

                // Also call when window is resized
                window.addEventListener('resize', adjustColorPalettePosition);
              });
            
            function mobileAndTabletCheck() {
               const isMobile = {
                    Android: function() {
                        return navigator.userAgent.match(/Android/i);
                    },
                    BlackBerry: function() {
                        return navigator.userAgent.match(/BlackBerry/i);
                    },
                    iOS: function() {
                        return navigator.userAgent.match(/iPhone|iPod/i);
                    },
                    Opera: function() {
                        return navigator.userAgent.match(/Opera Mini/i);
                    },
                    Windows: function() {
                        return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
                    },
                    any: function() {
                        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()|| (navigator.userAgent.toLowerCase().indexOf('macintosh') > -1 &&navigator.maxTouchPoints && navigator.maxTouchPoints > 1));
                    }
                };
           
                return isMobile.any();
            }
            function quantizeValue(value, quantum) {
    return Math.round(value / quantum) * quantum;
}

            
            if(mobileAndTabletCheck()){
 
                drawingCanvas.width = 4000;
                drawingCanvas.height = 4000;
                tempCanvas.width = 4000;
                tempCanvas.height = 4000;
                
                
            }
            else{
                drawingCanvas.width = 10000;
                drawingCanvas.height = 10000;
                tempCanvas.width = 10000;
                tempCanvas.height = 10000;
            }
            
            // Fill the drawing canvas with white initially
            drawingCtx.fillStyle = "white";
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            // Disable image smoothing for crisp pixels
            function disableSmoothing(context) {
                context.imageSmoothingEnabled = false;
                context.webkitImageSmoothingEnabled = false;
                context.mozImageSmoothingEnabled = false;
                context.msImageSmoothingEnabled = false;
            }
            
            disableSmoothing(ctx);
            disableSmoothing(drawingCtx);
            disableSmoothing(tempCtx);
    
            let drawareax = 640;
            let drawareay = 640;
            let drawstartx = 1000;
            let drawstarty = 1000;
            let zoom = 1;
            let startan = false;
            
            let movecorners = false;
            let x = 0;
            let y = 0;
            let zoomvalue = 100;
            

            
            let isposetivey = false;
            let isdirposetivey = 0;
            
            // Variables for drawing
            let isDrawing = false;
            let brushSize = 1; // Default brush size
            let brushColor = "black"; // Default brush color
            
            // Function to draw at a specific point with pixel perfect precision
            let lastX = 0;
            let lastY = 0;
            
            // Variables to track drag start position
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Original content area in pixel units (not screen units)
            let originalContentX = 0;
            let originalContentY = 0;
            let originalContentWidth = drawareax;
            let originalContentHeight = drawareay;
            
            // Constants to address the edge pixel issue
            const EDGE_BUFFER = 2; // Add 2 extra pixels for drawing
            
            // Flag to track if an image has already been loaded
            let firstImageLoaded1 = false;
            let firstImageLoaded2 = false;
            let firstImageLoaded3 = false;
            
            // Track content dimensions for the first image
            let firstImageWidth = 0;
            let firstImageHeight = 0;
            let isImageWaiting = false;   // Image is loaded, waiting for first click
            let isMovingImage = false; 
            
            // **************** NEW VARIABLES FOR IMAGE LAYER ****************
            let currentImage = null;
            let currentImageWidth = 0;
            let currentImageHeight = 0;
            let currentImageOriginalWidth = 0;
            let currentImageOriginalHeight = 0;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            // ******************************************************************
            let lastTapTime = 0;
            let lastTapCorner = 0; 
            const doubleTapThreshold = 300; 
            let isTransparentBrush = false;
            let prevDrawAreaX, prevDrawAreaY, prevDrawStartX, prevDrawStartY, prevZoom;
            let currentTool = 'pen';      // Default tool
            let isSelecting = false;      // Track selection state
            let selectionStartX = 0;      // Selection coordinates
            let selectionStartY = 0;
            let selectionEndX = 0;
            let selectionEndY = 0;
            let selectionNeedsClick = false; 
            let isInteractingWithToolbar = false;
            
            let projectdrawareax = [drawareax, drawareax, drawareax];
            let projectdrawareay = [drawareay, drawareay, drawareay];
            let projectdrawstartx = [drawstartx, drawstartx, drawstartx];
            let projectdrawstarty = [drawstarty, drawstarty, drawstarty];
            let projectzoom = [0,0,0];
            let projectcamerax=[0, 0, 0];
            let projectcameray=[0, 0, 0];
            
            let prevzoom=1;
            let isTextToolActive = false;
            let currentImagecanvas=currentproject;
            let showGrid = false;
            const camera = {x: 0,y: 0};
            // Event listener for zoom slider
            document.getElementById("zoomSlider").addEventListener("input", (e) => {
                e.preventDefault();
                zoomvalue = Number(e.target.value);
                document.getElementById("zoomLabel").innerText = "Zoom: " + e.target.value + "%";
            });
            
            // Event listener for brush size slider
            document.getElementById("brushSizeSlider").addEventListener("input", (e) => {
                e.preventDefault();
                const sliderVal = Number(e.target.value);
                brushSize = sliderVal * sliderVal;
                document.getElementById("brushSizeLabel").innerText = "Brush Size: " + brushSize + "px";
            });
            
            const toolButtons = document.querySelectorAll('.tool-btn');

// Add pointer event listeners to each tool button
toolButtons.forEach(button => {
    button.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});

// Get the save and open buttons
const saveBtn = document.getElementById('saveImageBtn');
const openLabel = document.querySelector('label[for="directFileInput"]');

// Add pointer event listeners to the save and open buttons
if (saveBtn) {
    saveBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

if (openLabel) {
    openLabel.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
}

// Get all color swatches
const colorSwatches = document.querySelectorAll('.color-swatch');

// Add pointer event listeners to each color swatch
colorSwatches.forEach(swatch => {
    swatch.addEventListener('pointerdown', (e) => {
        e.preventDefault(); // Prevent default behavior
        e.stopPropagation(); // Stop the event from bubbling up
    });
});
            

// ========= Konfig =========
// ---- Tunables ----
// ====== Tunables ======
const FF_CHUNK = 1024;
const TOLER    = 10;   // RGB-tolerans
const TOL_A    = 10;   // alfa-tolerans

// ====== Helpers ======
function __screenToImage(sx, sy){
  const z = _effectiveZoom();
  return { x: ((sx - drawstartx)/z)|0, y: ((sy - drawstarty)/z)|0 };
}
function __clamp(v, lo, hi){ return v < lo ? lo : (v > hi ? hi : v); }

// Aktiv vy i BILD-koordinater (klipper mot hela canvasen)
function __activeRect(){
  const W = drawingCanvas.width|0, H = drawingCanvas.height|0;
  const z = _effectiveZoom();
  // var i bilden som visas p√• sk√§rmen:
  const x0 = 0;
  const y0 = 0;
  const vw = Math.max(1, Math.floor(drawareax / z));
  const vh = Math.max(1, Math.floor(drawareay / z));
  const x1 = Math.min(W, x0 + vw);
  const y1 = Math.min(H, y0 + vh);
  return {x0, y0, x1, y1, w: (x1-x0)|0, h: (y1-y0)|0};
}

// F√§rgcache (of√∂r√§ndrad)
let __colC=null, __colX=null, __lastBrush=null, __lastRGBA=[0,0,0,255];
function __getFillRGBA(){
  if (brushColor === __lastBrush) return __lastRGBA;
  let r=0,g=0,b=0,a=255;
  if (brushColor === "checkerboard"){ a = 0; }
  else if (typeof brushColor === 'string' && brushColor[0]==='#' && brushColor.length>=7){
    r=parseInt(brushColor.slice(1,3),16);
    g=parseInt(brushColor.slice(3,5),16);
    b=parseInt(brushColor.slice(5,7),16);
  } else {
    if (!__colC){ __colC=document.createElement('canvas'); __colC.width=1; __colC.height=1; __colX=__colC.getContext('2d'); }
    __colX.clearRect(0,0,1,1);
    __colX.fillStyle = brushColor || '#000';
    __colX.fillRect(0,0,1,1);
    const d = __colX.getImageData(0,0,1,1).data;
    r=d[0]; g=d[1]; b=d[2]; a=d[3];
  }
  __lastBrush=brushColor; __lastRGBA=[r,g,b,a];
  return __lastRGBA;
}

// Pooler (som tidigare)
let __visited  = new Uint32Array(FF_CHUNK*FF_CHUNK);
let __stack    = new Int32Array(FF_CHUNK*FF_CHUNK*2);
let __stamp    = 1;
let __offC=null, __offX=null;
function __getOff(w,h){
  if (!__offC){ __offC=document.createElement('canvas'); __offX=__offC.getContext('2d'); }
  if (__offC.width !== w || __offC.height !== h){ __offC.width=w; __offC.height=h; }
  return {c:__offC, x:__offX};
}

// ====== DROP-IN flood fill (SK√ÑRM-koordinater in) ======
function floodFill(startSX, startSY){
  const p = __screenToImage(startSX, startSY);
  const sX = p.x|0, sY = p.y|0;

  const W = drawingCanvas.width|0, H = drawingCanvas.height|0;
  if (sX<0 || sY<0 || sX>=W || sY>=H) return;

  // --- KLIPP TILL AKTIV VY ---
  const AR = __activeRect();
  if (sX < AR.x0 || sX >= AR.x1 || sY < AR.y0 || sY >= AR.y1) return;

  const [fR,fG,fB,fA] = __getFillRGBA();
  const tgt = drawingCtx.getImageData(sX, sY, 1, 1).data;
  const tR=tgt[0], tG=tgt[1], tB=tgt[2], tA=tgt[3];

  // tidig exit om ‚âà samma f√§rg
  {
    const dR=tR-fR, dG=tG-fG, dB=tB-fB, dA=tA-fA;
    if ((dR*dR + dG*dG + dB*dB) <= (TOLER*TOLER) && Math.abs(dA) <= TOL_A) return;
  }

  // --- Chunk f√∂rankrad, MEN klippt mot aktiva vyn ---
  const gridX = (sX & ~(FF_CHUNK-1));
  const gridY = (sY & ~(FF_CHUNK-1));
  const maxChunkX = Math.max(AR.x0, AR.x1 - FF_CHUNK);
  const maxChunkY = Math.max(AR.y0, AR.y1 - FF_CHUNK);
  const chunkX = __clamp(gridX, AR.x0, maxChunkX);
  const chunkY = __clamp(gridY, AR.y0, maxChunkY);
  const cW = Math.min(FF_CHUNK, AR.x1 - chunkX);
  const cH = Math.min(FF_CHUNK, AR.y1 - chunkY);
  if (cW<=0 || cH<=0) return;

  const imageData = drawingCtx.getImageData(chunkX, chunkY, cW, cH);
  const data = imageData.data;

  const lx0 = (sX - chunkX)|0;
  const ly0 = (sY - chunkY)|0;

  const T2 = TOLER*TOLER;
  function matchesLocal(x, y) {
    // (chunken √§r redan inne i AR, s√• extra AR-koll beh√∂vs inte h√§r)
    const idx = ((y * cW + x) << 2) | 0;
    const dR = data[idx]   - tR;
    const dG = data[idx+1] - tG;
    const dB = data[idx+2] - tB;
    const dA = data[idx+3] - tA;
    return (dR*dR + dG*dG + dB*dB) <= T2 && Math.abs(dA) <= TOL_A;
  }
  function setLocal(x, y) {
    const idx = ((y * cW + x) << 2) | 0;
    data[idx]=fR; data[idx+1]=fG; data[idx+2]=fB; data[idx+3]=fA;
    __visited[y*FF_CHUNK + x] = __stamp;
  }

  __stamp = (__stamp === 0x7ffffffe) ? (__visited.fill(0), 1) : (__stamp+1);
  let sp = 0;
  __stack[sp++] = lx0; __stack[sp++] = ly0;

  while (sp > 0) {
    const y = __stack[--sp]|0;
    const x = __stack[--sp]|0;

    if (x < 0 || y < 0 || x >= cW || y >= cH) continue;
    if (__visited[y*FF_CHUNK + x] === __stamp) continue;
    if (!matchesLocal(x, y)) continue;

    // expandera horisontellt (snabbt/t√§tt)
    let xl=x, xr=x;
    while (xl-1>=0 && __visited[y*FF_CHUNK + (xl-1)]!==__stamp && matchesLocal(xl-1,y)) xl--;
    while (xr+1<cW && __visited[y*FF_CHUNK + (xr+1)]!==__stamp && matchesLocal(xr+1,y)) xr++;

    for (let xx=xl; xx<=xr; xx++) setLocal(xx,y);

    // ovan/under
    for (let ny of [y-1, y+1]){
      if (ny<0 || ny>=cH) continue;
      let xx = xl;
      while (xx <= xr){
        while (xx<=xr && (__visited[ny*FF_CHUNK + xx]===__stamp || !matchesLocal(xx,ny))) xx++;
        if (xx>xr) break;
        __stack[sp++]=xx; __stack[sp++]=ny;
        xx++;
        while (xx<=xr && (__visited[ny*FF_CHUNK + xx]!==__stamp && matchesLocal(xx,ny))) xx++;
      }
    }
  }

  // Skriv tillbaka (√•teranv√§nd offscreen f√∂r snabbhet)
  const os = __getOff(cW, cH);
  os.x.putImageData(imageData, 0, 0);
  drawingCtx.clearRect(chunkX, chunkY, cW, cH);
  drawingCtx.drawImage(os.c, chunkX, chunkY);
}

function drawText(x, y, text) {
  // 1) Sk√§rm -> bildkoordinater
  const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : (window.zoom || 1);
  const relativeX = Math.floor((x - drawstartx) / z);
  const relativeY = Math.floor((y - drawstarty) / z);

  // Anv√§nd din nuvarande storlekslogik (√§ndra till "brushSize" rakt av om du vill)
  const fontSize = Math.max(1, Math.round((brushSize * 4) + 10));
  const fontStack = `${fontSize}px Arial, Helvetica, sans-serif`;

  // 2) M√§t f√∂rst p√• en tempor√§r context
  const measureCanvas = document.createElement('canvas');
  const mctx = measureCanvas.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(mctx);
  mctx.font = fontStack;
  // M√§tningar (med safaris√§kra fallbacks)
  const m = mctx.measureText(text);
  const ascent  = Math.ceil(m.actualBoundingBoxAscent  ?? m.fontBoundingBoxAscent  ?? fontSize * 0.8);
  const descent = Math.ceil(m.actualBoundingBoxDescent ?? m.fontBoundingBoxDescent ?? fontSize * 0.2);
  const pad = 2; // litet s√§kerhetsmarginal f√∂r Safari/iOS
  const w = Math.max(1, Math.ceil(m.width)) + pad * 2;
  const h = ascent + descent + pad * 2;

  // 3) Bygg canvasen i r√§tt storlek och rita texten med 'alphabetic' baseline
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  let tctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(tctx);
  tctx.font = fontStack;
  tctx.textAlign = 'left';
  tctx.textBaseline = 'alphabetic';
  tctx.fillStyle = brushColor;
  tctx.fillText(text, pad, pad + ascent);

  // 4) Koppla in i nya select-fl√∂det
  if (typeof clearSelection === 'function') clearSelection();
  selectionImageCanvas = c;
  selectionBBox = { x: relativeX, y: relativeY, w, h }; // anv√§nd faktiska canvasm√•tten inkl. pad

  if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

  hasSelection        = true;
  selSessionActive    = true;
  selectionSrcCanvas  = selectionImageCanvas;
  selectionHoleBBox   = null;
  selectionHoleCut    = true;
  if (typeof startSelectionSession === 'function') startSelectionSession();
  selErasedOnce = true;

  switchTool('select');

}


function roundToFullPixels(value) {
    return Math.round(value);
}

// Helper to check if two colors match
function colorsMatch(colorData, cssColor) {
    // Parse CSS color
    let targetR, targetG, targetB, targetA;
    
    if (cssColor.startsWith('rgba')) {
        const parts = cssColor.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = Math.round(parseFloat(parts[4]) * 255);
    } else if (cssColor.startsWith('rgb')) {
        const parts = cssColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (!parts) return false;
        
        targetR = parseInt(parts[1]);
        targetG = parseInt(parts[2]);
        targetB = parseInt(parts[3]);
        targetA = 255;
    } else {
        // For other formats, we need a different approach
        return false;
    }
    
    // Compare with small tolerance for floating point errors
    return Math.abs(colorData[0] - targetR) <= 2 && 
           Math.abs(colorData[1] - targetG) <= 2 && 
           Math.abs(colorData[2] - targetB) <= 2 && 
           Math.abs(colorData[3] - targetA) <= 2;
}

// Helper to set pixel color in ImageData
function setPixelInImageData(imageData, x, y, color) {
    const idx = (y * imageData.width + x) * 4;
    
    // Handle different color formats
    if (color.startsWith('#')) {
        // Hex color
        imageData.data[idx] = parseInt(color.substring(1, 3), 16);
        imageData.data[idx + 1] = parseInt(color.substring(3, 5), 16);
        imageData.data[idx + 2] = parseInt(color.substring(5, 7), 16);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else if (color.startsWith('rgba')) {
        // RGBA color
        const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = Math.round(parseFloat(parts[4]) * 255);
    } else if (color.startsWith('rgb')) {
        // RGB color
        const parts = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        imageData.data[idx] = parseInt(parts[1]);
        imageData.data[idx + 1] = parseInt(parts[2]);
        imageData.data[idx + 2] = parseInt(parts[3]);
        imageData.data[idx + 3] = 255; // Fully opaque
    } else {
        // Named colors or other formats
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 1;
        tempCanvas.height = 1;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.fillStyle = color;
        tempCtx.fillRect(0, 0, 1, 1);
        const colorData = tempCtx.getImageData(0, 0, 1, 1).data;
        
        imageData.data[idx] = colorData[0];
        imageData.data[idx + 1] = colorData[1];
        imageData.data[idx + 2] = colorData[2];
        imageData.data[idx + 3] = colorData[3];
    }
}
function switchTool(newTool, opts = {}) {
  // 1) S√§tt aktivt verktyg
  const prevTool = currentTool;
  currentTool = newTool;
  // 2) UI-knappar (l√§gg till lasso h√§r!)
  const toolButtons = {
    pen:        document.getElementById('penTool'),
    fill:       document.getElementById('fillTool'),
    select:     document.getElementById('selectTool'),
    eyedropper: document.getElementById('eyedropperTool'),
    text:       document.getElementById('textTool'),
    lasso:      document.getElementById('lassoTool') // ‚Üê NY
  };

  Object.keys(toolButtons).forEach(tool => {
    const btn = toolButtons[tool];
    if (!btn) return;
    if (tool === currentTool) {
      btn.style.backgroundColor = '#d4ffd4';
      btn.style.borderColor = '#4CAF50';
    } else {
      btn.style.backgroundColor = '#f1f1f1';
      btn.style.borderColor = '#ccc';
    }
  });

  // 3) Avsluta p√•g√•ende lasso-drag n√§r vi l√§mnar lasso-verktyget
  if (newTool !== 'lasso') {
    if (typeof isLassoActive !== 'undefined') isLassoActive = false;
    // Rensa markering helt bara om man vill
    if (opts.clearSelection === true && typeof clearSelection === 'function') {
      clearSelection();
    }
  }

  // (valfritt) logg
  // console.log("Switched to tool:", newTool, "from", prevTool);
}        
            // Ensure the drawing canvas is big enough for the image
            function ensureCanvasSize(width, height) {
                // Resize the drawing canvas if the new dimensions are larger
                if (width > drawingCanvas.width || height > drawingCanvas.height) {
                    // Save current content
                    const oldContent = document.createElement('canvas');
                    oldContent.width = drawingCanvas.width;
                    oldContent.height = drawingCanvas.height;
                    const oldCtx = oldContent.getContext('2d');
                    oldCtx.drawImage(drawingCanvas, 0, 0);

                    // Resize the canvas
                    drawingCanvas.width = Math.max(width, drawingCanvas.width);
                    drawingCanvas.height = Math.max(height, drawingCanvas.height);

                    // Fill with white and restore content
                    drawingCtx.fillStyle = "white";
                    drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    drawingCtx.drawImage(oldContent, 0, 0);

                    // Ensure smooth rendering is disabled
                    disableSmoothing(drawingCtx);

                    // Also resize temp canvas
                    tempCanvas.width = drawingCanvas.width;
                    tempCanvas.height = drawingCanvas.height;
                    disableSmoothing(tempCtx);

                    console.log(`Canvas resized to ${drawingCanvas.width}x${drawingCanvas.height}`);
                }
            }
            
            // Event listener for image open button
     
     
            function drawBresenhamLine(x0, y0, x1, y1, size) {
                x0 = Math.floor(x0);
                y0 = Math.floor(y0);
                x1 = Math.floor(x1);
                y1 = Math.floor(y1);

                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const sx = (x0 < x1) ? 1 : -1;
                const sy = (y0 < y1) ? 1 : -1;
                let err = dx - dy;

                const halfSize = Math.floor(size / 2);

                while (true) {
                    // Simplified: just draw one rectangle at each point
                    if (isTransparentBrush) {
                        drawingCtx.clearRect(x0 - halfSize, y0 - halfSize, size, size);
                    } else {
                        drawingCtx.fillRect(x0 - halfSize, y0 - halfSize, size, size);
                    }

                    if (x0 === x1 && y0 === y1) break;

                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x0 += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y0 += sy;
                    }
                }
            }
            function ensureIntDimension(value) {
                // Add a tiny bias (0.001) to prevent rounding down due to floating point errors
                return Math.round(value + 0.001);
            }
            // IMPROVED: More accurate pixel drawing
            function drawPixel(x, y) {
                const relativeX = Math.floor((x - drawstartx) / zoom );
                const relativeY = Math.floor((y - drawstarty) / zoom );

                // Set the brush color
                if (!isTransparentBrush) {
                    drawingCtx.fillStyle = brushColor;
                }

                if (x >= drawstartx && x < drawstartx + drawareax &&
                    y >= drawstarty && y < drawstarty + drawareay) {

                    if(lastX === 0 && lastY === 0) {
                        lastX = relativeX; 
                        lastY = relativeY;

                        const halfSize = Math.floor(brushSize / 2);
                        if (isTransparentBrush) {
                            drawingCtx.clearRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        } else {
                            drawingCtx.fillRect(relativeX - halfSize, relativeY - halfSize, brushSize, brushSize);
                        }
                    } else {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                        lastX = relativeX;
                        lastY = relativeY;
                    }
                } else {
                    if(lastX !== 0 && lastY !== 0) {
                        drawBresenhamLine(lastX, lastY, relativeX, relativeY, brushSize);
                    }
                    lastX = relativeX;
                    lastY = relativeY;
                }
            }
            
            // Initialize canvas size properly
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;

                // 1) M√§t nuvarande viewport (CSS-px) och spara bild-centrum i BILD-koordinater
                const prevVW = (canvas.width  || 0) / (dpr || 1);
                const prevVH = (canvas.height || 0) / (dpr || 1);
                const z = _effectiveZoom();

                // OBS: om canvas √§nnu inte √§r initierad kan prevVW/VH bli 0; hantera det
                const hadSize = prevVW > 0 && prevVH > 0;
                let cxImg = 0.5 * drawingCanvas.width;   // fallback = bildens mitt
                let cyImg = 0.5 * drawingCanvas.height;
                
                
                let cximage = [0.5 * drawingCanvas.width, 0.5 * drawingCanvas.width, 0.5 * drawingCanvas.width];
                let cyimage = [0.5 * drawingCanvas.height, 0.5 * drawingCanvas.height, 0.5 * drawingCanvas.height];
                
                if (hadSize) {
                  cxImg = (-drawstartx + prevVW/2) / z;
                  cyImg = (-drawstarty + prevVH/2) / z;
                  
                  cximage[0]=(-projectdrawstartx[0] + prevVW/2) / z;
                  cyimage[0]= (-projectdrawstarty[0] + prevVH/2) / z;

                  cximage[1]=(-projectdrawstartx[1] + prevVW/2) / z;
                  cyimage[1]= (-projectdrawstarty[1] + prevVH/2) / z;

                  cximage[2]=(-projectdrawstartx[2] + prevVW/2) / z;
                  cyimage[2]=(-projectdrawstarty[2] + prevVH/2) / z;
                  
                }
                
                
                
                
                
                
                
                
                // 2) R√§kna ny CSS-storlek
                const isStandalone = matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
                const cssW = window.innerWidth;
                const cssH = (isStandalone && mobileAndTabletCheck() && window.innerWidth < window.innerHeight)
                  ? screen.height
                  : window.innerHeight;

                // 3) S√§tt pixelstorlek utan kumulativ skala
                canvas.width  = Math.max(1, Math.round(cssW * dpr));
                canvas.height = Math.max(1, Math.round(cssH * dpr));
                canvas.style.width  = cssW + 'px';
                canvas.style.height = cssH + 'px';

                // 4) Nollst√§ll transform och skala en g√•ng till DPR (ingen ackumulering)
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(dpr, dpr);
                if (typeof disableSmoothing === 'function') disableSmoothing(ctx);

                // 5) BEVARA VYN: √•terst√§ll drawstart s√• att samma bild-centrum √§r kvar p√• sk√§rmen
                const curVW = cssW;
                const curVH = cssH;
                drawstartx = Math.round(curVW/2 - z * cxImg);
                drawstarty = Math.round(curVH/2 - z * cyImg);
                
                for (let i=0;i<3;i++){
                    if(i!==currentproject){
                        
                        projectdrawstartx[i]=Math.round(curVW/2 - z * cximage[i]);
                        projectdrawstarty[i]=Math.round(curVH/2 - z * cyimage[i]);
                        
                    }
                }
                

  // 6) Uppdatera sparade viewportm√•tt och re-mappa stackar via din ko()


  if (typeof markDirty === 'function') markDirty();
}
            
            //NYTT----------------------------------------------------------------------------------
            // ======== LASSO + TRANSFORM STATE ========
let lassoPoints = [];
let isLassoActive = false;
let hasSelection = false;
let selectionBBox = null;         // {x,y,w,h} i canvas-pixelkoordinater (inte sk√§rm)
let selectionPath = null;         // Path2D f√∂r klippning
let selectionMaskCanvas = null;   // mask av markerat omr√•de
let selectionImageCanvas = null;  // utdraget pixelinneh√•ll f√∂r transform
let selectionPathCanvas = null; // overlay-path i sk√§rm-koordinater
let selectionPathImg = null; 
let selectionOrigBBox = null;
let selSessionActive = false;
let selectionSrcCanvas = null;   // immutabel k√§lla (originalpixlar)
let selectionHoleBBox = null;    // var originalet satt (rekt eller lasso-bbox)
let selectionHoleCut  = false;   // har vi skurit h√•let i basen √§n?
// --- Selection history arming ---
let startdragstuffx=0;
let startdragstuffy=0;

function clearSelection() {
  hasSelection = false;
  isLassoActive = false;
  selectionBBox = null;
  selectionPathCanvas = null;  // om du anv√§nder den
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
  selectionOrigBBox = null;
  cow=false;
}

function _effectiveZoom(){
  // UI: zoomvalue √§r procent (t.ex. 100..5000). Fallback till zoom-faktor om procent saknas.
  //if (typeof window.zoomvalue === 'number') return Math.max(0.1, window.zoomvalue / 100);
  return zoom;
}
function _canvasXYtoImageXY(cx, cy){
  const z=_effectiveZoom();
  return { x: Math.floor((cx - drawstartx-camera.x)/z), y: Math.floor((cy - drawstarty-camera.y)/z) };
}
function _eraseSelectionAt(ix, iy){
  if (!selectionMaskCanvas) return;
  beginAction();
  drawingCtx.save();
  drawingCtx.translate(ix, iy);
  drawingCtx.globalCompositeOperation = 'destination-out';
  drawingCtx.drawImage(selectionMaskCanvas, 0, 0);
  drawingCtx.restore();
  drawingCtx.globalCompositeOperation = 'source-over';

}

// Bygg en mask (svart) fr√•n alphat i selectionImageCanvas
function _rebuildMaskFromImageCanvas(){
  if (!selectionImageCanvas) return;
  const w = selectionImageCanvas.width;
  const h = selectionImageCanvas.height;
  const m = document.createElement('canvas');
  m.width = w; m.height = h;
  const mctx = m.getContext('2d'); disableSmoothing(mctx);

  // L√§gg in bilden, l√•t alpha styra var masken finns
  mctx.drawImage(selectionImageCanvas, 0, 0);
  mctx.globalCompositeOperation = 'source-in';
  mctx.fillStyle = '#000';           // mask = svart d√§r alpha > 0
  mctx.fillRect(0,0,w,h);
  mctx.globalCompositeOperation = 'source-over';
  _binarizeAndDilateMask(m, 1); // ‚Üê NYTT
  selectionMaskCanvas = m;
}

function _imageXYtoCanvasXY(ix, iy) {
  const z = _effectiveZoom();
  const x = drawstartx+camera.x + ix * z;
  const y = drawstarty+camera.y + iy * z;
  return {x, y};
}

function _mkPathFromPoints(pts) {
  const p = new Path2D();
  if (!pts.length) return p;
  p.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<pts.length;i++) p.lineTo(pts[i].x, pts[i].y);
  p.closePath();
  return p;
}

function _computeBBoxFromImagePts(ptsImg) {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const p of ptsImg) {
    if (p.x<minX) minX=p.x;
    if (p.y<minY) minY=p.y;
    if (p.x>maxX) maxX=p.x;
    if (p.y>maxY) maxY=p.y;
  }
  const x=minX, y=minY, w=Math.max(1, maxX-minX+1), h=Math.max(1, maxY-minY+1);
  return {x, y, w, h};
}

// Ritar lasso-overlay (p√• huvud-ctx)
function _drawLassoOverlay() {
  if (!isLassoActive || lassoPoints.length < 2) return;
  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4,3]);
  ctx.beginPath();
  const p0 = lassoPoints[0];
  ctx.moveTo(p0.cx, p0.cy);
  for (let i = 1; i < lassoPoints.length; i++) ctx.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  ctx.stroke();
  ctx.restore();
}

// Ta ut markerat omr√•de till selectionImageCanvas + skapa mask
function _extractSelection() {
  if (!selectionBBox || !selectionPathImg) return;
  const { x, y, w, h } = selectionBBox;

  selectionImageCanvas = document.createElement('canvas');
  selectionImageCanvas.width = w;
  selectionImageCanvas.height = h;
  const sctx = selectionImageCanvas.getContext('2d');
  disableSmoothing(sctx);

  selectionMaskCanvas = document.createElement('canvas');
  selectionMaskCanvas.width = w;
  selectionMaskCanvas.height = h;
  const mctx = selectionMaskCanvas.getContext('2d');
  disableSmoothing(mctx);
  

  // Rita mask i bild-koordinater, translaterad s√• (x,y) blir (0,0)
  mctx.save();
  mctx.translate(-x, -y);
  mctx.fillStyle = '#000';
  mctx.fill(selectionPathImg);
  mctx.restore();
  _binarizeAndDilateMask(selectionMaskCanvas, 1);
  // Klipp originalbilden till masken
  sctx.drawImage(drawingCanvas, -x, -y);
  sctx.globalCompositeOperation = 'destination-in';
  sctx.drawImage(selectionMaskCanvas, 0, 0);
  sctx.globalCompositeOperation = 'source-over';
}

// Rensa originalpixlar endast inom masken
function _eraseSelectionFromDrawing() {
  const {x,y,w,h} = selectionBBox;
  drawingCtx.save();
  drawingCtx.translate(x, y);
  // skapa clip fr√•n mask
  const t = drawingCtx;
  t.globalCompositeOperation = 'destination-out';
  t.drawImage(selectionMaskCanvas, 0, 0);
  t.globalCompositeOperation = 'source-over';
  drawingCtx.restore();
}

// Klistra tillbaka (utan transform)
function _pasteSelectionAt(x, y) {
  drawingCtx.drawImage(selectionImageCanvas, x, y);
}

// === TRANSFORMER ===
function rotateSelection(deg) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg * Math.PI) / 180;
    let outW = w, outH = h;
    if (Math.abs(deg % 180) === 90) { outW = h; outH = w; }

    const out = document.createElement('canvas');
    out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();
    
    selectionSrcCanvas = selectionImageCanvas;
    
    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    return; // (commit sker n√§r sessionen avslutas)
  }

  // --- HELA BILDEN ---
  beginAction();  // <-- SAKNADES
  const z = _effectiveZoom();
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  // rotera dokumentytan (0..w,0..h) till out-canvas
  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  // rita endast dokumentytan (inte hela drawingCanvas)
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  // rensa gamla dokumentytan och skriv in roterade resultatet
  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);

  // uppdatera dokumentm√•tt + centrera vy om storleken √§ndrades
  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    // centrera
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }

  endAction();
}

function flipSelection(axis /* 'h'|'v' */) {
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox;
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const out = document.createElement('canvas');
    out.width = w; out.height = h;
    const octx = out.getContext('2d'); disableSmoothing(octx);

    const ax = (axis || 'h').toLowerCase();  // <-- normalisera
    octx.save();
    if (ax === 'h') { octx.translate(w, 0); octx.scale(-1, 1); }
    else            { octx.translate(0, h); octx.scale(1, -1); }
    octx.drawImage(selectionImageCanvas, 0, 0);
    octx.restore();

    selectionImageCanvas = out;
    _rebuildMaskFromImageCanvas();
    
    selectionSrcCanvas = selectionImageCanvas;
    
    // bbox of√∂r√§ndrad
    return;
  }

  // --- HELA BILDEN ---
  beginAction(); // <-- SAKNADES
  const z = _effectiveZoom();
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d'); disableSmoothing(tctx);

  const ax = (axis || 'h').toLowerCase();
  tctx.save();
  if (ax === 'h') { tctx.translate(w, 0); tctx.scale(-1, 1); }
  else            { tctx.translate(0, h); tctx.scale(1, -1); }
  // rita endast dokumentytan
  tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  tctx.restore();

  drawingCtx.clearRect(0, 0, w, h);
  drawingCtx.drawImage(tmp, 0, 0);
  endAction();
}

// Fri rotation med grad-dialog
function rotateSelectionFree() {
  const val = prompt('Rotate degrees (e.g. 20 or -30):', '20');
  const deg = Number(val);
  if (!isFinite(deg)) return;
   
  const selectionActive = !!(hasSelection && selectionBBox && selectionImageCanvas);

  if (selectionActive) {
    startSelectionSession();

    const { x, y, w, h } = selectionBBox; // K√ÑLL-l√§ge
    if (!selErasedOnce) { _eraseSelectionAt(x, y); selErasedOnce = true; }

    const rad = (deg*Math.PI)/180;
    const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
    const outW = Math.ceil(w*cos + h*sin);
    const outH = Math.ceil(h*cos + w*sin);

    const out = document.createElement('canvas'); out.width = outW; out.height = outH;
    const octx = out.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(octx);
    octx.translate(outW/2, outH/2);
    octx.rotate(rad);
    octx.drawImage(selectionImageCanvas, -w/2, -h/2);

    // Uppdatera f√∂rhandsbild + mask
    selectionImageCanvas = out;
    if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

    // VIKTIGT: L√•t commit anv√§nda den roterade bufferten
    selectionSrcCanvas = selectionImageCanvas;

    // Centrera nya bbox runt gamla centrum (som i rotateSelection)
    const cx = x + w/2, cy = y + h/2;
    const nx = Math.round(cx - outW/2);
    const ny = Math.round(cy - outH/2);
    selectionBBox = { x: nx, y: ny, w: outW, h: outH };
    
    return; // commit sker n√§r sessionen avslutas
  }

  // --- HELA BILDEN (fri vinkel) ---
  beginAction();
  const z = _effectiveZoom();
  const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);

  const rad = (deg*Math.PI)/180;
  const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
  const outW = Math.ceil(w*cos + h*sin);
  const outH = Math.ceil(h*cos + w*sin);

  const tmp = document.createElement('canvas'); tmp.width = outW; tmp.height = outH;
  const tctx = tmp.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(tctx);
  tctx.translate(outW/2, outH/2);
  tctx.rotate(rad);
  tctx.drawImage(drawingCanvas, 0, 0, w, h, -w/2, -h/2, w, h);

  drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  drawingCtx.drawImage(tmp, 0, 0);

  if (outW !== w || outH !== h) {
    drawareax = outW * z;
    drawareay = outH * z;
    const dpr = (window.devicePixelRatio || 1);
    drawstartx = Math.floor((canvas.width / dpr - drawareax) / 2);
    drawstarty = Math.floor((canvas.height / dpr - drawareay) / 2);
  }
  endAction();
}

// ======== TOOL SWITCH HOOKS ========
document.getElementById('lassoTool')?.addEventListener('click', ()=> switchTool('lasso'));
document.getElementById('rotateRightBtn')?.addEventListener('click', ()=> rotateSelection(90));
document.getElementById('rotateLeftBtn')?.addEventListener('click', ()=> rotateSelection(-90));
document.getElementById('flipHBtn')?.addEventListener('click', ()=> flipSelection('h'));
document.getElementById('flipVBtn')?.addEventListener('click', ()=> flipSelection('v'));
document.getElementById('rotateFreeBtn')?.addEventListener('click', ()=> rotateSelectionFree());
const _byId = (id) => document.getElementById(id);

const _copyEl  = _byId('copyBtn');
if (_copyEl) _copyEl.addEventListener('click', () => { copySelectionMobileFriendly(); });

const _pasteEl = _byId('pasteBtn');
if (_pasteEl) _pasteEl.addEventListener('click', () => { pasteFromClipboard(); });

// tangentbordsgenv√§gar: R=+90, Shift+R=-90, H=flipH, V=flipV, L=lasso, Ctrl+R=free
document.addEventListener('keydown', (e)=>{
   const mod = e.ctrlKey || e.metaKey;
   if (mod && e.key.toLowerCase() === 'c') { copySelection(); return; }  
   if (mod && e.key.toLowerCase() === 'v') {pasteFromClipboard();return;}
   if (e.ctrlKey && (e.key==='r' || e.key==='R')) { e.preventDefault(); rotateSelectionFree(); return; }
   if (e.key==='r' || e.key==='R') { e.preventDefault(); rotateSelection( e.shiftKey? -90 : +90 ); return; }
   if (e.key==='n' || e.key==='N') { e.preventDefault(); flipSelection('h'); return; }
   if (e.key==='v' || e.key==='V') { e.preventDefault(); flipSelection('v'); return; }
   if (e.key==='l' || e.key==='L') { e.preventDefault(); switchTool('lasso'); return; }
  
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape') {
    if (selSessionActive) {
      commitSelectionSession();  // skriver in urklippet och avslutar
    } else {
      // ingen session: st√§ng bara ev. lasso-skiss/markering
      isLassoActive = false;
      hasSelection = false;
      selectionBBox = null;
      selectionPathCanvas = null;
      selectionPathImg = null;
      selectionImageCanvas = null;
      selectionMaskCanvas = null;
    }
  }
});
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Delete') {

      // ingen session: st√§ng bara ev. lasso-skiss/markering
        selSessionActive   = false;
        selectionSrcCanvas = null;
        selectionHoleBBox  = null;
        selectionHoleCut   = false;
        clearSelection();
          hasSelection = false;
        selSessionActive = false;
        isDraggingSelection = false;
        isResizingSelection = false;
        isTransformingSelection = false;

        selectionImageCanvas = null;
        selectionSrcCanvas   = null;
        selectionPathImg     = null;
        selectionPathCanvas  = null;
        selectionMask        = null;
        selectionOrigBBox    = null;
        selectionHoleBBox    = null;
        selectionHoleCut     = false;

        selectionBBox = null;
        dragSelX = 0; dragSelY = 0;
        
  }
});

// G√∂r switchTool medveten om lasso/selection
const _origSwitchTool = switchTool;
switchTool = function(newTool){
  _origSwitchTool(newTool);
  if (newTool !== 'lasso') {
    isLassoActive = false;
  }
};

let isDraggingSelection = false;
let dragSelX = 0,  dragSelY  = 0;       // aktuell ‚Äúoverlay‚Äù-position i bildpixlar
let dragOffsetIX = 0, dragOffsetIY = 0; // pekarens offset i bbox

let selErasedOnce    = false;           // originalplatsen raderad (en g√•ng)



function startSelectionSession() {
    startdragstuffx=selectionStartX;
    startdragstuffy=selectionStartY;
  if (!selSessionActive) {
    if (typeof beginAction === 'function'){beginAction(); }// snapshot f√∂r undo
    selSessionActive = true;
    selErasedOnce = false;
    
  }
}

function commitSelectionSession(){
  if (!selSessionActive || !selectionBBox) return;
  
  
  // 1) Se till att bara originalh√•let finns (om s√•dant existerar)
  if (!selectionHoleCut && selectionHoleBBox){
    _eraseSelectionAt(selectionHoleBBox.x, selectionHoleBBox.y);
    selectionHoleCut = true;
  }
  // NEW: till√•t commit √§ven utan selectionSrcCanvas
  const src = selectionSrcCanvas || selectionImageCanvas;
  if (!src) return;
  // 2) Baka in slutl√§get
  drawingCtx.save();

  if (typeof disableSmoothing==='function') disableSmoothing(drawingCtx);
  drawingCtx.drawImage(
    src, 0,0, src.width, src.height,
    selectionBBox.x, selectionBBox.y, selectionBBox.w, selectionBBox.h
  );
  drawingCtx.restore();
  if(canvasw!==window.innerWidth||canvash!==window.innerHeight)cow=true;
  if(startdragstuffx!==selectionStartX||startdragstuffy!==selectionStartY){destroyAction();cow=false;}
  
      
  endAction(cow);

  
  // 3) St√§da
  selSessionActive   = false;
  selectionSrcCanvas = null;
  selectionHoleBBox  = null;
  selectionHoleCut   = false;
  clearSelection();
    hasSelection = false;
  selSessionActive = false;
  isDraggingSelection = false;
  isResizingSelection = false;
  isTransformingSelection = false;

  selectionImageCanvas = null;
  selectionSrcCanvas   = null;
  selectionPathImg     = null;
  selectionPathCanvas  = null;
  selectionMask        = null;
  selectionOrigBBox    = null;
  selectionHoleBBox    = null;
  selectionHoleCut     = false;

  selectionBBox = null;
  dragSelX = 0; dragSelY = 0;
  
  
}
function _clearSelectionState(reason = '') {
  hasSelection = false;
  selSessionActive = false;
  isDraggingSelection = false;
  isResizingSelection = false;
  isTransformingSelection = false;

  selectionImageCanvas = null;
  selectionSrcCanvas   = null;
  selectionPathImg     = null;
  selectionPathCanvas  = null;
  selectionMask        = null;
  selectionOrigBBox    = null;
  selectionHoleBBox    = null;
  selectionHoleCut     = false;

  selectionBBox = null;
  dragSelX = 0; dragSelY = 0;
}
function cancelSelectionSession() {
  if (!selSessionActive) return;
  // √Öterst√§ll canvas om vi raderat original
  if (selErasedOnce && typeof undo === 'function') undo();
  // √•terst√§ll UI-state till startl√§get
  selSessionActive = false;
  selErasedOnce = false;
  isDraggingSelection = false;
  // hoppa tillbaka markeringen till startpunkt
  if (selectionBBox) { selectionBBox.x = dragStartX; selectionBBox.y = dragStartY; }
}
// ======== POINTER-HANTERING F√ñR LASSO ========

let isdragdrag=false;

canvas.addEventListener('pointerdown', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault(); 
    isdragdrag=true;
    markDirty();
  if (currentTool !== 'lasso'||pointers.size === 2) return;
  if(tapedTwice)return;
  
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig markering ‚Üí starta/mata p√• en flytt-session
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {




    beginAction();


    startSelectionSession();

    // Radera originalomr√•det bara f√∂rsta g√•ngen
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);  // g√∂r h√•l en g√•ng
      selErasedOnce = true;
    }

    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }

if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }


  // Annars: b√∂rja NY lasso-kurva
  
  commitSelectionSession();  
    isLassoActive = true;
    hasSelection = false;
    selectionBBox = null;
    selectionPathCanvas = null;
    selectionPathImg = null;
    selectionImageCanvas = null;
    selectionMaskCanvas = null;

    lassoPoints = [];
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  
});

canvas.addEventListener('pointermove', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault(); 
  if (currentTool !== 'lasso'||pointers.size === 2) return;
  
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    let nx = pImg.x - dragOffsetIX;
    let ny = pImg.y - dragOffsetIY;
    //nx = Math.max(0, Math.min(nx, drawingCanvas.width  - selectionBBox.w));
   // ny = Math.max(0, Math.min(ny, drawingCanvas.height - selectionBBox.h));
    dragSelX = nx; dragSelY = ny;
    return;
  }

  if (!isLassoActive) return;
  const last = lassoPoints[lassoPoints.length-1];
  if (!last || last.ix !== pImg.x || last.iy !== pImg.y) {
    lassoPoints.push({ cx, cy, ix:pImg.x, iy:pImg.y });
  }
});
//NUWUWUWUWW
function _finalizeLasso() {
  if (lassoPoints.length < 3) { isLassoActive = false; return; }

  // 1) Overlay-path i sk√§rm-koordinater (f√∂r att rita ‚Äúmarching ants‚Äù)
  const pCanvas = new Path2D();
  pCanvas.moveTo(lassoPoints[0].cx, lassoPoints[0].cy);
  for (let i = 1; i < lassoPoints.length; i++) pCanvas.lineTo(lassoPoints[i].cx, lassoPoints[i].cy);
  pCanvas.closePath();
  selectionPathCanvas = pCanvas;

  // 2) Mask-path i bildens pixelkoordinater (detta anv√§nds n√§r vi extraherar pixlar)
  const pImg = new Path2D();
  pImg.moveTo(lassoPoints[0].ix, lassoPoints[0].iy);
  for (let i = 1; i < lassoPoints.length; i++) pImg.lineTo(lassoPoints[i].ix, lassoPoints[i].iy);
  pImg.closePath();
  selectionPathImg = pImg;

  // 3) BBox i bildens pixelkoordinater
  const ptsImg = lassoPoints.map(p => ({ x: p.ix, y: p.iy }));
  const bbox = _computeBBoxFromImagePts(ptsImg);
  selectionBBox = { x: bbox.x, y: bbox.y, w: bbox.w, h: bbox.h };
  selectionOrigBBox = { ...selectionBBox };
  _extractSelection();
  hasSelection = true;
  isLassoActive = false;
    selSessionActive   = true;
    selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
    selectionHoleBBox  = { ...selectionBBox };
        // NEW: sk√§r h√•let direkt s√• man ‚Äúser h√•let p√• en g√•ng‚Äù
    _eraseSelectionAt(selectionBBox.x, selectionBBox.y);
    selErasedOnce   = true;
    selectionHoleCut= true; // s√• commit inte f√∂rs√∂ker radera igen
}

canvas.addEventListener('pointerup', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault(); 
    isdragdrag=false;
    if(tapedTwice)return;
  if (currentTool !== 'lasso') return;
  
  
  if (typeof isResizingSelection !== 'undefined' && isResizingSelection) return;
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    // flytten ‚Äúg√§ller‚Äù visuellt: uppdatera bbox men skriv inte till canvas √§nnu
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }

  // f√§rdigritad lasso ‚Üí skapa markering + extrakt
  if (lassoPoints.length > 6) _finalizeLasso();
});

// H√∂gerklick = √•ngra drag (√•terst√§ll snapshot)
canvas.addEventListener('contextmenu', (e)=>{
  if (selSessionActive) {
    e.preventDefault();
    cancelSelectionSession();    // √•terst√§ll h√•let och positionen
  }
});

// √§ven dubbelklick ‚Üí st√§ng/avsluta
canvas.addEventListener('dblclick', (ev)=>{
  
  if (currentTool!=='lasso') return;
  commitSelectionSession();      
  clearSelection();
});

canvas.addEventListener("touchstart", tapHandler);

var tapedTwice = false;

function tapHandler(event) {
    if(!tapedTwice) {
        tapedTwice = true;
        setTimeout( function() { tapedTwice = false; }, 300 );
        return false;
    }
    event.preventDefault();
    if (selSessionActive) {
      commitSelectionSession();  // skriver in urklippet och avslutar
    } else {
      // ingen session: st√§ng bara ev. lasso-skiss/markering
      isLassoActive = false;
      hasSelection = false;
      selectionBBox = null;
      selectionPathCanvas = null;
      selectionPathImg = null;
      selectionImageCanvas = null;
      selectionMaskCanvas = null;
    }
 }



canvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  isLassoActive = false;
  if (isDraggingSelection) {
    // Avbryt flytt: bara l√§mna allt som innan drag-start
    isDraggingSelection = false;
    
    // (vi har inte skrivit till drawingCanvas under drag, s√• inget mer beh√∂vs)
  }
}); 
canvas.addEventListener('pointercancel', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault(); 
  if (currentTool !== 'lasso') return;
  // Avbryt drag, men rulla inte tillbaka (sessionen lever kvar)
  isDraggingSelection = false;
});
// Tr√∂ska bort halv-alfa ‚Üí 0/255
function _binarizeAlpha(canvas, threshold = 128) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const img = ctx.getImageData(0, 0, w, h);
  const data = img.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i+3] = (data[i+3] >= threshold ? 255 : 0);
  }
  ctx.putImageData(img, 0, 0);
}

// V√§x masken 1 px (mycket enkel 3√ó3-dilation p√• alfa)
// iterationer=1 r√§cker oftast; √∂ka om du fortfarande ser glipor.
function _dilateAlpha(canvas, iterations = 1) {
  const w = canvas.width, h = canvas.height;
  if (!w || !h || iterations <= 0) return;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });

  for (let it=0; it<iterations; it++) {
    const src = ctx.getImageData(0, 0, w, h);
    const s = src.data;
    const dst = ctx.createImageData(w, h);
    const d = dst.data;

    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        let on = 0;
        // 8-grannar
        for (let dy=-1; dy<=1; dy++) {
          const yy = y+dy; if (yy<0 || yy>=h) continue;
          for (let dx=-1; dx<=1; dx++) {
            const xx = x+dx; if (xx<0 || xx>=w) continue;
            const ai = ((yy*w + xx) << 2) + 3;
            if (s[ai] >= 128) { on = 1; break; }
          }
          if (on) break;
        }
        const i = ((y*w + x) << 2);
        d[i]   = s[i];
        d[i+1] = s[i+1];
        d[i+2] = s[i+2];
        d[i+3] = on ? 255 : 0; // bara alfa spelar roll f√∂r masken
      }
    }
    ctx.putImageData(dst, 0, 0);
  }
}

// Kombinerad
function _binarizeAndDilateMask(maskCanvas, dilatePx = 1) {
  _binarizeAlpha(maskCanvas, 128);
  if (dilatePx > 0) _dilateAlpha(maskCanvas, dilatePx);
}
let resizeOccurred = false;

// snapshot av dokumentytan (0..docW √ó 0..docH) ‚Äî inte hela drawingCanvas
function _snapshotDocArea(docW, docH){
  const c = document.createElement('canvas');
  c.width = docW; c.height = docH;
  const cctx = c.getContext('2d'); disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0,0, docW,docH, 0,0, docW,docH);
  return c;
}

// rita tillbaka utan f√∂rlust (oavsett riktning)
function blitNoLoss(tempCanvas, newW, newH, dx, dy, bgColor = 'transparent'){
  const oldW = tempCanvas.width, oldH = tempCanvas.height;

  const dstX = (dx>0 ? dx : 0) | 0;
  const dstY = (dy>0 ? dy : 0) | 0;
  const srcX = (dx<0 ? -dx : 0) | 0;
  const srcY = (dy<0 ? -dy : 0) | 0;

  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // 1) clearRect g√∂r ytan helt transparent
  drawingCtx.clearRect(0, 0, Math.max(oldW,newW), Math.max(oldH,newH));

  // 2) Fyll endast om du VILL ha en bakgrundsf√§rg
  if (bgColor && bgColor !== 'transparent') {
    drawingCtx.save();
    drawingCtx.fillStyle = bgColor; // t.ex. '#ffffff'
    drawingCtx.fillRect(0, 0, newW, newH);
    drawingCtx.restore();
  }

  // 3) Kopiera overlap (f√∂rlustfritt)
  if (copyW>0 && copyH>0){
    drawingCtx.drawImage(
      tempCanvas,
      srcX, srcY, copyW, copyH,
      dstX, dstY, copyW, copyH
    );
  }
}

// dx,dy beroende p√• vilket h√∂rn som dras ‚Äî bevara motsatt h√∂rn
function offsetForCorner(corner, oldW, oldH, newW, newH){
  switch((corner||'SE').toUpperCase()){
    case 'NW': return { dx: newW - oldW, dy: newH - oldH }; // botten-h√∂ger fast
    case 'NE': return { dx: 0,            dy: newH - oldH }; // botten-v√§nster fast
    case 'SW': return { dx: newW - oldW,  dy: 0            }; // toppen-h√∂ger fast
    case 'SE':
    default:   return { dx: 0,            dy: 0            }; // toppen-v√§nster fast
  }
}
// === NYTT: resize-session ===
// === state f√∂r resize ===
let rc_active = false;
let rc_corner = 'SE';
let rc_oldW = 0, rc_oldH = 0;     // dokumentm√•tt i bildpixlar
let rc_prevW = 0, rc_prevH = 0;   // preview-m√•tt i bildpixlar
let rc_baseStartX = 0, rc_baseStartY = 0; // drawstart vid start (sk√§rmpixlar)
let rc_snap = null;
let rc_anchorX=0, rc_anchorY=0, rc_anchorSet=false;
let rc_lastSW=0, rc_lastSH=0;

function sx2ix(sx){ const z=_effectiveZoom(); return Math.round((sx - rc_baseStartX) / z); }
function sy2iy(sy){ const z=_effectiveZoom(); return Math.round((sy - rc_baseStartY) / z); }

function _snapshotDocArea(w,h){
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const cctx = c.getContext('2d'); cctx.imageSmoothingEnabled = false;
  cctx.drawImage(drawingCanvas, 0,0, w,h, 0,0, w,h);
  return c;
}

function resizeStart(corner){
  if (rc_active) return;
  const z = _effectiveZoom();
  rc_corner = corner.toUpperCase();
  rc_oldW = Math.floor(drawareax / z);
  rc_oldH = Math.floor(drawareay / z);
  rc_prevW = rc_oldW;
  rc_prevH = rc_oldH;
  rc_baseStartX = Math.round(drawstartx+camera.x);   // <- BASEL√ÑGE
  rc_baseStartY = Math.round(drawstarty+camera.y);   // <- BASEL√ÑGE
  rc_snap = _snapshotDocArea(rc_oldW, rc_oldH);
  beginAction?.(); // ett undo-steg
  rc_active = true;
}

// Anropar du med canvas-sk√§rmkoordinater (dina x,y):
function resizePreviewFromCanvasXY(sx, sy){
  if (!rc_active) return;
  const W = rc_oldW, H = rc_oldH;
  const imgX = sx2ix(sx);
  const imgY = sy2iy(sy);

  switch(rc_corner){
    case 'SE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, imgY);     break;
    case 'NE': rc_prevW = Math.max(1, imgX);     rc_prevH = Math.max(1, H - imgY); break;
    case 'SW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, imgY);     break;
    case 'NW': rc_prevW = Math.max(1, W - imgX); rc_prevH = Math.max(1, H - imgY); break;
  }
}

function resizeCommit(){
  if (!rc_active) return;
  const newW = rc_prevW|0, newH = rc_prevH|0;
  const {dx,dy} = offsetForCorner(rc_corner, rc_oldW, rc_oldH, newW, newH);

  blitNoLoss(rc_snap, newW, newH, dx, dy, /* bgColor */ null);

  // uppdatera drawarea (sk√§rmpixlar)
  const z = _effectiveZoom();
  drawareax = newW * z;
  drawareay = newH * z;

  // H√•ll valfritt h√∂rn visuellt "fast" genom att flytta drawstart* (f√∂r NW/NE/SW)
  // SE: top-left fast ‚Üí inget att g√∂ra
  if (rc_corner === 'NW' || rc_corner === 'NE'){ drawstarty += (rc_oldH - newH) * z;}
  if (rc_corner === 'NW' || rc_corner === 'SW'){ drawstartx += (rc_oldW - newW) * z;}

  if (typeof endAction === 'function') endAction();
  rc_active = false; rc_snap = null;
}

function resizeCancel(){
  if (!rc_active) return;
  if (typeof undo === 'function') undo(); // backa snapshot-start
  rc_active = false; rc_snap = null;
}
function quantizeToZoomGrid(screenValue, z) {
  // Sn√§pper till n√§rmaste multipel av z (s√• 1 doc-pixel = exakt z sk√§rmpixlar)
  return Math.round(screenValue / z) * z;
}
//funkar lite
function drawResizeOverlay() {
  if (!rc_active) return;
  const z = _effectiveZoom();
  const oldW = rc_oldW, oldH = rc_oldH;
  const newW = rc_prevW|0, newH = rc_prevH|0;

  // ... (beh√•ll din offsetForCorner etc)

  const { dx, dy } = offsetForCorner(rc_corner, oldW, oldH, newW, newH);

  const dstX = (dx > 0 ? dx : 0) | 0;
  const dstY = (dy > 0 ? dy : 0) | 0;
  const srcX = (dx < 0 ? -dx : 0) | 0;
  const srcY = (dy < 0 ? -dy : 0) | 0;
  const copyW = Math.max(0, Math.min(oldW - srcX, newW - dstX)) | 0;
  const copyH = Math.max(0, Math.min(oldH - srcY, newH - dstY)) | 0;

  // F√∂rhandsvisningens topp-v√§nster i SK√ÑRMpixlar (h√•ll motsatt h√∂rn "fast")
  let previewTLx = drawstartx+camera.x + ((rc_corner==='NW' || rc_corner==='SW') ? (oldW - newW) * z : 0);
  let previewTLy = drawstarty+camera.y + ((rc_corner==='NW' || rc_corner==='NE') ? (oldH - newH) * z : 0);

  // === VIKTIGT: kvantisera sk√§rmpixlar till zoom-rutn√§tet ===
  previewTLx = quantizeToZoomGrid(previewTLx, z);
  previewTLy = quantizeToZoomGrid(previewTLy, z);

  // Sk√§rm-rektar (kvantisera √§ven storleken)
  const prevW = quantizeToZoomGrid(newW * z, z);
  const prevH = quantizeToZoomGrid(newH * z, z);

  const docX0 = drawstartx+camera.x,             docY0 = drawstarty+camera.y;
  const docX1 = docX0 + quantizeToZoomGrid(oldW * z, z);
  const docY1 = docY0 + quantizeToZoomGrid(oldH * z, z);

  const prevX0 = Math.floor(previewTLx), prevY0 = Math.floor(previewTLy);
  const prevX1 = prevX0 + prevW,         prevY1 = prevY0 + prevH;

  // Destinationspunkt f√∂r snapshot i SK√ÑRMpixlar ‚Üí kvantisera
  const dstXs = quantizeToZoomGrid(prevX0 + dstX * z, z);
  const dstYs = quantizeToZoomGrid(prevY0 + dstY * z, z);
  const drawW = quantizeToZoomGrid(copyW * z, z);
  const drawH = quantizeToZoomGrid(copyH * z, z);

  ctx.save();
  disableSmoothing(ctx);

  ctx.fillStyle = "rgba(32, 45, 21, 0.3)";
  if(copyW > 0 && copyH > 0){
      ctx.fillRect(prevX0, prevY0, prevW, prevH);
  }
  
  
  /*
  if (rc_snap && copyW > 0 && copyH > 0) {
      ctx.drawImage(
      rc_snap,
      srcX, srcY, copyW, copyH,        // K√ÑLLA: or√∂rd i doc-pixlar
      dstXs,dstYs, drawW, drawH // M√ÖL: kvantiserade sk√§rmpixlar
    );
  }*/

  // 3) Skugga UTANF√ñR nya ytan
  ctx.fillStyle = 'rgba(0,0,0,0.10)';
  ctx.fillRect(docX0, docY0, Math.max(0, prevX0 - docX0), docY1 - docY0);
  ctx.fillRect(Math.min(docX1, prevX1), docY0, Math.max(0, docX1 - prevX1), docY1 - docY0);
  ctx.fillRect(prevX0, docY0, Math.max(0, prevX1 - prevX0), Math.max(0, prevY0 - docY0));
  ctx.fillRect(prevX0, Math.min(docY1, prevY1), Math.max(0, prevX1 - prevX0), Math.max(0, docY1 - prevY1));

  // 4) Ram
  ctx.setLineDash([6,4]);
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.strokeRect(prevX0 + 0.5, prevY0 + 0.5, prevW, prevH);

  ctx.restore();
}
let isRectSelecting = false;

canvas.addEventListener('pointerdown', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault();
  if (currentTool !== 'select'||pointers.size === 2) return;
  
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  // Klick inne i befintlig rektangelmarkering ‚Üí b√∂rja flytta (som lasso)
  if (hasSelection && selectionBBox &&
      pImg.x >= selectionBBox.x && pImg.x < selectionBBox.x + selectionBBox.w &&
      pImg.y >= selectionBBox.y && pImg.y < selectionBBox.y + selectionBBox.h) {

    startSelectionSession();
    if (!selErasedOnce) {
      dragStartX = selectionBBox.x;
      dragStartY = selectionBBox.y;
      _eraseSelectionAt(dragStartX, dragStartY);
      selErasedOnce = true;
    }
    isDraggingSelection = true;
    dragSelX = selectionBBox.x;
    dragSelY = selectionBBox.y;
    dragOffsetIX = pImg.x - selectionBBox.x;
    dragOffsetIY = pImg.y - selectionBBox.y;
    return;
  }







if (selectionImageCanvas || selectionBBox){

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (corner) return;
  }






  // Ny rektangel
  commitSelectionSession();
  isRectSelecting = true;
  selectionStartX = selectionEndX = pImg.x;
  selectionStartY = selectionEndY = pImg.y;
  // nolla gamla
  hasSelection = false;
  selectionBBox = null;
  selectionPathCanvas = null;
  selectionPathImg = null;
  selectionImageCanvas = null;
  selectionMaskCanvas = null;
});

canvas.addEventListener('pointermove', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault();
  if (currentTool !== 'select'||pointers.size === 2) return;
  
  const rect = canvas.getBoundingClientRect();
  const cx = ev.clientX - rect.left;
  const cy = ev.clientY - rect.top;
  const pImg = _canvasXYtoImageXY(cx, cy);

  if (isDraggingSelection && selectionBBox) {
    dragSelX = pImg.x - dragOffsetIX;
    dragSelY = pImg.y - dragOffsetIY;
    return;
  }
  if (isRectSelecting) {
    selectionEndX = pImg.x;
    selectionEndY = pImg.y;
  }
});

function _finalizeRectSelection() {
  const x0 = Math.min(selectionStartX, selectionEndX);
  const y0 = Math.min(selectionStartY, selectionEndY);
  const w  = Math.max(0, Math.abs(selectionEndX - selectionStartX));
  const h  = Math.max(0, Math.abs(selectionEndY - selectionStartY));
  if (w <= 0 || h <= 0) return;

  // Canvas-path (sk√§rm) f√∂r ‚Äúmarching ants‚Äù
  const p0 = _imageXYtoCanvasXY(x0, y0);
  const z  = _effectiveZoom();
  const pCanvas = new Path2D();
  pCanvas.rect(p0.x, p0.y, w*z, h*z);
  selectionPathCanvas = pCanvas;

  // Mask-path i bildkoordinater
  const pImg = new Path2D();
  pImg.rect(x0, y0, w, h);
  selectionPathImg = pImg;

  selectionBBox = { x: x0, y: y0, w, h };
  _extractSelection(); // bygger selectionImageCanvas + mask fr√•n pathen
  hasSelection = true;
  selSessionActive   = true;
  selectionSrcCanvas = selectionImageCanvas;      // spara originalet som *inte* skrivs √∂ver
  selectionHoleBBox  = { ...selectionBBox };
  
  _eraseSelectionAt(selectionBBox.x, selectionBBox.y);
    selErasedOnce   = true;
    selectionHoleCut= true; 
  
}

canvas.addEventListener('pointerup', (ev)=>{
    if (ev.pointerType === 'touch') ev.preventDefault();
  if (currentTool !== 'select') return;
  
  if (isDraggingSelection && selectionImageCanvas && selectionBBox) {
    selectionBBox.x = dragSelX;
    selectionBBox.y = dragSelY;
    isDraggingSelection = false;
    return;
  }
  if (isRectSelecting) {
    isRectSelecting = false;
    _finalizeRectSelection();
  }
});

canvas.addEventListener('pointercancel', ()=>{ if (currentTool==='select') { isDraggingSelection=false; isRectSelecting=false; }});
async function copySelection() {
  // V√§lj k√§lla: aktiv selection ‚Üí annars hela dokumentytan
  let srcCanvas = null;

  if (hasSelection && selectionImageCanvas) {
    srcCanvas = selectionImageCanvas;
  } else {
    // Kopiera hela dokumentytan (origo-bilden, inte zoomad)
    const z = _effectiveZoom();
    const w = Math.floor(drawareax / z), h = Math.floor(drawareay / z);
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d'); disableSmoothing(tctx);
    tctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
    srcCanvas = tmp;
  }

  // F√∂rs√∂k Clipboard API (bild)
  try {
    const blob = await new Promise(res => srcCanvas.toBlob(res, 'image/png'));
    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
    console.log('Selection copied to clipboard (image/png).');
  } catch (err) {
    // Fallback: Base64-text
    try {
      await navigator.clipboard.writeText(srcCanvas.toDataURL('image/png'));
      alert('Kopierade som data-URL (fallback).');
    } catch (err2) {
      console.warn('Clipboard copy failed:', err2);
      alert('Kunde inte kopiera till urklipp i den h√§r webbl√§saren.');
    }
  }
}
function _drawSelectOverlay() {
  // Visa bara medan man drar en rektangel i select/copy-l√§ge
  if (!isSelecting || (currentTool !== 'select' && currentTool !== 'copy')) return;

  const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : zoom;

  const left   = drawstartx+camera.x + Math.min(selectionStartX, selectionEndX) * z;
  const top    = drawstarty+camera.y + Math.min(selectionStartY, selectionEndY) * z;
  const width  = Math.abs(selectionEndX - selectionStartX) * z;
  const height = Math.abs(selectionEndY - selectionStartY) * z;

  if (width <= 0 || height <= 0) return;

  ctx.save();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
  ctx.setLineDash([4, 3]);          // samma ‚Äúants‚Äù-stil som lasso
  ctx.strokeRect(left, top, width, height);
  ctx.restore();
}
// === Double-click f√∂r SELECT: f√§rdigst√§ll eller commit+clear ===
canvas.addEventListener('dblclick', (ev) => {
  if (currentTool !== 'select') return;
  ev.preventDefault();

  // 1) Om vi h√•ller p√• att rita rektangel ‚Üí f√§rdigst√§ll rutan
  if ((typeof isRectSelecting !== 'undefined' && isRectSelecting) ||
      (typeof isSelecting !== 'undefined' && isSelecting)) {
    if (typeof isRectSelecting !== 'undefined') isRectSelecting = false;
    if (typeof isSelecting !== 'undefined')     isSelecting = false;
    if (typeof _finalizeRectSelection === 'function') _finalizeRectSelection(); // skapar selectionPath/Mask/BBox
    return;
  }

  // 2) Om vi har en aktiv markering/drag-session ‚Üí commit & clear (samma som lasso)
  if ((typeof isDraggingSelection !== 'undefined' && isDraggingSelection) ||
      (typeof selSessionActive !== 'undefined' && selSessionActive) ||
      (typeof hasSelection !== 'undefined' && hasSelection)) {

    // Om vi draggar, baka in drag-positionen i BBox f√∂rst
    if (typeof isDraggingSelection !== 'undefined' && isDraggingSelection) {
      if (typeof selectionBBox !== 'undefined' && selectionBBox) {
        selectionBBox.x = dragSelX;
        selectionBBox.y = dragSelY;
      }
      isDraggingSelection = false;
    }

    if (typeof commitSelectionSession === 'function') commitSelectionSession(); // skriv tillbaka
    if (typeof clearSelection === 'function') clearSelection();                 // rensa ants/overlay
  }
});






async function pasteFromClipboard() {
  try {
    // 1) image/* direkt
    if (navigator.clipboard?.read) {
      try {
        const items = await navigator.clipboard.read();
        for (const item of items) {
          const t = item.types.find(x => x.startsWith('image/'));
          if (t) {
            const blob = await item.getType(t);
            const bmp  = await createImageBitmap(blob);
            _activatePastedBitmap(bmp);
            return;
          }
        }
        // 2) HTML -> <img> / og:image
        for (const item of items) {
          if (item.types.includes('text/html')) {
            const html = await (await item.getType('text/html')).text();
            const src = _parseImgSrcFromHTML(html);
            if (src && _looksLikeImageURL(src)) {
              const bmp = await _loadBitmapFromURL(src);
              _activatePastedBitmap(bmp);
              return;
            }
          }
        }
        // 3) URI-list / plain text
        for (const mime of ['text/uri-list','text/plain']) {
          const item = items.find(it => it.types.includes(mime));
          if (item) {
            const txt = (await (await item.getType(mime)).text()).trim();
            const norm = _normalizeImageURL(txt);
            if (norm && _looksLikeImageURL(norm)) {
              const bmp = norm.startsWith('data:image/')
                ? await _bitmapFromDataURL(norm)
                : await _loadBitmapFromURL(norm);
              _activatePastedBitmap(bmp);
              return;
            }
          }
        }
      } catch (e) {
        console.warn('clipboard.read failed', e);
      }
    }

    // 4) Fallback: readText
    if (navigator.clipboard?.readText) {
      const txt = (await navigator.clipboard.readText()).trim();
      const norm = _normalizeImageURL(txt);
      if (norm && _looksLikeImageURL(norm)) {
        const bmp = norm.startsWith('data:image/')
          ? await _bitmapFromDataURL(norm)
          : await _loadBitmapFromURL(norm);
        _activatePastedBitmap(bmp);
        return;
      }
    }

    
  } catch (err) {
    console.error(err);
    
  }
}

// Hj√§lpare: dataURL -> ImageBitmap
async function _bitmapFromDataURL(dataURL) {
  const res = await fetch(dataURL);
  const blob = await res.blob();
  return await createImageBitmap(blob);
}
let cow=false;
// Aktivera som flyttbar markering (ingen direkt m√•lning p√• ritytan)
function _activatePastedBitmap(imgBitmap,whole) {
  // 1) Bygg en canvas av den inklistrade bilden
  beginAction();
  const w = imgBitmap.width | 0, h = imgBitmap.height | 0;
  if (!w || !h) return;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);
  cctx.drawImage(imgBitmap, 0, 0);

    // 2) Placera i mitten av vyn (bildkoordinater)
    const z = (typeof _effectiveZoom === 'function') ? _effectiveZoom() : (window.zoom || 1);

    // R√§tt s√§tt: konvertera canvas-mitten ‚Üí bildkoordinater
    
    let centerImg;
    if (typeof _canvasXYtoImageXY === 'function') {
      centerImg = _canvasXYtoImageXY(drawareax/2, drawareay/2);
    } else {
      // Fallback om helper saknas: (canvasX - drawstart) / zoom
      centerImg = {
        x: ((drawareax/2) - drawstartx) / z,
        y: ((drawareay/2) - drawstarty) / z
      };
    }

    // Centera bilden kring vymitten
    const cx = Math.max(0, (centerImg.x - w/2) | 0);
    const cy = Math.max(0, (centerImg.y - h/2) | 0);

  // 3) Mata in i selection-systemet
  
  
  selectionImageCanvas = c;
    selectionBBox = { x: cx, y: cy, w, h };
    

    // NEW: make paste committable
  selectionSrcCanvas   = selectionImageCanvas;   // ‚Üê viktigt f√∂r commit
  selectionHoleBBox    = null;                   // ingen ‚Äúh√•l‚Äù-yta f√∂r paste
  selectionHoleCut     = true;                   // hoppa √∂ver h√•l-kapitel vid commit
  hasSelection         = true;
  isDraggingSelection  = false;
  selSessionActive     = true;                   // commit skriver in bilden
  selErasedOnce        = true;                   // s√• vi f√∂rs√∂ker inte radera n√•got
  if (typeof currentTool !== 'undefined') {switchTool('select');currentTool = 'select';  }

  // Bygg mask fr√•n bilden (anv√§nds av transform/erase)
  if (typeof _rebuildMaskFromImageCanvas === 'function') _rebuildMaskFromImageCanvas();

  // 4) Flagga markering + ‚Äúp√•g√•ende session‚Äù s√• commit ritar in bilden
  hasSelection = true;
  isDraggingSelection = false;
  selSessionActive = true;   // ‚Üê viktigt
  selErasedOnce    = true;   // ‚Üê g√∂r att commitSelectionSession() ritar in bilden

  // 5) Byt till select s√• anv√§ndaren kan dra direkt
  if (typeof currentTool !== 'undefined') {switchTool('select');currentTool = 'select';}

  // 6) Be om en redraw
 // if (typeof requestAnimationFrame === 'function') requestAnimationFrame(()=>{});
}
window.addEventListener('paste', async (e) => {
  // F√∂rs√∂k hitta bild
  const cd = e.clipboardData;
  if (!cd) return;
  // 1) Filer (png/jpg/webp) direkt
  if (cd.files && cd.files.length) {
    const file = Array.from(cd.files).find(f => f.type.startsWith('image/'));
    if (file) {
      e.preventDefault();
      const bmp = await createImageBitmap(file);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 2) Items (t.ex. fr√•n Photoshop etc.)
  if (cd.items && cd.items.length) {
    const it = Array.from(cd.items).find(i => i.type && i.type.startsWith('image/'));
    if (it) {
      e.preventDefault();
      const blob = it.getAsFile();
      const bmp = await createImageBitmap(blob);
      _activatePastedBitmap(bmp);
      return;
    }
  }
  // 3) Text-dataURL
  const txt = cd.getData('text/plain');
  if (txt && txt.startsWith('data:image/')) {
    e.preventDefault();
    const bmp = await _bitmapFromDataURL(txt);
    _activatePastedBitmap(bmp);
  }
});
// === COPY: skriv data-URL till urklipp via copy-event (funkar utan HTTPS) ===
function _buildCopyDataURL() {
  // 1) Direkt fr√•n en redan beskuren canvas
  if (hasSelection && selectionImageCanvas) {
    const c = selectionImageCanvas;
    if (!c || !c.width || !c.height) return ''; // undvik 'data:,'
    return c.toDataURL('image/png');
  }

  // 2) Fr√•n en markeringsruta p√• huvud-canvas
  if (hasSelection && selectionBBox) {
    const { x, y, w, h } = selectionBBox;

    // Klipp till giltigt omr√•de inom drawingCanvas
    const srcW = drawingCanvas.width  | 0;
    const srcH = drawingCanvas.height | 0;
    let sx = Math.max(0, Math.round(x));
    let sy = Math.max(0, Math.round(y));
    let sw = Math.max(0, Math.round(w));
    let sh = Math.max(0, Math.round(h));
    if (sx + sw > srcW) sw = Math.max(0, srcW - sx);
    if (sy + sh > srcH) sh = Math.max(0, srcH - sy);
    // Se till att m√•let inte blir 0√ó0
    const outW = Math.max(1, sw);
    const outH = Math.max(1, sh);

    const c = document.createElement('canvas');
    c.width = outW; c.height = outH;
    const cctx = c.getContext('2d');
    if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

    if (sw > 0 && sh > 0) {
      cctx.drawImage(drawingCanvas, sx, sy, sw, sh, 0, 0, outW, outH);
    } // annars l√§mna transparent

    // OBS: om canvas √§r tainted kan iOS returnera 'data:,'
    return c.toDataURL('image/png');
  }

  // 3) Hela ritytan (justerat f√∂r din zoommodell)
  const z = (!Number.isFinite(zoom) || zoom <= 0)
    ? 1
    : (zoom > 10 ? zoom / 100 : zoom);

  // Anv√§nd round + min 1
  const outW = Math.max(1, Math.round((drawareax || drawingCanvas.width)  / z));
  const outH = Math.max(1, Math.round((drawareay || drawingCanvas.height) / z));

  // Klipp k√§llrektangel inom drawingCanvas
  const srcW = Math.min(outW, drawingCanvas.width);
  const srcH = Math.min(outH, drawingCanvas.height);

  const c = document.createElement('canvas');
  c.width = outW; c.height = outH;
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(cctx);

  cctx.drawImage(drawingCanvas, 0, 0, srcW, srcH, 0, 0, outW, outH);
  return c.toDataURL('image/png');
}

async function _dataURLToBlob(dataURL) {
  const res = await fetch(dataURL);
  return await res.blob();
}

function _fallbackTextareaCopy(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.setAttribute('readonly', '');
  ta.style.position = 'fixed';
  ta.style.top = '0';
  ta.style.left = '0';
  ta.style.opacity = '0';
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  ta.setSelectionRange(0, ta.value.length);
  let ok = false;
  try { ok = document.execCommand('copy'); } catch (_) {}
  document.body.removeChild(ta);
  return ok;
}

function _toast(msg) {
  let box = document.getElementById('toast-box');
  if (!box) {
    box = document.createElement('div');
    box.id = 'toast-box';
    box.style.cssText = `
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      background:#111; color:#fff; padding:8px 12px; border-radius:10px;
      font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      box-shadow:0 6px 24px rgba(0,0,0,.25); z-index:999999; opacity:0; transition:opacity .2s;
      pointer-events:none;
    `;
    document.body.appendChild(box);
  }
  box.textContent = msg;
  requestAnimationFrame(() => {
    box.style.opacity = '1';
    clearTimeout(box._t);
    box._t = setTimeout(() => { box.style.opacity = '0'; }, 1400);
  });
}

// Huvudfunktionen du anropar fr√•n knappen (m√•ste k√∂ras i user gesture)
function _buildCopyCanvas() {
  // 1) If a floating selection image exists, use that
  if (window.hasSelection && window.selectionImageCanvas) {
    return window.selectionImageCanvas;
  }
  // 2) If we only have a selection bbox, extract that region
  if (window.hasSelection && window.selectionBBox) {
    const { x, y, w, h } = window.selectionBBox;
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
    cctx.drawImage(drawingCanvas, x, y, w, h, 0, 0, w, h);
    return c;
  }
  // 3) Fallback: copy the whole visible document area
  const z = (window.zoom > 10 ? window.zoom/100 : window.zoom || 1);
  const w = Math.floor(window.drawareax / z);
  const h = Math.floor(window.drawareay / z);
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const cctx = c.getContext('2d'); if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(drawingCanvas, 0, 0, w, h, 0, 0, w, h);
  return c;
}

// Replace this function with the version below
function _isCanvasTainted(c) {
  try {
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.getImageData(0, 0, 1, 1); // kastar SecurityError vid taint
    return false;
  } catch (e) {
    return true;
  }
}



// iOS-fallback: kopiera genom att v√§lja ett IMG i en contenteditable
function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.position = 'fixed';
  host.style.left = '-99999px';
  host.style.top = '0';
  host.style.opacity = '0';
  // Viktigt: IMG som faktiskt renderas
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const img = host.firstChild;
  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(img);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch(_) {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

function _copyViaEditableIMG(dataURL) {
  const host = document.createElement('div');
  host.contentEditable = 'true';
  host.style.cssText = 'position:fixed;left:-99999px;top:0;opacity:0;';
  host.innerHTML = `<img src="${dataURL}" alt="copy">`;
  document.body.appendChild(host);

  const sel = window.getSelection();
  const range = document.createRange();
  range.selectNode(host.firstChild);
  sel.removeAllRanges();
  sel.addRange(range);

  let ok = false;
  try { ok = document.execCommand('copy'); } catch {}
  sel.removeAllRanges();
  document.body.removeChild(host);
  return ok;
}

async function copySelectionMobileFriendly() {
  const url = _buildCopyDataURL();
  if (!url || url === 'data:,') { _toast('Inget att kopiera.'); return; }

  // 1) Riktig bild till urklipp ‚Äî iOS/Safari vill ha PROMISE direkt i ClipboardItem
  try {
    if (navigator.clipboard && window.ClipboardItem) {
      const blobPromise = (async () => (await fetch(url)).blob())(); // <- Promise, inte f√§rdig blob
      const item = new ClipboardItem({ 'image/png': blobPromise });
      await navigator.clipboard.write([item]);
      _toast('Kopierat (bild).');
      return;
    }
  } catch (e) {
    console.warn('clipboard.write image failed:', e);
  }

  // 2) iOS-fallback: contenteditable + IMG + execCommand('copy')
  try {
    if (_copyViaEditableIMG(url)) {
      _toast('Kopierat (iOS-fallback).');
      return;
    }
  } catch (e2) {
    console.warn('editable IMG copy failed:', e2);
  }

  // 3) writeText(dataURL)
  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(url);
      _toast('Kopierat (text-dataURL).');
      return;
    }
  } catch {}

  // 4) execCommand (textarea)
  if (_fallbackTextareaCopy(url)) { _toast('Kopierat.'); return; }

  // 5) prompt (sista utv√§gen)
  try { window.prompt('Tryck Kopiera:', url); } catch {}
}
//-----NYTT
// ===== BEGIN PATCH: resize-corners state =====
let isResizingSelection = false;
let activeResizeCorner = null;   // 'tl','tr','bl','br'
let resizeAnchorImg = null;      // {x,y} i bild-koordinater (motsatt h√∂rn)
let resizeStartBBox = null;      // snapshot av bbox vid pointerdown
let HANDLE_SIZE_SCR = 12;      // storlek p√• h√∂rn-handtag i sk√§rm-px


// Tr√§ffa h√∂rn i SK√ÑRM-koordinater (mx,my i canvas.getBoundingClientRect()-space)
function _hitTestResizeHandleScreen(mx, my, bbox){
  if (!bbox) return null;
  const tl = _imageXYtoCanvasXY(bbox.x,             bbox.y);
  const tr = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y);
  const bl = _imageXYtoCanvasXY(bbox.x,             bbox.y + bbox.h);
  const br = _imageXYtoCanvasXY(bbox.x + bbox.w,    bbox.y + bbox.h);
  const S  = HANDLE_SIZE_SCR;

  const hits = (p) => (mx >= p.x - S && mx <= p.x + S && my >= p.y - S && my <= p.y + S);
  if (hits(tl)) return 'tl';
  if (hits(tr)) return 'tr';
  if (hits(bl)) return 'bl';
  if (hits(br)) return 'br';
  return null;
}

// Ber√§kna ny bbox fr√•n muspunkt (bild-koordinater) + l√•st ankare
function _bboxFromDragAnchor(currImg, anchorImg){
  const x = Math.min(currImg.x, anchorImg.x);
  const y = Math.min(currImg.y, anchorImg.y);
  const w = Math.max(1, Math.abs(currImg.x - anchorImg.x));
  const h = Math.max(1, Math.abs(currImg.y - anchorImg.y));
  return { x, y, w, h };
}

// Hj√§lp: h√•l i gamla omr√•det och inritning av skalad bild i nya
function _commitSelectionResize(oldBBox, newBBox){
  if (!selSessionActive || !selectionSrcCanvas || !newBBox) return;

  // 1) Uppdatera aktuell bbox
  selectionBBox = { ...newBBox };

  // 2) (valfritt) Bygg om en f√∂rhandsbuffer fr√•n *originalk√§llan*, inte fr√•n basen
  const c = document.createElement('canvas');
  c.width  = Math.max(1, Math.round(newBBox.w));
  c.height = Math.max(1, Math.round(newBBox.h));
  const cctx = c.getContext('2d');
  if (typeof disableSmoothing==='function') disableSmoothing(cctx);
  cctx.drawImage(
    selectionSrcCanvas,
    0,0, selectionSrcCanvas.width, selectionSrcCanvas.height,
    0,0, c.width, c.height
  );
  selectionImageCanvas = c; // f√∂rhandsvisning / overlay
}
// ===== END PATCH: resize-corners state =====
// ===== BEGIN PATCH: pointer listeners for corner resize =====
canvas.addEventListener('pointerdown', (ev) => {
  if (ev.pointerType === 'touch') ev.preventDefault();  
  if (!selectionImageCanvas || !selectionBBox) return;

  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;

  // √Ñr vi p√• ett h√∂rn?
  const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
  if (!corner) return;

  ev.preventDefault();
  ev.stopPropagation();

  // Om du har drag-l√§ge f√∂r selection, st√§ng av s√• de inte krockar:
  if (typeof isDraggingSelection !== 'undefined') isDraggingSelection = false;

  activeResizeCorner = corner;
  isResizingSelection = true;
  resizeStartBBox = { ...selectionBBox };

  // Motsatt h√∂rn = ankare (i bild-koordinater)
  let ax, ay;
  if (corner === 'tl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'tr') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y + resizeStartBBox.h; }
  if (corner === 'bl') { ax = resizeStartBBox.x + resizeStartBBox.w; ay = resizeStartBBox.y;                       }
  if (corner === 'br') { ax = resizeStartBBox.x;                       ay = resizeStartBBox.y;                       }
  resizeAnchorImg = { x: ax, y: ay };
});

canvas.addEventListener('pointermove', (ev) => {
    if (ev.pointerType === 'touch') ev.preventDefault();
  // Hover-cursor n√§r inte resizing
  if (!isResizingSelection) {
    if (selectionBBox) {
      const rect = canvas.getBoundingClientRect();
      const mx = ev.clientX - rect.left;
      const my = ev.clientY - rect.top;
      const corner = _hitTestResizeHandleScreen(mx, my, selectionBBox);
      let cur = 'default';
      if (corner === 'tl' || corner === 'br') cur = 'nwse-resize';
      if (corner === 'tr' || corner === 'bl') cur = 'nesw-resize';
      canvas.style.cursor = cur;
    }
    return;
  }

  // N√§r resizing: uppdatera selectionBBox live (preview)
  if (!resizeAnchorImg) return;
  const rect = canvas.getBoundingClientRect();
  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const mImg = _canvasXYtoImageXY(mx, my); // mus i bild-koordinater

  // (valfritt) beh√•ll aspektf√∂rh√•llande om Shift h√•lls:
  // if (ev.shiftKey) { ...justera mImg.x/mImg.y f√∂r ratio... }

  let newBBox = _bboxFromDragAnchor(mImg, resizeAnchorImg);

  // Kl√§m inom canvas-gr√§nser
  newBBox.x = Math.max(0, Math.min(newBBox.x, drawingCanvas.width  - 1));
  newBBox.y = Math.max(0, Math.min(newBBox.y, drawingCanvas.height - 1));
  newBBox.w = Math.max(1, Math.min(newBBox.w, drawingCanvas.width  - newBBox.x));
  newBBox.h = Math.max(1, Math.min(newBBox.h, drawingCanvas.height - newBBox.y));

  selectionBBox = newBBox; // detta r√§cker f√∂r live-preview eftersom din overlay ritar selectionImageCanvas skalad
  ev.preventDefault();
});

function _endResizeCommit(){
  if (!isResizingSelection) return;
  _commitSelectionResize(resizeStartBBox, selectionBBox);

  isResizingSelection = false;
  activeResizeCorner = null;
  resizeAnchorImg = null;
  resizeStartBBox = null;
}

canvas.addEventListener('pointerup',    _endResizeCommit);
canvas.addEventListener('pointercancel',_endResizeCommit);
canvas.addEventListener('pointerleave', () => {
  // valfritt: commit √§ven n√§r man drar utanf√∂r canvas
  if (isResizingSelection) _endResizeCommit();
});
// ===== END PATCH: pointer listeners for corner resize =====
function _parseImgSrcFromHTML(html) {
  try {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    if (!doc) return '';

    // 1) Vanlig <img>
    let img = doc.querySelector('img[src], img[data-src], img[data-original], img[data-iurl]');
    if (img) {
      let src = img.getAttribute('src') ||
                img.getAttribute('data-src') ||
                img.getAttribute('data-original') ||
                img.getAttribute('data-iurl') || '';
      if ((!src || src === '#') && img.getAttribute('srcset')) {
        src = _pickLargestFromSrcset(img.getAttribute('srcset'));
      }
      return _normalizeImageURL(src);
    }

    // 2) OG/Twitter fallback
    const og = doc.querySelector('meta[property="og:image"][content],meta[name="twitter:image"][content]');
    if (og) return _normalizeImageURL(og.getAttribute('content'));

    // 3) √Ñldre fallback
    const linkImg = doc.querySelector('link[rel="image_src"][href]');
    if (linkImg) return _normalizeImageURL(linkImg.getAttribute('href'));

    return '';
  } catch { return ''; }
}

function _pickLargestFromSrcset(srcset) {
  // V√§lj kandidaten med h√∂gst "w" (eller sista om bara "x"-descriptor)
  try {
    const parts = srcset.split(',').map(s => s.trim()).filter(Boolean).map(s => {
      const [u, d = ''] = s.split(/\s+/);
      const w = d.endsWith('w') ? parseInt(d) : (d.endsWith('x') ? parseFloat(d) * 1000 : 0);
      return { u, w: isFinite(w) ? w : 0 };
    });
    parts.sort((a,b) => b.w - a.w);
    return parts.length ? parts[0].u : '';
  } catch { return ''; }
}

// -------------- Normalisera bilder fr√•n s√∂kmotorer ------
function _normalizeImageURL(u) {
  try {
    const url = new URL(u, location.href);

    // Google Image redirect: https://www.google.xx/imgres?imgurl=...
    if (/\.google\./i.test(url.hostname) && /\/imgres/i.test(url.pathname)) {
      const real = url.searchParams.get('imgurl') || url.searchParams.get('imgrefurl');
      if (real) return real;
    }

    // Google "url" wrapper: https://www.google.xx/url?q=...
    if (/\.google\./i.test(url.hostname) && /\/url/i.test(url.pathname)) {
      const q = url.searchParams.get('q');
      if (q) return q;
    }

    // Bing Images: mediaurl=
    if (/\.bing\./i.test(url.hostname)) {
      const m = url.searchParams.get('mediaurl');
      if (m) return m;
    }

    // DuckDuckGo: u=
    if (/duckduckgo\.com/i.test(url.hostname)) {
      const m = url.searchParams.get('u');
      if (m) return m;
    }

    return url.href;
  } catch {
    return u;
  }
}

// -------------- URL heuristik: acceptera mer -------------
function _looksLikeImageURL(s) {
  // Var inte f√∂r strikt ‚Äì prova att ladda allt http(s) och data:image
  if (!s) return false;
  if (/^data:image\//i.test(s)) return true;
  if (/^blob:/i.test(s)) return true;                 // kan funka om samma origin
  if (/^https?:/i.test(s)) return true;               // l√•t loader avg√∂ra
  return false;
}
async function _loadBitmapFromURL(src) {
  // f√∂rs√∂k anonymt f√∂rst (om CORS finns blir canvas *inte* tainted)
  const img = new Image();
  img.crossOrigin = 'anonymous';
  const done = new Promise((res, rej) => {
    img.onload = () => res(img);
    img.onerror = () => rej(new Error('Image load failed: ' + src));
  });
  img.src = src;
  const el = await done;
  try {
    return await createImageBitmap(el);
  } catch {
    // sista utv√§g: rita till mellan-canvas (kan tainta)
    const c = document.createElement('canvas');
    c.width = el.naturalWidth || el.width;
    c.height = el.naturalHeight || el.height;
    const cctx = c.getContext('2d');
    if (typeof disableSmoothing === 'function') disableSmoothing(cctx);
    cctx.drawImage(el, 0, 0);
    return await createImageBitmap(c);
  }
}
//NYTT
function _fitViewportToImage(newW, newH) {
  // Beh√•ll beteendet: auto-fit till ~80% av f√∂nstret, men lyft upp till ~50% om det blir f√∂r sm√•tt
  
 
  let newZoom = zoom;
  const availW = window.innerWidth;
  const availH = window.innerHeight - 100; // din toppbar-marginal

  if (newW * newZoom > availW * 0.8 || newH * newZoom > availH * 0.8) {
    const zx = Math.round(((availW * 0.8) / newW) * 10) / 10;
    const zy = Math.round(((availH * 0.8) / newH) * 10) / 10;
    newZoom = Math.min(zx, zy);
  } else if (newW * newZoom < availW * 0.5 || newH * newZoom < availH * 0.5) {
    const zx = Math.round(((availW * 0.5) / newW) * 10) / 10;
    const zy = Math.round(((availH * 0.5) / newH) * 10) / 10;
    newZoom = Math.min(zx, zy);
  }

  // Skriv tillbaka zoom + UI
  zoom = newZoom;
  zoomvalue = Math.round(newZoom * 100);
  const zSlider = document.getElementById("zoomSlider");
  const zLabel  = document.getElementById("zoomLabel");
  if (zSlider) zSlider.value = zoomvalue;
  if (zLabel)  zLabel.innerText = "Zoom: " + zoomvalue + "%";

  // Uppdatera drawarea och centrera
  drawareax = newW * zoom;
  drawareay = newH * zoom;
  const dpr = window.devicePixelRatio || 1;
  drawstartx = (canvas.width / dpr - drawareax) / 2;
  drawstarty = (canvas.height / dpr - drawareay) / 2;
  

  
  
}
async function _activateLoadedBitmap(imgBitmap) {
  if (!imgBitmap || !imgBitmap.width || !imgBitmap.height) return;
  beginAction();
  ensureCanvasSize(imgBitmap.width, imgBitmap.height); // beh√•ll din s√§kerhetsmarginal
  _fitViewportToImage(imgBitmap.width, imgBitmap.height);
  _activatePastedBitmap(imgBitmap,true);                     // in i nya selectTool-fl√∂det
  if (typeof currentTool !== 'undefined') { switchTool('select'); currentTool = 'select'; }
}
//NYTT
window.addEventListener('load', ()=>{
  const startTool = (window.currentTool || 'pen'); // du har default 'pen' redan
  if (window.__setSidebarActive) window.__setSidebarActive(startTool); // direkt uppdatering
  window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool: startTool } })); // f√∂r alla andra lyssnare
});

// Originalknappar
  const inputOpen   = document.getElementById('directFileInput');
  const lblOpen     = document.querySelector('label[for="directFileInput"]');
  const btnSave     = document.getElementById('saveImageBtn');
  const btnResize   = document.getElementById('ResizeBtn');
  const btnGrid     = document.getElementById('gridBtn');
  const btnP1       = document.getElementById('project1Btn');
  const btnP2       = document.getElementById('project2Btn');
  const btnP3       = document.getElementById('project3Btn');

  // D√∂lj original (vi proxy-klickar dem)
  if (lblOpen)   lblOpen.style.display = 'none';
  if (btnSave)   btnSave.style.display = 'none';
  if (btnResize) btnResize.style.display = 'none';
  if (btnGrid)   btnGrid.style.display = 'none';
  if (btnP1) btnP1.style.display = 'none';
  if (btnP2) btnP2.style.display = 'none';
  if (btnP3) btnP3.style.display = 'none';

  // Top-meny element
  const hamburgerBtn = document.getElementById('hamburgerBtn');
  const mainMenu     = document.getElementById('mainMenu');
  const projectsBtn  = document.getElementById('projectsBtn');
  const projectsDrop = document.getElementById('projectsDrop');
  const backdrop     = document.getElementById('menuBackdrop');

  // Hj√§lpare
  function closeAll(){
    mainMenu.classList.remove('open');
    projectsDrop.classList.remove('open');
    hamburgerBtn.setAttribute('aria-expanded','false');
    projectsBtn.setAttribute('aria-expanded','false');
    backdrop.classList.remove('show');
  }

  function toggle(el, btn){
    const willOpen = !el.classList.contains('open');
    closeAll();
    if (willOpen){
      el.classList.add('open');
      btn.setAttribute('aria-expanded','true');
      // CSS sk√∂ter position (left:0; top:‚Ä¶)
      backdrop.classList.add('show');
    }
  }

  // √ñppna/st√§ng via knappar
  hamburgerBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(mainMenu, hamburgerBtn); });
  projectsBtn ?.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(projectsDrop, projectsBtn); });

  // F√•nga interaktioner INUTI menyerna s√• de inte bubbler upp till backdrop
  [hamburgerBtn, projectsBtn, mainMenu, projectsDrop].forEach(el=>{
    el?.addEventListener('pointerdown', e=> e.stopPropagation());
    el?.addEventListener('touchstart',  e=> e.stopPropagation(), {passive:true});
    el?.addEventListener('mousedown',   e=> e.stopPropagation());
  });

  // Klick/touch utanf√∂r -> st√§ng (fungerar p√• iOS)
  function closeOnOutside(){ closeAll(); }
  backdrop.addEventListener('pointerdown', closeOnOutside);
  backdrop.addEventListener('mousedown',   closeOnOutside);
  backdrop.addEventListener('touchstart',  closeOnOutside, {passive:true});

  // Som extra s√§kerhet ‚Äì ESC st√§nger
  window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeAll(); });

  // Proxy-actions
  document.getElementById('mnuOpen') ?.addEventListener('click', ()=>{ closeAll(); inputOpen?.click(); });
  document.getElementById('mnuSave') ?.addEventListener('click', ()=>{ closeAll(); btnSave?.click(); });
  document.getElementById('mnuResize')?.addEventListener('click', ()=>{ closeAll(); btnResize?.click(); });
  document.getElementById('mnuGrid')  ?.addEventListener('click', ()=>{ closeAll(); btnGrid?.click(); });

  document.getElementById('mnuProj1')?.addEventListener('click', ()=>{ closeAll(); btnP1?.click(); });
  document.getElementById('mnuProj2')?.addEventListener('click', ()=>{ closeAll(); btnP2?.click(); });
  document.getElementById('mnuProj3')?.addEventListener('click', ()=>{ closeAll(); btnP3?.click(); });




// H√§mta originalknapparna
  const flipHBtn      = document.getElementById('flipHBtn');
  const flipVBtn      = document.getElementById('flipVBtn');
  const rotateRightBtn= document.getElementById('rotateRightBtn');
  const rotateLeftBtn = document.getElementById('rotateLeftBtn');
  const rotateFreeBtn = document.getElementById('rotateFreeBtn');

  // G√∂m dem om de syns i UI (valfritt)
  [flipHBtn, flipVBtn, rotateRightBtn, rotateLeftBtn, rotateFreeBtn]
    .forEach(b=>{ if(b) b.style.display='none'; });

  // V√•r launcher och meny
  const trBtn  = document.getElementById('transformBtn');
  const trMenu = document.getElementById('transformMenu');

  function closeTransform(){
    trMenu.classList.remove('open');
    backdrop?.classList.remove('show');
  }
  function toggleTransform(){
    const willOpen = !trMenu.classList.contains('open');
    // st√§ng andra menyer om du anv√§nder closeAll()
    if (typeof closeAll === 'function') closeAll();
    if (willOpen){
      trMenu.classList.add('open');
      backdrop?.classList.add('show');
    }else{
      closeTransform();
    }
  }

  // √ñppna/st√§ng
  trBtn?.addEventListener('click', (e)=>{ e.stopPropagation(); toggleTransform(); });

  // Stoppa bubblering inuti menyn s√• backdrop inte st√§nger direkt
  [trBtn, trMenu].forEach(el=>{
    el?.addEventListener('pointerdown', e=> e.stopPropagation());
    el?.addEventListener('touchstart',  e=> e.stopPropagation(), {passive:true});
    el?.addEventListener('mousedown',   e=> e.stopPropagation());
  });

  // Backdrop ‚Üí st√§ng
  const closeOnOutside2 = ()=> closeTransform();
  backdrop?.addEventListener('pointerdown', closeOnOutside2);
  backdrop?.addEventListener('mousedown',   closeOnOutside2);
  backdrop?.addEventListener('touchstart',  closeOnOutside2, {passive:true});

function proxy(btn){
    // s√§krare proxy: trigga b√•de pointerup/click-v√§gen
    if (!btn) { console.warn('Missing target button for proxy'); return; }
    // en del iOS-webkit-versioner missar .click() direkt efter close ‚Üí k√∂r i microtask
    Promise.resolve().then(()=> btn.click());
  }

  document.getElementById('trFlipH')  ?.addEventListener('click', ()=>{ closeTransform(); proxy(flipHBtn); });
  document.getElementById('trFlipV')  ?.addEventListener('click', ()=>{ closeTransform(); proxy(flipVBtn); });
  document.getElementById('trRotR')   ?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateRightBtn); });
  document.getElementById('trRotL')   ?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateLeftBtn); });
  document.getElementById('trRotFree')?.addEventListener('click', ()=>{ closeTransform(); proxy(rotateFreeBtn); });

  const copyBtn = document.getElementById('copyBtn');
  const pasteBtn = document.getElementById('pasteBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');

  function proxyClick(target){
    if (!target) return;
    Promise.resolve().then(()=> target.click());
  }

  document.getElementById('barCopy') ?.addEventListener('click', ()=> proxyClick(copyBtn));
  document.getElementById('barPaste')?.addEventListener('click', ()=> proxyClick(pasteBtn));
  document.getElementById('barUndo') ?.addEventListener('click', ()=> proxyClick(undoBtn));
  document.getElementById('barRedo') ?.addEventListener('click', ()=> proxyClick(redoBtn));


const btnProjects = document.getElementById('projectsBtn');
  const item1 = document.getElementById('mnuProj1');
  const item2 = document.getElementById('mnuProj2');
  const item3 = document.getElementById('mnuProj3');

  const projItems = { 1:item1, 2:item2, 3:item3 };

  const origP1 = document.getElementById('project1Btn');
  const origP2 = document.getElementById('project2Btn');
  const origP3 = document.getElementById('project3Btn');

  // 1) S√§kerst√§ll att knappen har en separat label-span
  function ensureLabelSpan(){
    if (!btnProjects) return null;
    let label = document.getElementById('projectsLabel');
    if (!label){
      // Plocka nuvarande text (utan pilen) och bygg om knappen
      const raw = (btnProjects.textContent || '').replace('‚ñæ','').trim();
      const txt = raw || 'Canvas 1';
      btnProjects.innerHTML = `<span id="projectsLabel">${txt}</span> ‚ñæ`;
      label = document.getElementById('projectsLabel');
    }
    return label;
  }
  const labelSpan = ensureLabelSpan();

  // 2) S√§tt aktiv canvas (uppdatera knapp + highlight)
  function setActiveProject(n){
    if (labelSpan) labelSpan.textContent = `Canvas ${n}`;
    Object.values(projItems).forEach(el => el?.classList.remove('active'));
    projItems[n]?.classList.add('active');
  }

  // 3) Initiera fr√•n knappens befintliga text (t.ex. "Canvas 1 ‚ñæ")
  function initialIndex(){
    const base = (labelSpan?.textContent || btnProjects?.textContent || '').replace('‚ñæ','').trim();
    const m = base.match(/(\d+)/);
    return m ? parseInt(m[1],10) : 1;
  }
  setActiveProject(initialIndex());

  // 4) Koppla klick i dropdownen ‚Üí proxya originalknappar + uppdatera label/highlight
  item1?.addEventListener('click', ()=>{ origP1?.click(); setActiveProject(1); });
  item2?.addEventListener('click', ()=>{ origP2?.click(); setActiveProject(2); });
  item3?.addEventListener('click', ()=>{ origP3?.click(); setActiveProject(3); });

  // 5) Om du byter canvas p√• annat s√§tt (t.ex. programatiskt),
  //    lyssna √§ven p√• originalknapparna:
  origP1?.addEventListener('click', ()=> setActiveProject(1));
  origP2?.addEventListener('click', ()=> setActiveProject(2));
  origP3?.addEventListener('click', ()=> setActiveProject(3));
let zomzomzom=1;

function hitCornerPrecise(x, y, { radius = 28, safeInner = 14 } = {}) {
  // Alla koordinater i CSS-px (clientX/clientY)
  const left   = drawstartx;
  const top    = drawstarty;
  const right  = left + drawareax;
  const bottom = top  + drawareay;

  const inside = (x >= left && x <= right && y >= top && y <= bottom);
  const corners = [
    { id: 1, x: left,  y: top    }, // TL
    { id: 2, x: right, y: top    }, // TR
    { id: 3, x: left,  y: bottom }, // BL
    { id: 4, x: right, y: bottom }  // BR
  ];

  // 1) Om man startar INNE i dokumentet: prioritera ritning,
  //    utom om man tr√§ffar en pytteliten kvadrat precis i h√∂rnet.
  if (inside) {
    for (const c of corners) {
      const dx = Math.abs(x - c.x);
      const dy = Math.abs(y - c.y);
      const d2 = dx*dx + dy*dy;
      if (dx <= safeInner && dy <= safeInner && d2 <= radius*radius) {
        return c.id; // till√•t resize om man VERKLIGEN siktat p√• h√∂rnet
      }
    }
    return 0; // rita
  }

  // 2) Startade man UTANF√ñR dokumentet: till√•t h√∂rntr√§ff om n√§ra nog (cirkul√§rt)
  let best = 0, bestD2 = Infinity, r2 = radius * radius;
  for (const c of corners) {
    const dx = x - c.x, dy = y - c.y;
    const d2 = dx*dx + dy*dy;
    if (d2 <= r2 && d2 < bestD2) { bestD2 = d2; best = c.id; }
  }
  return best; // 0 = ingen h√∂rna, annars 1..4
}
let isPinching = false;
let preStrokeBmp = null;        // temp-canvas innan stroke (ej history)
let pinchLastDist = 0;

// anropa innan en stroke b√∂rjar
function _capturePreStroke() {
  // skapar en liten snapshot av renderade bilden (inte hela 10000x10000 om du har visningsyta separat)
  preStrokeBmp = document.createElement('canvas');
  preStrokeBmp.width  = drawingCanvas.width;
  preStrokeBmp.height = drawingCanvas.height;
  preStrokeBmp.getContext('2d').drawImage(drawingCanvas, 0, 0);
}

// anropa om en stroke avbryts (t.ex. pinch startar)
function _revertToPreStroke() {
  if (!preStrokeBmp) return;
  const g = drawingCanvas.getContext('2d');
  g.setTransform(1,0,0,1,0,0);
  g.clearRect(0,0,drawingCanvas.width,drawingCanvas.height);
  g.drawImage(preStrokeBmp, 0, 0);
  preStrokeBmp = null;
}
function recalcCanvasSize() {
  const dpr = window.devicePixelRatio || 1;
  const w = Math.round(window.innerWidth);
  const h = Math.round(window.innerHeight);
  if (canvas.width !== w*dpr || canvas.height !== h*dpr) {
    canvas.width  = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
  }
}
document.getElementById('mnuNew').addEventListener('click', ()=>{
  if (confirm("Start a new drawing? Unsaved work will be lost.")) {
    location.reload(); // enklaste variant A
  }
});







const pointers = new Map();           // pointerId -> { clientX, clientY, offsetX, offsetY }
let touchTimer = null;
let lastPinchDistance = 0;            // 0 = ingen pinch-baslinje satt √§nnu
let startxxx=0;
let startyyy=0;
let delatare=false;

function twoPointers() {
  const it = pointers.values();
  const p0 = it.next().value;
  const p1 = it.next().value;
  return [p0, p1];
}

canvas.addEventListener('pointerdown', (ev) => {
  if (ev.pointerType === 'touch') ev.preventDefault();
  canvas.setPointerCapture(ev.pointerId);

  pointers.set(ev.pointerId, {
    clientX: ev.clientX, clientY: ev.clientY,
    offsetX: ev.offsetX, offsetY: ev.offsetY
  });

  // === 2 fingrar -> initiera pinch (ers√§tter ev.touches.length === 2)
  if (pointers.size === 2) {
      clearSelection();
    clearTimeout(touchTimer);
    if (delatare === true) { delatare = false;isDrawing = false;destroyAction();_revertToPreStroke(); }

    const [p0, p1] = twoPointers();
    const dx = p0.clientX - p1.clientX;
    const dy = p0.clientY - p1.clientY;
    startxxx=(p0.clientX);
    startyyy=(p0.clientY);
    lastPinchDistance = Math.hypot(dx, dy);
    return; // l√§mna ‚Äì vi √§r i pinch-l√§ge
  }

  // === 1 finger -> din timer (ers√§tter ev.touches.length === 1)
  if (pointers.size === 1) {
    touchTimer = setTimeout(() => { delatare = false; }, 40);
  }

  // --- Resten av din singel-finger nedtryckningslogik ---
  if (ev.target === canvas && pointers.size === 1) {
    const rect = canvas.getBoundingClientRect();
    x = ev.clientX - rect.left-camera.x;
    y = ev.clientY - rect.top-camera.y;

    // movecorners
    if(tapedTwice&&ev.pointerType === 'touch'||ev.pointerType !== 'touch'){
        
        if (x >= drawstartx-30 && x < drawstartx && y >= drawstarty-30 && y < drawstarty+10) { movecorners = true; resizeStart('NW'); return; }
        if (x >= drawstartx+drawareax-10 && x < drawstartx+drawareax+30 && y >= drawstarty-30 && y < drawstarty+10) { movecorners = true; resizeStart('NE'); return; }
        if (x >= drawstartx-30 && x < drawstartx && y >= drawstarty+drawareay && y < drawstarty-10+drawareay+30) { movecorners = true; resizeStart('SW'); return; }
        if (x >= drawstartx+drawareax-10 && x < drawstartx+drawareax+30 && y >= drawstarty+drawareay-10 && y < drawstarty+drawareay+30) { movecorners = true; resizeStart('SE'); return; }
    }

    // Tools
    if (x >= drawstartx && x < drawstartx + drawareax && y >= drawstarty && y < drawstarty + drawareay) {
      const canvasX = Math.floor((x - drawstartx) / zoom);
      const canvasY = Math.floor((y - drawstarty) / zoom);
      if (currentTool === 'eyedropper') {
        updateEyedropperBuffer();
        const data = eyedropperCtx.getImageData(canvasX, canvasY, 1, 1).data;
        const hexColor = `#${data[0].toString(16).padStart(2,'0')}${data[1].toString(16).padStart(2,'0')}${data[2].toString(16).padStart(2,'0')}`;
        document.querySelector('.color-swatch.active').dataset.color = hexColor;document.querySelector('.color-swatch.active').style.background = hexColor; isTransparentBrush = false; switchTool('pen'); return;
      } else if (currentTool === 'fill') {
        beginAction(); floodFill(x, y); endAction();
      } else if (currentTool === 'select') {
        isSelecting = true; //selectionStartX = canvasX; selectionStartY = canvasY; selectionEndX = canvasX; selectionEndY = canvasY;
      } else if (currentTool === 'text') {
        const text = prompt("Enter your text:"); if (text) { beginAction(); drawText(x, y, text); endAction(); }
      } else if (currentTool === 'pen') {
        beginAction(); _capturePreStroke();delatare=true;isDrawing = true; lastX = 0; lastY = 0; drawPixel(x, y);
      }
    }
  }
}, { passive: false });

canvas.addEventListener('pointermove', (ev) => {
  if (ev.pointerType === 'touch') ev.preventDefault();
  if (!pointers.has(ev.pointerId)) return;

  // uppdatera den aktiva pointerns pos
  const p = pointers.get(ev.pointerId);
  p.clientX = ev.clientX; p.clientY = ev.clientY;
  p.offsetX = ev.offsetX; p.offsetY = ev.offsetY;
  pointers.set(ev.pointerId, p);

  // dragga h√∂rn
  if (movecorners) {
      clearSelection();
    const rect = canvas.getBoundingClientRect();
    const xNow = ev.clientX - rect.left;
    const yNow = ev.clientY - rect.top;
    resizePreviewFromCanvasXY(xNow, yNow);
  }
  
  
  // === 2-finger pinch (ers√§tter e.touches vid move)
  if (pointers.size === 2 ) {
      clearSelection();
    const [p0, p1] = twoPointers();
    const dx = p0.clientX - p1.clientX;
    const dy = p0.clientY - p1.clientY;
    const newDistance = Math.hypot(dx, dy);
    const delta = newDistance - lastPinchDistance;


  
    if(Math.abs(delta)>=10){

        let newzoom = zoom;  // beh√•ller din befintliga formel
        if (Math.abs(delta) > 10) {
          newzoom *= (delta > 0) ? 1.05 : 0.95;
          newzoom = Math.max(0.10, Math.min(newzoom, 50));
          zoomvalue = Math.round(newzoom * 100);
          document.getElementById("zoomSlider").value = String(zoomvalue);
          document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";
          lastPinchDistance = newDistance;
        }
    }
    else{
        
        if(startxxx===0){startxxx=(p0.clientX);startyyy=(p0.clientY);}
        
        const cx = ((p0.clientX)-startxxx );
        const cy = ((p0.clientY)-startyyy );
        
  
        
        // Vi vill INTE skriva till drawstartx/y h√§r ‚Üí anv√§nd skuggoffset och skuggzoom
        camera.x +=cx;
        camera.y +=cy;
        startxxx=(p0.clientX);
        startyyy=(p0.clientY); 
    }
    return; // n√§r tv√• fingrar ‚Äì rita inte
  }

  // === 1 finger: rita
  if (ev.target === canvas && pointers.size === 1) {
    const rect = canvas.getBoundingClientRect();
    x = ev.clientX - rect.left-camera.x;
    y = ev.clientY - rect.top-camera.y;


    if (isDrawing && currentTool === 'pen' ) {
      drawPixel(x, y);
    }
  }
}, { passive: false });

function endPointer(ev) {
  if (ev.pointerType === 'touch') ev.preventDefault();
  pointers.delete(ev.pointerId);
  try { canvas.releasePointerCapture(ev.pointerId); } catch(_) {}

  if (pointers.size < 2) {
    // nollst√§ll pinch-baslinjen n√§r vi inte l√§ngre har tv√• fingrar
    lastPinchDistance = 0;
  }

  if (movecorners) {clearSelection(); resizeCommit(); movecorners = false; }


  if (isDrawing === true) endAction();
  isDrawing = false;
  lastX = 0; lastY = 0;
  isSelecting = false;

  if (pointers.size === 0 && touchTimer) {
    clearTimeout(touchTimer);
    touchTimer = null;
  }
  
 
  
  
}
canvas.addEventListener('pointerup', endPointer, { passive: false });
canvas.addEventListener('pointercancel', endPointer, { passive: false });

const HIST_MAX = 50;
let savelabel,savew,savebmp,saveh,savedrawareax,savedrawareay,savedrawstartx,savedrawstarty,savezoom,canvash,ox,oy;
let canvasw=null;
let startansasa=true;
function pruneStack(stack){
  if (!stack) return;
  while (stack.length > HIST_MAX) {
      
      
      
    stack.shift(); // kasta √§ldsta; l√•t GC ta canvasen
  }
}
function ensureStacks(pid){
  if (!undoMap.has(pid)) undoMap.set(pid, []);
  if (!redoMap.has(pid)) redoMap.set(pid, []);
  return { undo: undoMap.get(pid), redo: redoMap.get(pid) };
}
function captureRegionSnapshot() {
  // Snapshot av aktuella bildm√•tt (w,h) ‚Äì inte hela backing-canvas
  const z = _effectiveZoom();
  const imgW = Math.max(1, Math.floor(drawareax / z)) | 0;
  const imgH = Math.max(1, Math.floor(drawareay / z)) | 0;

  const snap = document.createElement('canvas');
  snap.width = imgW; snap.height = imgH;
  const sctx = snap.getContext('2d');
  if (typeof disableSmoothing === 'function') disableSmoothing(sctx);
  // kopiera exakt bildytan 0..imgW/0..imgH
  sctx.drawImage(drawingCanvas, 0, 0, imgW, imgH, 0, 0, imgW, imgH);

  return { snap, imgW, imgH };
}
let actionOpen = true;
function beginAction(label = ''){
  const { snap, imgW, imgH } = captureRegionSnapshot();
  

      if(canvasw===0||startansasa){
          
        startansasa=false;
        savelabel=label;
        savebmp=snap;
        savew=imgW;
        saveh=imgH;
        savedrawareax=drawareax;
        savedrawareay=drawareay;
        savedrawstartx=drawstartx;
        savedrawstarty=drawstarty;
        savezoom=zoom;
        canvasw=window.innerWidth;
        canvash=window.innerHeight;
        
      }
}
function destroyAction(){
    
    savelabel=null;
    savebmp=null;
    savew=0;
    saveh=0;
    savedrawareax=0;
    savedrawareay=0;
    savedrawstartx=0;
    savedrawstarty=0;
    savezoom=0;
    canvasw=0;
    canvash=0;
}
function endAction(cowcow){
  if (typeof markDirty === 'function'){
      if(savebmp===null){return;}
      
      
      if(cowcow){  
        const prevVW = Math.max(1, canvasw || window.innerWidth);
        const prevVH = Math.max(1, canvash || window.innerHeight);
        const curVW  = Math.max(1, window.innerWidth);
        const curVH  = Math.max(1, window.innerHeight);

        // Effektiv zoom f√∂r posten
        const z = savezoom;

        // Bildens storlek (hela backing-bilden, ex 10000√ó10000)
        const imgW = drawingCanvas.width;
        const imgH = drawingCanvas.height;

        // 1) Ber√§kna bild-centrum i BILD-px fr√•n sparat ‚Äúoriginal‚Äù-l√§ge (ox/oy) + GAMLA viewporten
        const cxImg = (-savedrawstartx + prevVW/2) / z;
        const cyImg = (-savedrawstarty + prevVH/2) / z;

        // 2) Ny drawstart s√• samma bild-centrum hamnar mitt i den NYA viewporten
        let sx = Math.round(curVW/2 - z * cxImg);
        let sy = Math.round(curVH/2 - z * cyImg);

        // 3) Clamp:a mot nya till√•tna spann i SK√ÑRM-px
        const imgWscreen = imgW * z;
        const imgHscreen = imgH * z;
        const minX = curVW - imgWscreen; // ‚â§ 0
        const minY = curVH - imgHscreen; // ‚â§ 0
        savedrawstartx = sx;
        savedrawstarty = sy;
        canvasw = curVW;
        canvash = curVH;
        
      } 
      
      
      
      undoMap.get(currentproject)?.push({
        savelabel,
        bmp: savebmp,         // snapshot canvas av bildytan
        w: savew, h: saveh,  // "logiska" bildm√•tt i px (utan zoom)
        drawareax:savedrawareax, drawareay:savedrawareay, drawstartx:savedrawstartx, drawstarty:savedrawstarty, zoom:savezoom,canvasw:canvasw,canvash:canvash,ox:savedrawstartx,oy:savedrawstarty
      });
      ko(undoMap.get(currentproject));
      
      pruneStack(undoMap.get(currentproject));
      while (redoMap.get(currentproject)?.length) redoMap.get(currentproject)?.pop();
      canvasw=0;
      markDirty();

  }
}


function restoreState(state){
  if (!state || !state.bmp) return;
  drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
  if (typeof disableSmoothing === 'function') disableSmoothing(drawingCtx);
  drawingCtx.drawImage(state.bmp, 0, 0);

  zoom = state.zoom;
  drawareax = state.w * zoom;
  drawareay = state.h * zoom;
  // Lita p√• att drawstartx/y redan √§r r√§tt preppade (via ko())
  drawstartx = state.drawstartx;
  drawstarty = state.drawstarty;

  if (typeof markDirty === 'function') markDirty();
}
function ko(stack){
  if (!stack || !stack.length) return;
  
  
  for(let s of stack){
  
 

  // Gamla viewporten (som sparades i posten) och nya viewporten (aktuella f√∂nstret)
  const prevVW = Math.max(1, s.canvasw || window.innerWidth);
  const prevVH = Math.max(1, s.canvash || window.innerHeight);
  const curVW  = Math.max(1, window.innerWidth);
  const curVH  = Math.max(1, window.innerHeight);

  // Effektiv zoom f√∂r posten
  const z = s.zoom;

  // Bildens storlek (hela backing-bilden, ex 10000√ó10000)
  const imgW = drawingCanvas.width;
  const imgH = drawingCanvas.height;

  // 1) Ber√§kna bild-centrum i BILD-px fr√•n sparat ‚Äúoriginal‚Äù-l√§ge (ox/oy) + GAMLA viewporten
  const cxImg = (-s.ox+(s.ox-s.drawstartx) + prevVW/2) / z;
  const cyImg = (-s.oy+(s.oy-s.drawstarty) + prevVH/2) / z;

  // 2) Ny drawstart s√• samma bild-centrum hamnar mitt i den NYA viewporten
  let sx = Math.round(curVW/2 - z * cxImg);
  let sy = Math.round(curVH/2 - z * cyImg);

  // 3) Clamp:a mot nya till√•tna spann i SK√ÑRM-px
  const imgWscreen = imgW * z;
  const imgHscreen = imgH * z;
  const minX = curVW - imgWscreen; // ‚â§ 0
  const minY = curVH - imgHscreen; // ‚â§ 0
  //sx = clamp(sx, minX, 0);
  //sy = clamp(sy, minY, 0);

  // 4) Skriv tillbaka i posten + uppdatera dess sparade viewport
  s.drawstartx = sx;
  s.drawstarty = sy;
  s.canvasw = curVW;
  s.canvash = curVH;
  }
}
function undo(){
  if (!undoMap.get(currentproject)?.length) return;

  const cur = captureRegionSnapshot();


  // flytta current ‚Üí redo
  redoMap.get(currentproject)?.push({
    bmp: cur.snap, w: cur.imgW, h: cur.imgH,
    drawareax, drawareay, drawstartx, drawstarty,
    zoom, canvasw:window.innerWidth, canvash:window.innerHeight,
    ox: undoMap.get(currentproject)?.at(-1)?.ox,
    oy: undoMap.get(currentproject)?.at(-1)?.oy
  });
  pruneStack(redoMap.get(currentproject));
  
  // Om viewport √§ndrats relativt posten vi ska visa -> centrera den posten med ko()
  const willShow = undoMap.get(currentproject)?.at(-1) ?? null;
  if (willShow && (window.innerWidth !== willShow.canvasw || window.innerHeight !== willShow.canvash)) {
    ko(undoMap.get(currentproject)); // justera sista posten i undoStack
  }


  restoreState(willShow);
  undoMap.get(currentproject)?.pop();

}

function redo(){
  if (!redoMap.get(currentproject)?.length) return;

  const cur = captureRegionSnapshot();


  // flytta current ‚Üí undo
  undoMap.get(currentproject)?.push({
    bmp: cur.snap, w: cur.imgW, h: cur.imgH,
    drawareax, drawareay, drawstartx, drawstarty,
    zoom, canvasw:window.innerWidth, canvash:window.innerHeight,
    ox: redoMap.get(currentproject)?.at(-1)?.ox,
    oy: redoMap.get(currentproject)?.at(-1)?.oy // <-- fix: inte .ox
  });
  pruneStack(undoMap.get(currentproject));
  const willShow = redoMap.get(currentproject)?.at(-1) ?? null;
  if (willShow && (window.innerWidth !== willShow.canvasw || window.innerHeight !== willShow.canvash)) {
    ko(redoMap.get(currentproject)); // justera sista posten i redoStack
  }
  

  restoreState(willShow);
  redoMap.get(currentproject)?.pop();
}

const gridBtn = document.getElementById('gridBtn');
function updateGridButton() {
    if (!gridBtn) return;
    gridBtn.style.backgroundColor = showGrid ? '#d4ffd4' : '#f1f1f1';
    gridBtn.style.borderColor = showGrid ? '#4CAF50' : '#ccc';
}

gridBtn.addEventListener('click', () => { showGrid = !showGrid; updateGridButton(); });
document.getElementById('undoBtn').addEventListener('click', undo);
document.getElementById('redoBtn').addEventListener('click', redo);
window.addEventListener('keydown', function(e) {
  const z = e.key.toLowerCase() === 'z';
  const y = e.key.toLowerCase() === 'y';
  const mod = e.ctrlKey || e.metaKey;
  if (mod && z && !e.shiftKey) { e.preventDefault(); undo(); }
  else if (mod && (y || (z && e.shiftKey))) { e.preventDefault(); redo(); }
  if (e.key.toLowerCase() === 'g') { showGrid = !showGrid; updateGridButton(); }
});
updateGridButton();


let pcanvasw=0;
let pcanvash=0;
let kn√§ppt=false;

let keyState = {up: false,down: false,left: false,right: false,h: false,plus:false,minus:false};         
document.addEventListener("keydown", function(e) {
    try{if(audio.paused&&gameState!=='game_over'){ audio.play();}}catch(error){};
    if (e.key === "w") keyState.up = true;
    if (e.key === "a") keyState.left = true;
    if (e.key === "s") keyState.down = true;
    if (e.key === "d") keyState.right = true;
    if (e.key === "h") keyState.h = true;
    if (e.key === "+") keyState.plus = true;
    if (e.key === "-") keyState.minus = true;
});

document.addEventListener("keyup", function(e) {
    if (e.key === "w") keyState.up = false;
    if (e.key === "a") keyState.left = false;
    if (e.key === "s") keyState.down = false;
    if (e.key === "d") keyState.right = false;
    if (e.key === "h") keyState.h = false;
    if (e.key === "+") keyState.plus = false;
    if (e.key === "-") keyState.minus = false;
});
let firstbloodx=null;
let firstbloody=null;

document.getElementById('mnuCameraCenter')  ?.addEventListener('click', ()=>{ closeAll(); cameraHome(); });
function cameraHome(){keyState.h=true;}

function setZoomAroundScreenCenter(newZoom,oldZoom){
  const sx = window.innerWidth  / 2;
  const sy = window.innerHeight / 2;
  setZoomAroundScreenPoint(newZoom, sx, sy, "shiftDrawstart",oldZoom);
}




// mode: "shiftDrawstart" (default), "shiftCamera", eller "snapDrawstartInt"
function setZoomAroundScreenPoint(newZoom, sx, sy, mode = "shiftDrawstart",oldZoom){
  const z0  = _effectiveZoom() ;                     // gamla zoomen (samma som i render)
  const ox0 = drawstartx + camera.x;                // kombinerad offset f√∂re zoom
  const oy0 = drawstarty + camera.y;

  // Bildpunkten som ligger under pivoten (sx,sy)
  const ix = (sx - ox0) / z0;
  const iy = (sy - oy0) / z0;

  // Uppdatera zoom + h√§rled drawarea fr√•n bildm√•tt (blanda inte in gamla drawarea)


  // √ñnskad kombinerad offset efter zoom s√• att samma bildpunkt stannar under (sx,sy)
  const ox1 = sx - ix * newZoom;
  const oy1 = sy - iy * newZoom;

  // === V√§lj hur du vill f√∂rdela ox1/oy1 p√• drawstart vs camera ===
  if (mode === "shiftDrawstart"){
    // 1) L√§gg hela deltat p√• drawstart, l√§mna camera of√∂r√§ndrad

    
    
    drawstartx += (ox1 - ox0);
    drawstarty += (oy1 - oy0);
    
    
  } else if (mode === "shiftCamera"){
    // 2) L√•t drawstart vara, l√§gg deltat p√• camera
    camera.x   += (ox1 - ox0);
    camera.y   += (oy1 - oy0);
    
    
    
  } else if (mode === "snapDrawstartInt"){
    // 3) ‚ÄúPixel-snap‚Äù: l√§gg kombinerad offset p√• drawstart (heltal), resten i camera
    const nx = Math.round(ox1), ny = Math.round(oy1);
    const rx = ox1 - nx,        ry = oy1 - ny;
    camera.x += rx;
    camera.y += ry;
    drawstartx = nx;
    drawstarty = ny;
  }


}
let hcounter=2;
            //check---------------------------------------------------------------------------------------
            var check = function() {
                
                
                if(keyState.up)camera.y-=6;
                if(keyState.down)camera.y+=6;
                if(keyState.left)camera.x-=6;
                if(keyState.right)camera.x+=6;
                if(keyState.h){drawstartx = firstbloodx;drawstarty = firstbloody;camera.x=0;camera.y=0;if(hcounter==0){hcounter=3;keyState.h=false;}hcounter--;zoomvalue=100;document.getElementById("zoomSlider").value = String(zoomvalue);document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";}
                if(keyState.plus){newzoom = Math.max(0.10, Math.min(zoom*1.01, 50));zoomvalue = Math.ceil(newzoom * 100);document.getElementById("zoomSlider").value = String(zoomvalue);document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";}
                if(keyState.minus){newzoom = Math.max(0.10, Math.min(zoom*0.99, 50));zoomvalue = Math.floor(newzoom * 100);document.getElementById("zoomSlider").value = String(zoomvalue);document.getElementById("zoomLabel").innerText = "Zoom: " + zoomvalue + "%";}
                
                
            const active = document.querySelector('.color-swatch.active');
                if (active && active.dataset.color !== brushColor) {
                   brushColor=active.dataset.color;
                 
                }
                
                zomzomzom=1;
                if(mobileAndTabletCheck()){
                    zomzomzom=0.3;
                }
                
                // Update canvas size
                if (pcanvasw !== window.innerWidth||pcanvash !== window.innerHeight) {
                    pcanvasw=window.innerWidth;
                    pcanvash=window.innerHeight;
                    resizeCanvas();

                }
                if((document.body.clientWidth > 100 && startan == false))zoom=zoom/zomzomzom;
                
                kn√§ppt=true;
            //    zoom=zoom/zomzomzom;
                    if(tvaaaa===true){tvaaaa=false;zoomvalue=100;}
                    else if(treeee===true){treeee=false;zoomvalue=100;}
                  
                    const oldZoom = zoom;
                    const newZoom = zoomvalue / 100;
                    setZoomAroundScreenCenter(zoomvalue / 100,zoom);
                    zoom = newZoom;
                    drawareax = drawareax / oldZoom * newZoom;
                    drawareay = drawareay / oldZoom * newZoom;
                    
                    
                
                // --- R√§kna om start s√• att samma bildpunkt ligger kvar i mitten
                
                //drawstartx = (screenCenterX - imgCenterX * newZoom);
                //drawstarty = (screenCenterY - imgCenterY * newZoom);
               // zoom=zoom*zomzomzom;
                kn√§ppt=false;
                if((document.body.clientWidth > 100 && startan == false)) {
                    startan = true;  
                    drawstartx = (canvas.width/devicePixelRatio)/2 - drawareax/2;
                    drawstarty = (canvas.height/devicePixelRatio)/2 - drawareay/2;
                    prevDrawAreaX = drawareax;
                    prevDrawAreaY = drawareay;
                    prevDrawStartX = drawstartx;
                    prevDrawStartY = drawstarty;
                    projectdrawareax = [drawareax, drawareax, drawareax];
                    projectdrawareay = [drawareay, drawareay, drawareay];
                    projectdrawstartx = [drawstartx, drawstartx, drawstartx];
                    projectdrawstarty = [drawstarty, drawstarty, drawstarty];
                     
                    
                    
                    projectzoom = [zoom, zoom, zoom];
                    if(mobileAndTabletCheck())HANDLE_SIZE_SCR = 24;
                   
                    resizeCanvas();
                    
                    undoMap.set(0,[]);
                    undoMap.set(1,[]);
                    undoMap.set(2,[]);
                    
                    redoMap.set(0,[]);
                    redoMap.set(1,[]);
                    redoMap.set(2,[]);
                    
                }
                
      
                    if(firstbloodx===null){
        
        firstbloodx=drawstartx;
        firstbloody=drawstarty;
    }
   
                
                // Store the old dimensions before any changes
                const oldDrawStartX = drawstartx;
                const oldDrawStartY = drawstarty;
                const oldDrawAreaX = drawareax;
                const oldDrawAreaY = drawareay;
                
                
                

                
                // Draw the document background
                ctx.fillStyle = "#4D4D4D";
                ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
                
 

                const checkerPattern = (function createCheckerPattern() {
                const patternCanvas = document.createElement('canvas');
                const size = 16; // Small pattern size (8px per square)
                patternCanvas.width = size;
                patternCanvas.height = size;
                const patternCtx = patternCanvas.getContext('2d');

                // Create the pattern
                patternCtx.fillStyle = "white";
                patternCtx.fillRect(0, 0, size, size);
                patternCtx.fillStyle = "#cccccc";
                patternCtx.fillRect(0, 0, size/2, size/2);
                patternCtx.fillRect(size/2, size/2, size/2, size/2);

                return patternCanvas;
            })();
                const pattern = ctx.createPattern(checkerPattern, 'repeat');
                ctx.fillStyle = pattern;
                // Use integer coordinates and add 1px buffer to prevent edge artifacts
                const patternX = Math.floor(drawstartx+1+camera.x);
                const patternY = Math.floor(drawstarty+1+camera.y);
                const patternWidth = (Math.ceil(drawareax + (drawstartx+camera.x - patternX)) - 3);
                const patternHeight = (Math.ceil(drawareay + (drawstarty+camera.y - patternY)) - 3);
                ctx.fillRect(patternX, patternY, patternWidth, patternHeight);


                
                // Calculate how much of the drawing area to display
                //const displayWidth = Math.ceil(drawareax / zoom) + EDGE_BUFFER;
              //  const displayHeight = Math.ceil(drawareay / zoom) + EDGE_BUFFER;

  
                // Draw the content from the drawing canvas to the visible canvas
           
                
                    ctx.save(); // Save the current state
                    ctx.translate(drawstartx+camera.x, drawstarty+camera.y); // Move to the top-left corner
                    const z = _effectiveZoom(); // Apply zoom scaling
                    ctx.scale(z, z);
                    const displayWidth  = ensureIntDimension(drawareax / z);
                    const displayHeight = ensureIntDimension(drawareay / z);
                    ctx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0,0,displayWidth, displayHeight);
                    ctx.restore();
            
            
            if (showGrid) {
                    ctx.save();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';

                    for (let gx = 0; gx <= displayWidth; gx++) {
                        const xPix = drawstartx+camera.x-0.5 + gx * zoom;
                        ctx.beginPath();
                        ctx.moveTo(xPix + 0.5, drawstarty+camera.y-0.5);
                        ctx.lineTo(xPix + 0.5, drawstarty+camera.y-0.5 + displayHeight * zoom);
                        ctx.stroke();
                    }

                    for (let gy = 0; gy <= displayHeight; gy++) {
                        const yPix = drawstarty+camera.y-0.5 + gy * zoom;
                        ctx.beginPath();
                        ctx.moveTo(drawstartx+camera.x-0.5, yPix + 0.5);
                        ctx.lineTo(drawstartx+camera.x-0.5 + displayWidth * zoom, yPix + 0.5);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
                
                if(!movecorners){
                    ctx.fillStyle = "black";
                    ctx.fillRect(drawstartx+camera.x-20, drawstarty+camera.y-20, 20, 20);
                    ctx.fillRect(drawstartx+camera.x+drawareax, drawstarty+camera.y-20, 20, 20);
                    ctx.fillRect(drawstartx+camera.x-20, drawstarty+camera.y+drawareay, 20, 20);
                    ctx.fillRect(drawstartx+camera.x+drawareax, drawstarty+camera.y+drawareay, 20, 20);
                }

               
               if(currentTool!=="lasso"&&currentTool !== 'select'){isDraggingSelection = false;if (selSessionActive) commitSelectionSession();clearSelection();}
               
               
                  // visa urklippet i overlay p√• nuvarande (ev. drag) position
                if (selectionImageCanvas &&selectionBBox) {
                  const showX = isDraggingSelection ? dragSelX : selectionBBox.x;
                  const showY = isDraggingSelection ? dragSelY : selectionBBox.y;

                  const { w, h } = selectionBBox;
                  const p = _imageXYtoCanvasXY(showX, showY);
                  const z = _effectiveZoom();
                  ctx.drawImage(selectionImageCanvas, p.x, p.y, w*z, h*z);

                  // ‚Äúmarching ants‚Äù
                  const p0 = _imageXYtoCanvasXY(showX, showY);
                  const p1 = _imageXYtoCanvasXY(showX + w, showY + h);
                  ctx.save();
                  ctx.setLineDash([4,3]);
                  ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                  ctx.strokeRect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y);
                    const curX = (isDraggingSelection && typeof dragSelX === 'number') ? dragSelX : selectionBBox.x;
                    const curY = (isDraggingSelection && typeof dragSelY === 'number') ? dragSelY : selectionBBox.y;

                    // Om du har ‚Äúpreviews‚Äù f√∂r resize, anv√§nd dem ‚Äì annars fall tillbaka till selectionBBox
                    const curW = (isResizingSelection && typeof rc_prevW === 'number') ? rc_prevW : selectionBBox.w;
                    const curH = (isResizingSelection && typeof rc_prevH === 'number') ? rc_prevH : selectionBBox.h;

                    if (selectionPathImg && selectionOrigBBox && currentTool === 'lasso') {
                      const z = _effectiveZoom();
                      ctx.save();

                      // bild‚Üísk√§rm
                      ctx.translate(drawstartx+camera.x, drawstarty+camera.y);
                      ctx.scale(z, z);

                      // Mappa originalkonturen (selectionPathImg i bildkoordinater)
                      // fr√•n selectionOrigBBox ‚Üí till nuvarande bbox (curX/curY/curW/curH)
                      ctx.translate(curX, curY);
                      ctx.scale(curW / selectionOrigBBox.w, curH / selectionOrigBBox.h);
                      ctx.translate(-selectionOrigBBox.x, -selectionOrigBBox.y);

                      ctx.setLineDash([4,3]);
                      // (valfritt: animera "marching" om du vill)
                      // ctx.lineDashOffset = -(performance.now() / 50) % 7;

                      ctx.strokeStyle = 'rgba(0,0,0,0.9)';
                      ctx.stroke(selectionPathImg);
                      ctx.restore();
                    }
                  ctx.restore();
                  //corners ---NYTT
                    ctx.save();
                    ctx.strokeStyle = 'black';
                    ctx.fillStyle = 'white';
                    ctx.lineWidth = 1;
                    const size = HANDLE_SIZE_SCR; // storlek p√• handtaget
                    const corners = [
                      {x: p0.x, y: p0.y}, // top-left
                      {x: p1.x, y: p0.y}, // top-right
                      {x: p0.x, y: p1.y}, // bottom-left
                      {x: p1.x, y: p1.y} // bottom-right
                    ];
                    for (const c of corners) {
                      ctx.fillRect(c.x - size/2, c.y - size/2, size, size);
                      ctx.strokeRect(c.x - size/2, c.y - size/2, size, size);
                    }
                    ctx.restore();
                }

                if(isdragdrag&&currentTool === 'lasso')_drawLassoOverlay();
                if(isdragdrag&&isRectSelecting&&currentTool === 'select')_drawSelectOverlay();
                drawResizeOverlay();
            
            
            
                window.requestAnimationFrame(check);   
            }; 
            
            check();

           
     //==========LOAD IMAGES MOBILE===========
                
document.addEventListener('DOMContentLoaded', function () {
  const directInput = document.getElementById('directFileInput');
  if (!directInput) return;

  directInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    if (!file.type || !file.type.startsWith('image/')) {
      alert('Filen √§r inte en bild.');
      return;
    }
    try {
      if (typeof beginAction === 'function') beginAction('paste/load');  
      const bmp = await createImageBitmap(file);
      await _activateLoadedBitmap(bmp);
    } catch (err) {
      console.error(err);
      alert('Kunde inte l√§sa bilden.');
    } finally {
      // Nollst√§ll inputen s√• samma fil kan v√§ljas igen
      directInput.value = '';
    }
  });
});
    document.addEventListener('DOMContentLoaded', function() {
    // Get the save button
    const saveBtn = document.getElementById('saveImageBtn');
    
    // Add click event handler for save button
    if (saveBtn) {
        saveBtn.addEventListener('click', function() {
            // Create a temporary canvas for the final image
            const saveCanvas = document.createElement('canvas');
            const saveCtx = saveCanvas.getContext('2d', {alpha: true});
            
            // Set dimensions to match the current drawing area
            const displayWidth = Math.floor(drawareax / zoom);
            const displayHeight = Math.floor(drawareay / zoom);
            saveCanvas.width = displayWidth;
            saveCanvas.height = displayHeight;
            
            // Draw the content WITHOUT filling white background first
            disableSmoothing(saveCtx);
            
            // Just draw the drawing canvas directly   
            saveCtx.drawImage(drawingCanvas, 0, 0, displayWidth, displayHeight, 0, 0, displayWidth, displayHeight);
            
            try {
                // Convert to data URL with PNG format to support transparency
                const dataURL = saveCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'maxpaint-image.png';
                link.href = dataURL;
                link.click();
                console.log("Image saved successfully with transparency");
            } catch (e) {
                console.error("Error saving image:", e);
                alert("Could not save the image. Error: " + e.message);
            }
        });
    }
    
    // Mobile-specific adjustments for the save button
    function adjustButtonsForMobile() {
        const saveBtn = document.getElementById('saveImageBtn');
        const openLabel = document.querySelector('label[for="directFileInput"]');
        
        if (mobileAndTabletCheck()) {
            // Mobile styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "15px 25px";
                saveBtn.style.fontSize = "22px";
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "120px";
            }
            if (openLabel) {
                openLabel.style.padding = "15px 25px";
                openLabel.style.fontSize = "22px"; // Exact same font size
                openLabel.style.top = "15px";
                openLabel.style.minWidth = "120px";
            }
        } else {
            // Desktop styling - keep the buttons the same size and font
            if (saveBtn) {
                saveBtn.style.padding = "8px 15px";
                saveBtn.style.fontSize = "16px"; // Exact same font size
                saveBtn.style.top = "80px"; // Positioned much lower
                saveBtn.style.minWidth = "90px";
            }
            if (openLabel) {
                openLabel.style.padding = "8px 15px";
                openLabel.style.fontSize = "16px"; // Exact same font size
                openLabel.style.top = "10px";
                openLabel.style.minWidth = "90px";
            }
        }
    }
    
    // Call initially
    adjustButtonsForMobile();
    
    // Also adjust when window is resized
    window.addEventListener('resize', adjustButtonsForMobile);
});



    
           // ===== END MOBILE DEVICE SUPPORT =====
            resizeCanvas();
            
        </script>


<script>


(function initMainToolSidebar(){
  const bar = document.getElementById('mainToolBar');
  if (!bar) return;

  // --- UI helper
  function setActive(tool){
    bar.querySelectorAll('[data-tool]').forEach(b=>{
      const on = b.dataset.tool === tool;
      b.classList.toggle('is-active', on);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
  }
  // g√∂r √•tkomlig f√∂r andra hooks
  window.__setSidebarActive = setActive;

  // --- Klick p√• knappar
  bar.addEventListener('click', (e)=>{
    const btn = e.target.closest('[data-tool]');
    if (!btn) return;
    const tool = btn.dataset.tool;

    // anv√§nd din befintliga switchTool om den finns
    if (typeof window.switchTool === 'function') {
      window.switchTool(tool);
    } else {
      window.currentTool = tool;
    }
    // trigga global sync
    window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool } }));
  });

  ['pointerdown','mousedown','touchstart'].forEach(ev=>{
    bar.addEventListener(ev, e=>e.stopPropagation(), {passive:false});
  });

  // --- Globalt event ‚Üí uppdatera sidomenyn
  window.addEventListener('toolchange', (e)=>{
    const t = (e && e.detail && e.detail.tool) || window.currentTool || 'pen';
    setActive(t);
  });

  // --- Hooka nuvarande switchTool om den redan finns
  function wrapExistingSwitch(){
    if (typeof window.switchTool === 'function' && !window.__wrappedSwitchTool){
      const orig = window.switchTool;
      window.switchTool = function(tool){
        const out = orig.apply(this, arguments);
        window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool } }));
        return out;
      };
      window.__wrappedSwitchTool = true;
    }
  }
  wrapExistingSwitch();



  // --- Fallback: om kod byter currentTool direkt utan switchTool
  (function pollCurrentTool(){
    let last = window.currentTool || null;
    setInterval(()=>{
      const now = window.currentTool || null;
      if (now !== last){
        last = now;
        window.dispatchEvent(new CustomEvent('toolchange', { detail:{ tool: now } }));
      }
    }, 200);
  })();

  // Initiera aktiv knapp
  setActive(window.currentTool || 'pen');
  
  
  
  
})();



</script>


<script>
  // Registrera service worker
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js').catch(console.error);
    });
  }

  // Enkel iOS-hint (visas bara i Safari n√§r appen EJ √§r installerad)
  (function showIOSInstallHint(){
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isStandalone = window.navigator.standalone === true;
    if (!isIOS || isStandalone) return;

    const hint = document.createElement('div');
    hint.style.cssText = `
      position:fixed;left:50%;bottom:16px;transform:translateX(-50%);
      background:#000c;border:1px solid #444;color:#fff;padding:10px 14px;
      border-radius:12px;font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index:9999;backdrop-filter: blur(6px);
    `;
    hint.textContent = 'Installera appen: Dela-knappen ‚Üí ‚ÄúL√§gg till p√• hemsk√§rmen‚Äù';
    document.body.appendChild(hint);
    setTimeout(()=>hint.remove(), 7000);
  })();

  // Android ‚ÄúBeforeInstallPrompt‚Äù (frivillig)
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    // Visa egen knapp i din UI om du vill: ‚ÄúInstallera‚Äù. N√§r anv√§ndaren klickar:
    // deferredPrompt.prompt(); deferredPrompt = null;
  });
</script>


</body>
</html>