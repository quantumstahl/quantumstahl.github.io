<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Failsafe Draw → Camera</title>
<style>
  html, body { margin:0; height:100dvh; overflow:hidden; background:#111; }
  #stage { width:100%; height:100%; display:block; touch-action:none; image-rendering:pixelated; }
  #diag { position:fixed; left:8px; bottom:8px; background:rgba(0,0,0,.65); color:#fff;
          font:12px/1.2 system-ui,monospace; padding:6px 8px; border-radius:8px; user-select:none; pointer-events:none; }
</style>
</head>
<body>
<canvas id="stage"></canvas>
<div id="diag">boot…</div>

<script>
(() => {
/*** === VÄXLA HÄR === ***/
const USE_CAMERA = true;   // börja med false → du MÅSTE se ritning direkt.

/*** === Grundcanvas === ***/
const cv  = document.getElementById('stage');
const ctx = cv.getContext('2d', { alpha:false }); // så bakgrund fyller svart; vi fyller själva
const diag = document.getElementById('diag');
// 1) Kamera

const camera = { x:0, y:0, scale:1 };
// 2) Backbuffer (bilden)
const back = document.createElement('canvas');
back.width = 3000; back.height = 2000;
const bctx = back.getContext('2d');

// Tydlig bas – ljus bakgrund + checker
bctx.fillStyle = "#f0f0f0";
bctx.fillRect(0,0,back.width,back.height);
for(let y=0;y<back.height;y+=100){
  for(let x=0;x<back.width;x+=100){
    bctx.fillStyle = ((x/100 + y/100) % 2) ? "#e0e0e0" : "#ffffff";
    bctx.fillRect(x,y,100,100);
  }
}
bctx.fillStyle = "#222";
bctx.font = "28px system-ui";
bctx.fillText("Camera/backbuffer-läge – rita för att testa", 24, 48);



function fitCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const vw = Math.floor((window.visualViewport?.width  ?? window.innerWidth));
  const vh = Math.floor((window.visualViewport?.height ?? window.innerHeight));
  const W  = Math.max(1, Math.floor(vw * dpr));
  const H  = Math.max(1, Math.floor(vh * dpr));
  if (cv.width !== W || cv.height !== H){
    cv.width = W; cv.height = H;
    cv.style.width = vw+'px';
    cv.style.height = vh+'px';
    // Gör 1 canvas-enhet = 1 CSS-px
    ctx.setTransform(dpr,0,0,dpr,0,0);
    render();
  }
}
window.addEventListener('resize', fitCanvas);
window.visualViewport?.addEventListener('resize', fitCanvas);
window.addEventListener('orientationchange', () => setTimeout(fitCanvas, 50));
fitCanvas();

/*** === Hjälp för diag === ***/
function setDiag(msg){
  const dpr = (window.devicePixelRatio||1).toFixed(2);
  const vw = Math.round(window.visualViewport?.width || window.innerWidth);
  const vh = Math.round(window.visualViewport?.height|| window.innerHeight);
  diag.textContent = `${msg} | dpr=${dpr} | vw=${vw}×${vh}`;
}

/*** === Läge A: DIREKT RITA I SKÄRM-SPACE (garanterad synlighet) === ***/
if (!USE_CAMERA){
  let drawing = false, last = null;

  function render(){
    // Tydlig bakgrund (inte nästan-svart)
    const vw = cv.style.width ? parseInt(cv.style.width) : window.innerWidth;
    const vh = cv.style.height? parseInt(cv.style.height): window.innerHeight;
    const grd = ctx.createLinearGradient(0,0, vw, vh);
    grd.addColorStop(0, "#283593"); // blå
    grd.addColorStop(1, "#26c6da"); // cyan
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,vw,vh);

    // Demo-grafik (vit ruta + text)
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(16,16,140,56);
    ctx.fillStyle = "#000";
    ctx.font = "16px system-ui";
    ctx.fillText("Rita här med fingret", 26, 48);
    setDiag('screen-mode');
  }

  function drawSeg(x, y){
    ctx.strokeStyle = "#ff5252"; // röd
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    if (last) ctx.moveTo(last.x, last.y); else ctx.moveTo(x,y);
    ctx.lineTo(x,y);
    ctx.stroke();
    last = {x,y};
  }

  cv.addEventListener('pointerdown', e=>{
    e.preventDefault();
    cv.setPointerCapture(e.pointerId);
    drawing = true; last = null;
    drawSeg(e.clientX, e.clientY);
  }, {passive:false});

  cv.addEventListener('pointermove', e=>{
    if(!drawing) return;
    e.preventDefault();
    drawSeg(e.clientX, e.clientY);
  }, {passive:false});

  function end(e){
    if(!drawing) return;
    e?.preventDefault?.();
    try{ e?.pointerId!=null && cv.releasePointerCapture(e.pointerId);}catch{}
    drawing = false; last = null;
  }
  cv.addEventListener('pointerup', end, {passive:false});
  cv.addEventListener('pointercancel', end, {passive:false});
  cv.addEventListener('touchcancel', end, {passive:false});

  render();
  return; // <-- klara här i screen-mode
}



// 3) Hjälpare
function screenToImage(sx, sy){
  const r = cv.getBoundingClientRect();
  const px = sx - r.left, py = sy - r.top;
  return { ix: px / camera.scale + camera.x, iy: py / camera.scale + camera.y };
}

// 4) Render
function render(){
  // täck hela skärmen med något så svart inte syns
  const vw = cv.style.width ? parseInt(cv.style.width) : window.innerWidth;
  const vh = cv.style.height? parseInt(cv.style.height): window.innerHeight;
  ctx.fillStyle = "#222";
  ctx.fillRect(0,0,vw,vh);

  ctx.save();
  ctx.scale(camera.scale, camera.scale);
  ctx.translate(-camera.x, -camera.y);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(back, 0, 0);
  ctx.restore();

  setDiag(`camera-mode cam=(${camera.x.toFixed(1)},${camera.y.toFixed(1)}) scale=${camera.scale.toFixed(2)}`);
}

// 5) Rita på backbuffer (bild-space)
let drawing = false, lastImg = null;
const BRUSH = { color:"#e91e63", size: 18 };

function drawSegImg(ix, iy){
  bctx.strokeStyle = BRUSH.color;
  bctx.lineWidth   = BRUSH.size;
  bctx.lineCap     = "round";
  bctx.lineJoin    = "round";
  bctx.beginPath();
  if (lastImg) bctx.moveTo(lastImg.x, lastImg.y); else bctx.moveTo(ix,iy);
  bctx.lineTo(ix,iy);
  bctx.stroke();
  lastImg = {x:ix, y:iy};
}

// --- Gesture state (ersätt din gamla) ---
// --- Gesture state (stabil pan/pinch) ---
const activePointers = new Map(); // id -> {x,y}
let gesture = null;               // null | {mode:'pan'|'pinch', ...}

const PINCH_DEADZONE = 0.03;   // ±3% distans ⇒ fortfarande PAN
const PINCH_HYST     = 0.06;   // >6% från start ⇒ lås till PINCH (ingen flop)
const MIN_MOVE_PX    = 0.5;    // ignorera micro-rörelser (skärmpx)
const SCALE_MIN = 0.25, SCALE_MAX = 20;

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function mid(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
function smooth(prev, target, alpha=0.35){ return prev + (target - prev)*alpha; }

function beginTwoFingerGesture(){
  const [p1,p2] = [...activePointers.values()];
  const startMid = mid(p1,p2);
  const startDist = Math.max(dist(p1,p2), 1);

  const startScale = camera.scale;
  const startCam   = { x: camera.x, y: camera.y };
  const rect = cv.getBoundingClientRect(); // frys så adressfältet inte ruckar

  // Funktion som konverterar skärm→bild med startens kamera/scale (för anchor)
  function s2i_fixed(sx, sy){
    const px = sx - rect.left, py = sy - rect.top;
    return { ix: px / startScale + startCam.x, iy: py / startScale + startCam.y };
  }

  gesture = {
    mode: null,               // bestäms vid första move
    startDist, startMid,
    prevMid: { ...startMid }, // för pan
    startScale, startCam, rect,
    anchor: null,             // sätts om vi går till pinch
    lastScale: startScale
  };
}

cv.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  cv.setPointerCapture(e.pointerId);
  activePointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

  if (activePointers.size === 1){
    // En-finger: rita
    drawing = true; lastImg = null;
    const { ix, iy } = screenToImage(e.clientX, e.clientY);
    drawSegImg(ix, iy);
    render();
  } else if (activePointers.size === 2){
    // Två fingrar: börja gesto
    drawing = false;
    beginTwoFingerGesture();
  }
}, {passive:false});

cv.addEventListener('pointermove', (e)=>{
  const p = activePointers.get(e.pointerId);
  if (!p) return;
  e.preventDefault();
  p.x = e.clientX; p.y = e.clientY;

  // En-finger ritning
  if (activePointers.size === 1 && drawing){
    const { ix, iy } = screenToImage(e.clientX, e.clientY);
    drawSegImg(ix, iy);
    render();
    return;
  }

  if (activePointers.size === 2 && gesture){
    const [a,b] = [...activePointers.values()];
    const curMid  = mid(a,b);
    const curDist = Math.max(dist(a,b), 1);
    const ratio   = curDist / gesture.startDist;     // 1.00 ≈ samma avstånd
    const deltaMidX = curMid.x - gesture.prevMid.x;
    const deltaMidY = curMid.y - gesture.prevMid.y;

    // Bestäm läge
    if (gesture.mode === null){
      if (Math.abs(ratio - 1) <= PINCH_DEADZONE){
        gesture.mode = 'pan';
      } else if (Math.abs(ratio - 1) >= PINCH_HYST){
        gesture.mode = 'pinch';
        // Sätt anchor vid övergång till pinch
        const s2i = (sx,sy)=>{
          const px = sx - gesture.rect.left, py = sy - gesture.rect.top;
          return {
            ix: px / gesture.startScale + gesture.startCam.x,
            iy: py / gesture.startScale + gesture.startCam.y
          };
        };
        gesture.anchor = s2i(gesture.startMid.x, gesture.startMid.y);
      } else {
        // Mellanläge: bete dig som pan tills vi säkert är pinch
        gesture.mode = 'pan';
      }
    } else if (gesture.mode === 'pan') {
      // Uppgradera till pinch om vi passerar hysteresis
      if (Math.abs(ratio - 1) >= PINCH_HYST){
        gesture.mode = 'pinch';
        const s2i = (sx,sy)=>{
          const px = sx - gesture.rect.left, py = sy - gesture.rect.top;
          return {
            ix: px / gesture.startScale + gesture.startCam.x,
            iy: py / gesture.startScale + gesture.startCam.y
          };
        };
        gesture.anchor = s2i(gesture.prevMid.x, gesture.prevMid.y);
      }
    }
    // OBS: vi nedgraderar aldrig från pinch → pan i samma gesto (ingen flop)

    if (gesture.mode === 'pan'){
      // Ignorera super-små rörelser (eliminera jitter)
      if (Math.abs(deltaMidX) > MIN_MOVE_PX || Math.abs(deltaMidY) > MIN_MOVE_PX){
        camera.x -= deltaMidX / camera.scale;
        camera.y -= deltaMidY / camera.scale;
        gesture.prevMid = { ...curMid };
        render();
      }
      return;
    }

    // === PINCH ===
    const unclamped = gesture.startScale * ratio;
    const targetScale = Math.min(Math.max(unclamped, SCALE_MIN), SCALE_MAX);
    const newScale = smooth(gesture.lastScale, targetScale, 0.35);
    gesture.lastScale = newScale;
    camera.scale = newScale;

    // Håll anchor under nuvarande mittpunkt
    camera.x = gesture.anchor.ix - (curMid.x - gesture.rect.left) / camera.scale;
    camera.y = gesture.anchor.iy - (curMid.y - gesture.rect.top)  / camera.scale;

    gesture.prevMid = { ...curMid };
    render();
  }
}, {passive:false});

function endPointer(e){
  e?.preventDefault?.();
  try { e?.pointerId!=null && cv.releasePointerCapture(e.pointerId); } catch {}
  activePointers.delete(e.pointerId);
  if (activePointers.size < 2) gesture = null;
  if (activePointers.size === 0) { drawing = false; lastImg = null; }
}
cv.addEventListener('pointerup', endPointer, {passive:false});
cv.addEventListener('pointercancel', endPointer, {passive:false});
cv.addEventListener('touchcancel', endPointer, {passive:false});

// 6) demo: piltangenter pan, +/- zoom (desktop)
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  camera.x -= 50;
  if(e.key==='ArrowRight') camera.x += 50;
  if(e.key==='ArrowUp')    camera.y -= 50;
  if(e.key==='ArrowDown')  camera.y += 50;
  if(e.key==='+' || e.key==='=') zoomAt(window.innerWidth/2, window.innerHeight/2, 1.2);
  if(e.key==='-')          zoomAt(window.innerWidth/2, window.innerHeight/2, 1/1.2);
  render();
});
function zoomAt(sx, sy, factor){
  const before = screenToImage(sx, sy);
  camera.scale = Math.min(Math.max(camera.scale * factor, 0.25), 20);
  const after  = screenToImage(sx, sy);
  camera.x += before.ix - after.ix;
  camera.y += before.iy - after.iy;
}

render();
})();
</script>
</body>
</html>