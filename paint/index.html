<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <!-- Exakt en viewport-rad -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Stable Canvas Shell</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      padding: 0;
      /* 100dvh undviker iOS adressfälts-hop */
      height: 100dvh;
      overflow: hidden;       /* ingen scroll */
      background: #111;
      touch-action: auto;     /* låt sidan vara normal */
    }
    /* Endast canvasen stänger av gester */
    #stage {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;            /* kritiskt: inga pinch/scroll på canvas */
      image-rendering: pixelated;
      background: #2b2b2b;
    }

    /* Liten diag-overlay (kan tas bort) */
    #diag {
      position: fixed; left: 8px; bottom: 8px;
      font: 12px/1.2 system-ui, sans-serif;
      color: #ddd; background: rgba(0,0,0,.6);
      padding: 6px 8px; border-radius: 8px;
      pointer-events: none; user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div id="diag">init…</div>

  <script>
  (function(){
    // ---------- Grund: DPI-säker resize utan jitter ----------
    const dpr = () => (window.devicePixelRatio || 1);
    const cv = document.getElementById('stage');
    const ctx = cv.getContext('2d', { alpha: false, desynchronized: true });
    let cw = 0, ch = 0;

    function resizeCanvas() {
      // Använd visuella viewporten om den finns (iOS säkrare)
      const vw = (window.visualViewport?.width || window.innerWidth);
      const vh = (window.visualViewport?.height || window.innerHeight);
      const ratio = dpr();

      const targetW = Math.max(1, Math.floor(vw * ratio));
      const targetH = Math.max(1, Math.floor(vh * ratio));
      if (cv.width !== targetW || cv.height !== targetH) {
        cv.width = targetW; cv.height = targetH;
        cv.style.width = vw + 'px';
        cv.style.height = vh + 'px';
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // 1 CSS-px == 1 enhet
        cw = vw; ch = vh;
        render(); // rita om
      }
    }

    // Debounce på viewport-förändringar (iOS adressfält)
    let rezId = 0;
    function scheduleResize() {
      cancelAnimationFrame(rezId);
      rezId = requestAnimationFrame(resizeCanvas);
    }
    window.addEventListener('resize', scheduleResize);
    window.visualViewport?.addEventListener('resize', scheduleResize);
    window.addEventListener('orientationchange', () => {
      // vänta ett tick efter orientationchange
      setTimeout(resizeCanvas, 50);
    });

    // ---------- Stabil pointer-hantering (alla plattformar) ----------
    let drawing = false;
    let last = null;

    // Viktigt: passive:false + preventDefault inne i handlers
    cv.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      cv.setPointerCapture(e.pointerId);
      drawing = true;
      last = { x: e.clientX, y: e.clientY };
      dot(last.x, last.y);
      updateDiag('down');
    }, { passive: false });

    cv.addEventListener('pointermove', (e) => {
      if (!drawing) return;
      e.preventDefault();
      const p = { x: e.clientX, y: e.clientY };
      line(last, p);
      last = p;
    }, { passive: false });

    function endStroke(e){
      if (!drawing) return;
      e?.preventDefault?.();
      try { e?.pointerId != null && cv.releasePointerCapture(e.pointerId); } catch {}
      drawing = false;
      last = null;
      updateDiag('up/cancel');
    }

    cv.addEventListener('pointerup', endStroke, { passive: false });
    cv.addEventListener('pointercancel', endStroke, { passive: false });
    // Extra skydd (Safari kan slänga touchcancel/leave)
    cv.addEventListener('touchcancel', endStroke, { passive: false });
    cv.addEventListener('pointerleave', (e) => { if (drawing) endStroke(e); }, { passive:false });

    // På UI-knappar (om du har sådana): använd touch-action: manipulation i CSS

    // ---------- Ritstubs (ersätt med din logik) ----------
    function render() {
      ctx.fillStyle = '#202020';
      ctx.fillRect(0, 0, cw, ch);
      ctx.fillStyle = '#3c7';
      ctx.fillRect(10, 10, 140, 40);
      ctx.fillStyle = '#fff';
      ctx.font = '16px system-ui';
      ctx.fillText('Stable shell – rita för att testa input', 20, 36);
    }
    function dot(x, y) {
      ctx.fillStyle = '#f55';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI*2);
      ctx.fill();
    }
    function line(a, b) {
      ctx.strokeStyle = '#6af';
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    // ---------- Diag / watchdog ----------
    const diag = document.getElementById('diag');
    let lastEventTs = performance.now();
    function updateDiag(tag){
      lastEventTs = performance.now();
      diag.textContent = [
        `evt: ${tag}`,
        `dpr=${dpr().toFixed(2)}`,
        `vw=${Math.round(window.visualViewport?.width||window.innerWidth)}×${Math.round(window.visualViewport?.height||window.innerHeight)}`,
        `cv=${cv.width}×${cv.height}`,
      ].join('  |  ');
    }
    // Liten häng-detektor: om vi ritar och inga event på 1200ms → släpp stroke
    setInterval(() => {
      if (drawing && performance.now() - lastEventTs > 1200) {
        drawing = false; last = null;
        updateDiag('watchdog-end');
      }
    }, 600);

    // ---------- Start ----------
    resizeCanvas();
    updateDiag('boot');
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState !== 'visible') { drawing = false; last = null; }
    });

  })();
  </script>
</body>
</html>