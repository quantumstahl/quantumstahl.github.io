<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Failsafe Draw → Camera</title>
<style>
  html, body { margin:0; height:100dvh; overflow:hidden; background:#111; }
  #stage { width:100%; height:100%; display:block; touch-action:none; image-rendering:pixelated; }
  #diag { position:fixed; left:8px; bottom:8px; background:rgba(0,0,0,.65); color:#fff;
          font:12px/1.2 system-ui,monospace; padding:6px 8px; border-radius:8px; user-select:none; pointer-events:none; }
</style>
</head>
<body>
<canvas id="stage"></canvas>
<div id="diag">boot…</div>

<script>
(() => {
/*** === VÄXLA HÄR === ***/
const USE_CAMERA = true;   // börja med false → du MÅSTE se ritning direkt.

/*** === Grundcanvas === ***/
const cv  = document.getElementById('stage');
const ctx = cv.getContext('2d', { alpha:false }); // så bakgrund fyller svart; vi fyller själva
const diag = document.getElementById('diag');
// 1) Kamera

const camera = { x:0, y:0, scale:1 };
// 2) Backbuffer (bilden)
const back = document.createElement('canvas');
back.width = 3000; back.height = 2000;
const bctx = back.getContext('2d');

// Tydlig bas – ljus bakgrund + checker
bctx.fillStyle = "#f0f0f0";
bctx.fillRect(0,0,back.width,back.height);
for(let y=0;y<back.height;y+=100){
  for(let x=0;x<back.width;x+=100){
    bctx.fillStyle = ((x/100 + y/100) % 2) ? "#e0e0e0" : "#ffffff";
    bctx.fillRect(x,y,100,100);
  }
}
bctx.fillStyle = "#222";
bctx.font = "28px system-ui";
bctx.fillText("Camera/backbuffer-läge – rita för att testa", 24, 48);



function fitCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const vw = Math.floor((window.visualViewport?.width  ?? window.innerWidth));
  const vh = Math.floor((window.visualViewport?.height ?? window.innerHeight));
  const W  = Math.max(1, Math.floor(vw * dpr));
  const H  = Math.max(1, Math.floor(vh * dpr));
  if (cv.width !== W || cv.height !== H){
    cv.width = W; cv.height = H;
    cv.style.width = vw+'px';
    cv.style.height = vh+'px';
    // Gör 1 canvas-enhet = 1 CSS-px
    ctx.setTransform(dpr,0,0,dpr,0,0);
    render();
  }
}
window.addEventListener('resize', fitCanvas);
window.visualViewport?.addEventListener('resize', fitCanvas);
window.addEventListener('orientationchange', () => setTimeout(fitCanvas, 50));
fitCanvas();

/*** === Hjälp för diag === ***/
function setDiag(msg){
  const dpr = (window.devicePixelRatio||1).toFixed(2);
  const vw = Math.round(window.visualViewport?.width || window.innerWidth);
  const vh = Math.round(window.visualViewport?.height|| window.innerHeight);
  diag.textContent = `${msg} | dpr=${dpr} | vw=${vw}×${vh}`;
}

/*** === Läge A: DIREKT RITA I SKÄRM-SPACE (garanterad synlighet) === ***/
if (!USE_CAMERA){
  let drawing = false, last = null;

  function render(){
    // Tydlig bakgrund (inte nästan-svart)
    const vw = cv.style.width ? parseInt(cv.style.width) : window.innerWidth;
    const vh = cv.style.height? parseInt(cv.style.height): window.innerHeight;
    const grd = ctx.createLinearGradient(0,0, vw, vh);
    grd.addColorStop(0, "#283593"); // blå
    grd.addColorStop(1, "#26c6da"); // cyan
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,vw,vh);

    // Demo-grafik (vit ruta + text)
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(16,16,140,56);
    ctx.fillStyle = "#000";
    ctx.font = "16px system-ui";
    ctx.fillText("Rita här med fingret", 26, 48);
    setDiag('screen-mode');
  }

  function drawSeg(x, y){
    ctx.strokeStyle = "#ff5252"; // röd
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    if (last) ctx.moveTo(last.x, last.y); else ctx.moveTo(x,y);
    ctx.lineTo(x,y);
    ctx.stroke();
    last = {x,y};
  }

  cv.addEventListener('pointerdown', e=>{
    e.preventDefault();
    cv.setPointerCapture(e.pointerId);
    drawing = true; last = null;
    drawSeg(e.clientX, e.clientY);
  }, {passive:false});

  cv.addEventListener('pointermove', e=>{
    if(!drawing) return;
    e.preventDefault();
    drawSeg(e.clientX, e.clientY);
  }, {passive:false});

  function end(e){
    if(!drawing) return;
    e?.preventDefault?.();
    try{ e?.pointerId!=null && cv.releasePointerCapture(e.pointerId);}catch{}
    drawing = false; last = null;
  }
  cv.addEventListener('pointerup', end, {passive:false});
  cv.addEventListener('pointercancel', end, {passive:false});
  cv.addEventListener('touchcancel', end, {passive:false});

  render();
  return; // <-- klara här i screen-mode
}



// 3) Hjälpare
function screenToImage(sx, sy){
  const r = cv.getBoundingClientRect();
  const px = sx - r.left, py = sy - r.top;
  return { ix: px / camera.scale + camera.x, iy: py / camera.scale + camera.y };
}

// 4) Render
function render(){
  // täck hela skärmen med något så svart inte syns
  const vw = cv.style.width ? parseInt(cv.style.width) : window.innerWidth;
  const vh = cv.style.height? parseInt(cv.style.height): window.innerHeight;
  ctx.fillStyle = "#222";
  ctx.fillRect(0,0,vw,vh);

  ctx.save();
  ctx.scale(camera.scale, camera.scale);
  ctx.translate(-camera.x, -camera.y);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(back, 0, 0);
  ctx.restore();

  setDiag(`camera-mode cam=(${camera.x.toFixed(1)},${camera.y.toFixed(1)}) scale=${camera.scale.toFixed(2)}`);
}

// 5) Rita på backbuffer (bild-space)
let drawing = false, lastImg = null;
const BRUSH = { color:"#e91e63", size: 18 };

function drawSegImg(ix, iy){
  bctx.strokeStyle = BRUSH.color;
  bctx.lineWidth   = BRUSH.size;
  bctx.lineCap     = "round";
  bctx.lineJoin    = "round";
  bctx.beginPath();
  if (lastImg) bctx.moveTo(lastImg.x, lastImg.y); else bctx.moveTo(ix,iy);
  bctx.lineTo(ix,iy);
  bctx.stroke();
  lastImg = {x:ix, y:iy};
}

// --- Gesture state (ersätt din gamla) ---
const activePointers = new Map(); // id -> {x,y}
let gesture = null;               // null | {...}

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function mid(a,b){ return { sx:(a.x+b.x)/2, sy:(a.y+b.y)/2 }; }

// Liten smoothing så det känns mjukt men responsivt
function smooth(prev, target, alpha=0.35){ return prev + (target - prev)*alpha; }

// Pinch-setup: kalla när andra fingret går ned
function beginPinch(){
  const [p1,p2] = [...activePointers.values()];
  const startMid = mid(p1,p2);
  const startDist = Math.max(dist(p1,p2), 1);

  // Viktigt: räkna anchor i bild-koord utifrån START-kameran
  const startScale = camera.scale;
  const startCam = { x: camera.x, y: camera.y };

  // screenToImage men fryst på startCam/startScale:
  const rect = cv.getBoundingClientRect();           // frys rect (adressfältet kan flytta!)
  function s2i_fixed(sx, sy){
    const px = sx - rect.left, py = sy - rect.top;
    return {
      ix: px / startScale + startCam.x,
      iy: py / startScale + startCam.y
    };
  }
  const anchor = s2i_fixed(startMid.sx, startMid.sy);

  gesture = { startDist, startMid, startScale, startCam, anchor, lastScale: startScale, rect };
}

// Använd i pointerdown/pointermove/pointerup enligt nedan
cv.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  cv.setPointerCapture(e.pointerId);
  activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

  if (activePointers.size === 1) {
    // en-finger: rita
    drawing = true; lastImg = null;
    const { ix, iy } = screenToImage(e.clientX, e.clientY);
    drawSegImg(ix, iy);
    render();
  } else if (activePointers.size === 2) {
    // två fingrar: börja pinch
    drawing = false;
    beginPinch();
  }
}, { passive:false });

cv.addEventListener('pointermove', (e)=>{
  const p = activePointers.get(e.pointerId);
  if (!p) return;
  e.preventDefault();
  p.x = e.clientX; p.y = e.clientY;

  if (activePointers.size === 1 && drawing) {
    const { ix, iy } = screenToImage(e.clientX, e.clientY);
    drawSegImg(ix, iy);
    render();
    return;
  }

  if (activePointers.size === 2 && gesture) {
    const [a,b] = [...activePointers.values()];
    const curMid = mid(a,b);
    const curDist = Math.max(dist(a,b), 1);

    // 1) ny skala relativt START-dist/START-scale (ingen feedback)
    const unclamped = gesture.startScale * (curDist / gesture.startDist);
    const targetScale = Math.min(Math.max(unclamped, 0.25), 20);

    // valfri smoothing för att undvika "flimmer"
    const newScale = smooth(gesture.lastScale, targetScale, 0.35);
    gesture.lastScale = newScale;
    camera.scale = newScale;

    // 2) placera kameran så att START-ankaret hamnar under NUVARANDE mitt
    //    anchor (i bildpx) ska mappa till curMid (i skärmpx):
    //    (anchor.ix - camera.x) * camera.scale = curMid.sx
    // => camera.x = anchor.ix - curMid.sx / camera.scale   (samma för y)
    camera.x = gesture.anchor.ix - (curMid.sx - gesture.rect.left) / camera.scale;
    camera.y = gesture.anchor.iy - (curMid.sy - gesture.rect.top)  / camera.scale;

    // (valfritt) klamma kameran till bildens kanter:
    // clampCamera();

    render();
  }
}, { passive:false });

function endPointer(e){
  e?.preventDefault?.();
  try { e?.pointerId!=null && cv.releasePointerCapture(e.pointerId); } catch {}
  activePointers.delete(e.pointerId);

  if (activePointers.size < 2) gesture = null;
  if (activePointers.size === 0) { drawing = false; lastImg = null; }
}
cv.addEventListener('pointerup', endPointer, { passive:false });
cv.addEventListener('pointercancel', endPointer, { passive:false });
cv.addEventListener('touchcancel', endPointer, { passive:false });

// 6) demo: piltangenter pan, +/- zoom (desktop)
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft')  camera.x -= 50;
  if(e.key==='ArrowRight') camera.x += 50;
  if(e.key==='ArrowUp')    camera.y -= 50;
  if(e.key==='ArrowDown')  camera.y += 50;
  if(e.key==='+' || e.key==='=') zoomAt(window.innerWidth/2, window.innerHeight/2, 1.2);
  if(e.key==='-')          zoomAt(window.innerWidth/2, window.innerHeight/2, 1/1.2);
  render();
});
function zoomAt(sx, sy, factor){
  const before = screenToImage(sx, sy);
  camera.scale = Math.min(Math.max(camera.scale * factor, 0.25), 20);
  const after  = screenToImage(sx, sy);
  camera.x += before.ix - after.ix;
  camera.y += before.iy - after.iy;
}

render();
})();
</script>
</body>
</html>